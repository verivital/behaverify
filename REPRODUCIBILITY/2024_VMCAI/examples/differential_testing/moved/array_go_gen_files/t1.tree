configuration{}
enumerations {
	'yes', 'no', 'both'
}
constants {
	'MIN_VAL' := 2,
	'MAX_VAL' := 5
}
variables { 
	variable { bl blVAR0 array 3 VAR {'yes', 'no', 'both'}
		per_index
		assign {
			case {(greater_than, (min, 100, (max, -100, (max, 2, -15))), (min, 100, (max, -100, (min, 89, -4))))} result { 'no'}
			case {(equal, 2, -100)} result { 'both'}
			result {'yes'}
		}
		assign {
			case {False} result { 'no'}
			case {True} result { 'yes'}
			result {'no'}
		}
		assign {
			case {(greater_than_or_equal, 2, 2)} result { 'yes'}
			result {'yes'}
		}
	}
	variable { env envVAR1 array 3 VAR [-5, -2]
		per_index
		assign {
			result {(min, -2, (max, -5, (min, 100, (max, -100, (multiplication, -4, (min, 100, (max, -100, (abs, -3))), (min, 100, (max, -100, (negative, 5))), (min, 100, (max, -100, (subtraction, 80, -3))))))))}
		}
		assign {
			result {(min, -2, (max, -5, (min, 100, (max, -100, (min, 94, 2)))))}
		}
		assign {
			case {True} result { (min, -2, (max, -5, (count, (equivalent, True, True), (greater_than_or_equal, 3, 4))))}
			case {False} result { (min, -2, (max, -5, 4))}
			result {(min, -2, (max, -5, (min, 100, (max, -100, (abs, -3)))))}
		}
	}
	variable { local localVAR2 VAR [2, 5]
		assign {
			result {(min, 5, (max, 2, (min, 100, (max, -100, (negative, (min, 100, (max, -100, (max, 80, 10))))))))}
		}
	}
	variable { local localDEFINE3 array 2 DEFINE INT
		per_index
		assign {
			case {(less_than_or_equal, -95, 2)} result { (min, -2, (max, -5, (min, 100, (max, -100, (max, (min, 100, (max, -100, (negative, (min, 100, (max, -100, (max, -13, 13)))))), (min, 100, (max, -100, (min, (min, 100, (max, -100, (abs, -3))), -43))))))))}
			result {(min, -2, (max, -5, (count, (xnor, (xor, (xnor, True, False), True), (greater_than_or_equal, 2, -3)), (not_equal, (xnor, False, True), (less_than_or_equal, -2, 4)), (xor, True, (equal, True, (or, True, True))))))}
		}
		assign {
			case {(xor, (and, False, False), False)} result { (min, -2, (max, -5, (count, (xor, (greater_than_or_equal, (min, 100, (max, -100, (max, 76, 2))), (min, 100, (max, -100, (min, -5, 2)))), (equivalent, True, False)), (xnor, (or, True, False), True), (greater_than, (min, 100, (max, -100, (abs, -2))), 2), (implies, False, (and, False, True)))))}
			case {(or, True, (greater_than_or_equal, 41, 34))} result { (min, -2, (max, -5, -37))}
			result {(min, -2, (max, -5, (min, 100, (max, -100, (subtraction, 3, -96)))))}
		}
	}
	variable { env envDEFINE4 DEFINE INT
		assign {
			case {(equal, 'yes', (index, blVAR0, 0))} result { (min, -2, (max, -5, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (min, (index, envVAR1, 0), 5))), (min, 100, (max, -100, (max, 4, (index, envVAR1, 2)))), (min, 100, (max, -100, (max, (min, 100, (max, -100, (subtraction, (index, envVAR1, 0), -13))), (count, (equivalent, True, True), (equal, (index, blVAR0, 0), 'yes'))))))))))}
			case {(implies, True, True)} result { (min, -2, (max, -5, (min, 100, (max, -100, (subtraction, (index, envVAR1, 2), (index, envVAR1, 2))))))}
			result {(min, -2, (max, -5, (index, envVAR1, 2)))}
		}
	}
	variable { bl blDEFINE5 array 2 DEFINE BOOLEAN
		range
		assign {
			result {(less_than, (min, 100, (max, -100, (min, 2, (min, 100, (max, -100, (addition, -9, 24, -39)))))), (min, 100, (max, -100, (abs, 2))))}
		}
	}
}
environment_update {
}
checks{
	check {
		c1
		arguments{}
		read_variables {blVAR0, blDEFINE5}
		condition{(index, blDEFINE5, 1)}
	}
	check {
		c2
		arguments{}
		read_variables {blVAR0, blDEFINE5}
		condition{(index, blDEFINE5, 0)}
	}
}
environment_checks {}
actions{
	action {
		a1
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blDEFINE5}
		initial_values {

		}
		update {
			variable_statement{ blVAR0
				per_index
				index_of { (min, 2, (max, 0, (min, 100, (max, -100, (max, -39, 5)))))}
				assign {
					case {(equal, (index, blVAR0, 0), 'both')} result { (index, blVAR0, 1)}
					case {(less_than_or_equal, 86, 79)} result { (index, blVAR0, 0)}
					result {(index, blVAR0, 0)}
				}
			}
			write_environment {
				a1_write_before_1
				variable_statement{ instant envVAR1
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (min, (min, 100, (max, -100, (min, 66, 94))), (min, 100, (max, -100, (min, -38, (index, envVAR1, 1)))))))))}
					assign {
						case {(greater_than, (min, 100, (max, -100, (multiplication, (index, envVAR1, 1), (min, 100, (max, -100, (min, envDEFINE4, 91))), (index, envVAR1, 0)))), (min, 100, (max, -100, (abs, 83))))} result { (min, -2, (max, -5, (min, 100, (max, -100, (multiplication, envDEFINE4, envDEFINE4)))))}
						result {(min, -2, (max, -5, (count, (implies, False, (index, blDEFINE5, 1)), (or, (index, blDEFINE5, 0), (index, blDEFINE5, 1)), (xnor, (index, blDEFINE5, 1), False), (greater_than, 26, (index, envVAR1, 2)))))}
					}
				}
			}
			variable_statement{ blVAR0
				per_index
				index_of { (min, 2, (max, 0, 4))}
				assign {
					case {(equivalent, True, True)} result { 'both'}
					case {(xor, False, (equivalent, (less_than_or_equal, -95, -33), (index, blDEFINE5, 1)))} result { 'both'}
					result {(index, blVAR0, 0)}
				}
				index_of { (min, 2, (max, 0, (min, 100, (max, -100, (addition, -4, 4, 4)))))}
				assign {
					case {(index, blDEFINE5, 1)} result { 'yes'}
					case {(not_equal, (min, 100, (max, -100, (addition, -3, 3, -4))), 33)} result { (index, blVAR0, 2)}
					result {'yes'}
				}
			}
			return_statement {
				result {success}
			}
			read_environment {
				a1_read_after_0
				condition {(greater_than, envDEFINE4, envDEFINE4)}
				variable_statement{ blVAR0
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (addition, (index, envVAR1, 1), envDEFINE4)))))}
					assign {
						result {'both'}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (abs, (min, 100, (max, -100, (abs, 12))))))))}
					assign {
						result {'yes'}
					}
				}
			}
		}
	}
	action {
		a2
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blDEFINE5}
		initial_values {

		}
		update {
			read_environment {
				a2_read_before_0
				condition {False}
				variable_statement{ blVAR0
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (min, (count, (equal, (index, envVAR1, 2), 83), (equivalent, (less_than, envDEFINE4, envDEFINE4), (equal, False, (index, blDEFINE5, 1))), (less_than_or_equal, (min, 100, (max, -100, (abs, envDEFINE4))), (min, 100, (max, -100, (negative, 1)))), (less_than_or_equal, (min, 100, (max, -100, (addition, -97, (index, envVAR1, 2), 61))), -67)), (min, 100, (max, -100, (addition, -89, 9, (min, 100, (max, -100, (negative, envDEFINE4))), (count, (less_than_or_equal, 36, (index, envVAR1, 2)), (or, False, (index, blDEFINE5, 0)), (equivalent, False, (index, blDEFINE5, 0)), (equal, (index, blDEFINE5, 0), (index, blDEFINE5, 0)))))))))))}
					assign {
						result {'no'}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (negative, (min, 100, (max, -100, (subtraction, -4, 88))))))))}
					assign {
						result {'yes'}
					}
				}
				variable_statement{ blVAR0
					per_index
					index_of { (min, 2, (max, 0, (count, (xnor, (equal, (index, envVAR1, 0), (index, envVAR1, 0)), (index, blDEFINE5, 1)), (less_than_or_equal, (count, (less_than, (min, 100, (max, -100, (subtraction, -15, -29))), -65), (not_equal, (index, blVAR0, 2), (index, blVAR0, 2)), (or, (less_than_or_equal, (index, envVAR1, 0), (index, envVAR1, 0)), False)), (min, 100, (max, -100, (addition, envDEFINE4, -43)))), (less_than, (min, 100, (max, -100, (abs, 97))), (min, 100, (max, -100, (multiplication, envDEFINE4, envDEFINE4, (index, envVAR1, 0), -27)))), (less_than_or_equal, (count, (xor, (index, blDEFINE5, 1), False), (greater_than_or_equal, (min, 100, (max, -100, (negative, envDEFINE4))), (min, 100, (max, -100, (subtraction, envDEFINE4, 96)))), (less_than, (min, 100, (max, -100, (abs, 13))), (count, (xnor, (index, blDEFINE5, 0), (index, blDEFINE5, 1)), (and, True, True), (or, False, True)))), (min, 100, (max, -100, (addition, -8, envDEFINE4)))))))}
					assign {
						case {(equivalent, (index, blDEFINE5, 1), (index, blDEFINE5, 0))} result { (index, blVAR0, 0)}
						case {(equal, 'no', 'no')} result { 'both'}
						result {'no'}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (subtraction, -58, envDEFINE4)))))}
					assign {
						case {(implies, (xnor, False, False), (less_than_or_equal, -36, -61))} result { (index, blVAR0, 2)}
						case {(xor, False, (index, blDEFINE5, 1))} result { 'both'}
						result {(index, blVAR0, 0)}
					}
				}
			}
			return_statement {
				case { (greater_than, 39, -2)} result { failure}
				case { (or, True, (index, blDEFINE5, 1))} result { running}
				case { (and, (index, blDEFINE5, 0), True)} result { running}
				result {failure}
			}
		}
	}
	action {
		a3
		arguments{}
		local_variables {localVAR2}
		read_variables { }
		write_variables {blVAR0, blDEFINE5}
		initial_values {
			variable_statement{ localVAR2
			assign {
				case {(and, (index, blDEFINE5, 1), (less_than, -5, 76))} result { (min, 5, (max, 2, (min, 100, (max, -100, (addition, (min, 100, (max, -100, (multiplication, 60, -2, 5, -74))), (min, 100, (max, -100, (multiplication, 58, 79))), 2, (min, 100, (max, -100, (abs, 3))))))))}
				result {(min, 5, (max, 2, 22))}
			}
			}

		}
		update {
			return_statement {
				case { True} result { success}
				case { (xnor, (xnor, True, (index, blDEFINE5, 1)), (equivalent, (index, blDEFINE5, 1), False))} result { running}
				case { (equivalent, (less_than_or_equal, localVAR2, localVAR2), (implies, (index, blDEFINE5, 1), True))} result { failure}
				result {success}
			}
			write_environment {
				a3_write_after_1
				variable_statement{ instant envVAR1
					per_index
					index_of { (min, 2, (max, 0, -74))}
					assign {
						case {True} result { (min, -2, (max, -5, -91))}
						case {True} result { (min, -2, (max, -5, (min, 100, (max, -100, (subtraction, (min, 100, (max, -100, (abs, (index, envVAR1, 1)))), (min, 100, (max, -100, (abs, 57))))))))}
						result {(min, -2, (max, -5, (min, 100, (max, -100, (min, -53, (min, 100, (max, -100, (multiplication, localVAR2, -2, (index, envVAR1, 2), (index, envVAR1, 0)))))))))}
					}
				}
				variable_statement{ envVAR1
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (addition, localVAR2, 49, (index, envVAR1, 0), (index, envVAR1, 2)))), (min, 100, (max, -100, (max, envDEFINE4, envDEFINE4))), 96, -98)))))}
					assign {
						case {False} result { (min, -2, (max, -5, (count, (xnor, (xnor, (index, blDEFINE5, 0), (index, blDEFINE5, 0)), (xor, False, True)), (less_than_or_equal, 23, (min, 100, (max, -100, (max, 46, 5)))), (greater_than, (index, envVAR1, 0), (count, (less_than_or_equal, envDEFINE4, (index, envVAR1, 2)), (not_equal, 'no', 'both'))))))}
						case {(not_equal, 'yes', (index, blVAR0, 1))} result { (min, -2, (max, -5, (min, 100, (max, -100, (multiplication, (index, envVAR1, 1), envDEFINE4)))))}
						result {(min, -2, (max, -5, -18))}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (subtraction, 32, 67)))))}
					assign {
						case {(xnor, False, (greater_than, (index, envVAR1, 1), envDEFINE4))} result { (min, -2, (max, -5, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (max, (count, (greater_than, localVAR2, 70), (greater_than_or_equal, localVAR2, envDEFINE4)), (min, 100, (max, -100, (negative, localVAR2)))))), (min, 100, (max, -100, (subtraction, 33, -5))))))))}
						case {(xor, (equal, (min, 100, (max, -100, (abs, envDEFINE4))), envDEFINE4), (index, blDEFINE5, 0))} result { (min, -2, (max, -5, (count, (greater_than, envDEFINE4, envDEFINE4), (greater_than_or_equal, localVAR2, (index, envVAR1, 2)))))}
						result {(min, -2, (max, -5, 48))}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (addition, localVAR2, 35, (min, 100, (max, -100, (negative, 21))))))))}
					assign {
						case {(implies, (index, blDEFINE5, 0), (index, blDEFINE5, 1))} result { (min, -2, (max, -5, (min, 100, (max, -100, (subtraction, -24, (index, envVAR1, 1))))))}
						case {(implies, (index, blDEFINE5, 1), (index, blDEFINE5, 0))} result { (min, -2, (max, -5, (min, 100, (max, -100, (addition, 94, -43, 45, 19)))))}
						result {(min, -2, (max, -5, (min, 100, (max, -100, (addition, 19, -93, -3)))))}
					}
				}
				variable_statement{ instant envVAR1
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (addition, (min, 100, (max, -100, (max, -3, envDEFINE4))), (min, 100, (max, -100, (max, localVAR2, (index, envVAR1, 1)))), (min, 100, (max, -100, (max, envDEFINE4, 40)))))), (min, 100, (max, -100, (negative, (min, 100, (max, -100, (abs, -73)))))))))))}
					assign {
						case {(greater_than, (index, envVAR1, 0), localVAR2)} result { (min, -2, (max, -5, (min, 100, (max, -100, (negative, envDEFINE4)))))}
						case {(or, (and, True, (index, blDEFINE5, 1)), (equal, envDEFINE4, -36))} result { (min, -2, (max, -5, (min, 100, (max, -100, (max, 12, -21)))))}
						result {(min, -2, (max, -5, (min, 100, (max, -100, (multiplication, (count, (less_than_or_equal, 71, 80), (greater_than, -33, -99), (implies, (index, blDEFINE5, 0), True), (and, (index, blDEFINE5, 1), (index, blDEFINE5, 1))), (min, 100, (max, -100, (multiplication, envDEFINE4, -95))))))))}
					}
				}
			}
			read_environment {
				a3_read_after_0
				condition {True}
				variable_statement{ blVAR0
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (abs, localVAR2)))))}
					assign {
						result {'both'}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (max, (min, 100, (max, -100, (abs, -39))), (index, envVAR1, 0))))))}
					assign {
						result {(index, blVAR0, 2)}
					}
					index_of { (min, 2, (max, 0, (count, (xor, True, False), (xor, True, (index, blDEFINE5, 1)), (equivalent, (index, blDEFINE5, 0), False), (not_equal, (index, blDEFINE5, 0), (index, blDEFINE5, 1)))))}
					assign {
						result {(index, blVAR0, 1)}
					}
				}
			}
		}
	}
	action {
		a4
		arguments{}
		local_variables {localVAR2, localDEFINE3}
		read_variables { }
		write_variables {blVAR0, blDEFINE5}
		initial_values {

		}
		update {
			return_statement {
				case { (xor, False, (and, False, (index, blDEFINE5, 0)))} result { success}
				result {success}
			}
			read_environment {
				a4_read_after_2
				condition {(greater_than, localVAR2, -26)}
				variable_statement{ localVAR2
				assign {
					result {(min, 5, (max, 2, (min, 100, (max, -100, (negative, (min, 100, (max, -100, (multiplication, envDEFINE4, (index, envVAR1, 2)))))))))}
				}
				}
				variable_statement{ blVAR0
					per_index
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (multiplication, 66, 69))), localVAR2)))))}
					assign {
						case {(not_equal, (index, envVAR1, 1), -52)} result { (index, blVAR0, 0)}
						result {(index, blVAR0, 0)}
					}
					index_of { (min, 2, (max, 0, (min, 100, (max, -100, (abs, (min, 100, (max, -100, (abs, 45))))))))}
					assign {
						case {(equal, (and, True, (index, blDEFINE5, 1)), False)} result { (index, blVAR0, 0)}
						result {'no'}
					}
				}
			}
			variable_statement{ localVAR2
			assign {
				result {(min, 5, (max, 2, (min, 100, (max, -100, (negative, (count, (implies, (index, blDEFINE5, 0), (index, blDEFINE5, 0)), (greater_than, localVAR2, -12), (equal, -21, localVAR2)))))))}
			}
			}
			read_environment {
				a4_read_after_0
				condition {(greater_than_or_equal, 50, (min, 100, (max, -100, (max, 20, 23))))}
				variable_statement{ localVAR2
				assign {
					case {(or, (xor, (index, blDEFINE5, 0), (index, blDEFINE5, 1)), False)} result { (min, 5, (max, 2, (min, 100, (max, -100, (max, (index, localDEFINE3, 0), -20)))))}
					case {(and, (greater_than, envDEFINE4, envDEFINE4), (greater_than_or_equal, 93, localVAR2))} result { (min, 5, (max, 2, (min, 100, (max, -100, (multiplication, (min, 100, (max, -100, (max, (index, envVAR1, 1), (index, envVAR1, 0)))), -95, (min, 100, (max, -100, (addition, localVAR2, localVAR2, -28))), (min, 100, (max, -100, (abs, -74))))))))}
					result {(min, 5, (max, 2, (index, localDEFINE3, 0)))}
				}
				}
			}
		}
	}
}
sub_trees{}
tree {
	composite {
		p_one0
		parallel policy success_on_one
		
		children {
			a3{}
			decorator {
				dec_sf1
				X_is_Y X success Y failure
				child {
					c1{}
				}
			}
			decorator {
				dec_sr2
				X_is_Y X success Y running
				child {
					composite {
						p_one3
						parallel policy success_on_one
						
						children {
							a1{}
							a4{}
							c1{}
						}
					}
				}
			}
		}
	}
}
tick_prerequisite{True}
specifications { #{ INVAR, LTL, and CTL specs go here }# } end_specifications