configuration{}
enumerations {
	'yes', 'no', 'both'
}
constants {
	'MIN_VAL' := 2,
	'MAX_VAL' := 5
}
variables { 
	variable { bl blVAR0 VAR [2, 5]
		assign {
			result {(min, 5, (max, 2, 4))}
		}
	}
	variable { env envVAR1 array 2 VAR BOOLEAN
		per_index
		assign {
			case {(equal, (or, True, False), (equivalent, False, True))} result { (xor, (equal, blVAR0, -44), (equivalent, False, True))}
			case {(not_equal, blVAR0, 24)} result { (equivalent, (less_than_or_equal, 63, 60), True)}
			result {(xor, False, (not_equal, True, (and, True, True)))}
		}
		assign {
			result {(greater_than_or_equal, -94, -17)}
		}
	}
	variable { env envVAR2 VAR {'yes', 'no', 'both'}
		assign {
			result {'no'}
		}
	}
	variable { env envFROZENVAR3 array 3 FROZENVAR {'yes', 'no', 'both'}
		per_index
		assign {
			case {(xnor, False, True)} result { envVAR2}
			result {'no'}
		}
		assign {
			result {envVAR2}
		}
		assign {
			case {True} result { 'both'}
			case {(and, False, False)} result { 'no'}
			result {'no'}
		}
	}
	variable { env envFROZENVAR4 array 3 FROZENVAR [-5, -2]
		range
		assign {
			case {(greater_than, (negative, blVAR0), blVAR0)} result { (min, -2, (max, -5, (abs, blVAR0)))}
			result {(min, -2, (max, -5, (min, blVAR0, blVAR0)))}
		}
	}
	variable { local localDEFINE5 array 2 DEFINE INT
		range
		assign {
			case {(greater_than, -48, -20)} result { (min, 5, (max, 2, -13))}
			result {(min, 5, (max, 2, (min, (subtraction, (min, -97, 68), 39), (max, blVAR0, blVAR0))))}
		}
	}
	variable { bl blDEFINE6 array 2 DEFINE ENUM
		per_index
		assign {
			result {'both'}
		}
		assign {
			result {'no'}
		}
	}
}
environment_update {
}
checks{
	check {
		c1
		arguments{}
		read_variables {blVAR0, blDEFINE6}
		condition{(not_equal, (index, blDEFINE6, 0), (index, blDEFINE6, 0))}
	}
	check {
		c2
		arguments{}
		read_variables {blVAR0, blDEFINE6}
		condition{(equal, (abs, (min, 97, -80)), (negative, (count, (greater_than_or_equal, -4, blVAR0), (greater_than_or_equal, blVAR0, blVAR0), (xnor, False, False))))}
	}
}
environment_checks {}
actions{
	action {
		a1
		arguments{}
		local_variables {localDEFINE5}
		read_variables { }
		write_variables {blVAR0, blDEFINE6}
		initial_values {

		}
		update {
			return_statement {
				case { False} result { failure}
				case { (xor, (greater_than_or_equal, 42, (index, localDEFINE5, 0)), (less_than_or_equal, -100, -7))} result { failure}
				result {running}
			}
			read_environment {
				a1_read_after_0
				condition {(implies, (not_equal, 57, (index, localDEFINE5, 0)), (and, False, (index, envVAR1, 1)))}
				variable_statement{ blVAR0
				assign {
					case {(and, True, (equivalent, True, (index, envVAR1, 0)))} result { (min, 5, (max, 2, (count, (xor, True, (and, False, True)), (not_equal, (max, 55, 2), 38), (equivalent, (greater_than, (count, (not_equal, (index, envVAR1, 0), (index, envVAR1, 1)), (less_than_or_equal, 64, (index, envFROZENVAR4, 2))), -35), False), (greater_than_or_equal, (max, (index, envFROZENVAR4, 0), blVAR0), (subtraction, -84, (max, (index, localDEFINE5, 1), (index, envFROZENVAR4, 2)))))))}
					case {(or, True, True)} result { (min, 5, (max, 2, (max, 10, (subtraction, 90, 95))))}
					result {(min, 5, (max, 2, (count, (implies, True, (xor, (index, envVAR1, 0), (index, envVAR1, 0))), (or, (less_than_or_equal, 17, -47), (greater_than_or_equal, blVAR0, blVAR0)), (greater_than_or_equal, (addition, 44, 55, blVAR0, (index, localDEFINE5, 1)), (max, (negative, -81), 99)), (greater_than, (multiplication, (index, localDEFINE5, 0), 55), -18))))}
				}
				}
				variable_statement{ blVAR0
				assign {
					case {(not_equal, envVAR2, (index, envFROZENVAR3, 1))} result { (min, 5, (max, 2, (negative, (count, (equivalent, False, (index, envVAR1, 1)), (xnor, False, False), (equal, 'no', 'yes'), (xor, (index, envVAR1, 1), (index, envVAR1, 1))))))}
					case {(or, (index, envVAR1, 0), (index, envVAR1, 1))} result { (min, 5, (max, 2, (subtraction, 4, blVAR0)))}
					result {(min, 5, (max, 2, -78))}
				}
				}
				variable_statement{ blVAR0
				assign {
					case {True} result { (min, 5, (max, 2, (abs, (max, -56, (index, localDEFINE5, 1)))))}
					result {(min, 5, (max, 2, (negative, (subtraction, (index, localDEFINE5, 0), (index, localDEFINE5, 0)))))}
				}
				}
			}
		}
	}
	action {
		a2
		arguments{}
		local_variables {localDEFINE5}
		read_variables { }
		write_variables {blVAR0, blDEFINE6}
		initial_values {

		}
		update {
			return_statement {
				case { (less_than_or_equal, (index, localDEFINE5, 0), 100)} result { success}
				result {running}
			}
		}
	}
	action {
		a3
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blDEFINE6}
		initial_values {

		}
		update {
			write_environment {
				a3_write_before_1
				variable_statement{ envVAR1
					per_index
					index_of { (min, 1, (max, 0, (count, (or, (index, envVAR1, 1), False), (not_equal, (index, envFROZENVAR4, 1), -77), (greater_than_or_equal, (index, envFROZENVAR4, 1), -26))))}
					assign {
						case {(not_equal, (count, (greater_than, blVAR0, -42), (or, False, True), (xor, (index, envVAR1, 0), True)), (min, 43, -76))} result { (less_than_or_equal, (min, 49, 73), (addition, 71, blVAR0))}
						case {(or, (xnor, False, (index, envVAR1, 0)), False)} result { (or, (index, envVAR1, 0), False)}
						result {(greater_than_or_equal, (negative, (multiplication, blVAR0, blVAR0, 23, (index, envFROZENVAR4, 0))), 16)}
					}
					index_of { (min, 1, (max, 0, (multiplication, blVAR0, (index, envFROZENVAR4, 0))))}
					assign {
						case {(less_than, -45, (max, (index, envFROZENVAR4, 0), (index, envFROZENVAR4, 0)))} result { (equivalent, (less_than, (index, envFROZENVAR4, 2), 80), (less_than, (negative, (index, envFROZENVAR4, 0)), (negative, -22)))}
						case {(less_than, blVAR0, 24)} result { (greater_than_or_equal, (addition, blVAR0, blVAR0), (count, (not_equal, True, False), (and, (index, envVAR1, 1), False), (implies, (index, envVAR1, 1), (index, envVAR1, 0))))}
						result {(index, envVAR1, 0)}
					}
				}
			}
			variable_statement{ blVAR0
			assign {
				case {(xor, (not_equal, False, False), True)} result { (min, 5, (max, 2, 76))}
				result {(min, 5, (max, 2, (multiplication, (multiplication, blVAR0, blVAR0, blVAR0), (count, (greater_than_or_equal, -44, -36), (xnor, False, True), (or, True, False), (equal, 'no', 'no')), blVAR0)))}
			}
			}
			return_statement {
				case { (xnor, (greater_than, -67, 52), False)} result { running}
				case { (or, (less_than, -51, blVAR0), (greater_than, -41, blVAR0))} result { failure}
				case { False} result { failure}
				result {failure}
			}
		}
	}
	action {
		a4
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blDEFINE6}
		initial_values {

		}
		update {
			variable_statement{ blVAR0
			assign {
				case {True} result { (min, 5, (max, 2, (count, (equal, False, False), (xnor, True, True), (and, False, True))))}
				result {(min, 5, (max, 2, (multiplication, -65, blVAR0, -91)))}
			}
			}
			return_statement {
				case { True} result { running}
				result {failure}
			}
			read_environment {
				a4_read_after_1
				condition {(implies, (index, envVAR1, 1), (less_than, (index, envFROZENVAR4, 2), (index, envFROZENVAR4, 0)))}
				variable_statement{ blVAR0
				assign {
					result {(min, 5, (max, 2, (negative, (multiplication, -42, (index, envFROZENVAR4, 2)))))}
				}
				}
				variable_statement{ blVAR0
				assign {
					result {(min, 5, (max, 2, -21))}
				}
				}
			}
			variable_statement{ blVAR0
			assign {
				result {(min, 5, (max, 2, (min, -10, (min, -2, 89))))}
			}
			}
		}
	}
}
sub_trees{}
tree {
	composite {
		p_one0
		parallel policy success_on_one
		
		children {
			composite {
				seq1
				sequence
				with_partial_memory
				children {
					c1{}
					composite {
						p_one2
						parallel policy success_on_one
						
						children {
							c2{}
							c1{}
							a1{}
						}
					}
					composite {
						p_all3
						parallel policy success_on_all
						with_partial_memory
						children {
							a1{}
							c2{}
						}
					}
				}
			}
			decorator {
				dec_fr4
				X_is_Y X failure Y running
				child {
					c2{}
				}
			}
		}
	}
}
tick_prerequisite{True}
specifications { #{ INVAR, LTL, and CTL specs go here }# } end_specifications