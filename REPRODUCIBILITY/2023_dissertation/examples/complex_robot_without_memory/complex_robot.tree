#comment#
0-9 -> home
10-20 -> maze
21-25 -> target
#end_comment#

constants {
	x_max = 18
	y_max = 2
	home_end = 3
	maze_start = 4
	maze_end = 14
	target_start = 15
} end_constants


blackboard_variables {
	#comment# Variable declarations go here #end_comment#
	blackboard_variable { zone VAR {'home', 'maze', 'target'} initial_value { result { 'home' } end_result } end_initial_value} end_blackboard_variable
	blackboard_variable { side VAR {-1, 1} initial_value { result { 1 } end_result } end_initial_value } end_blackboard_variable
	blackboard_variable { have_flag VAR BOOLEAN initial_value { result { False } end_result } end_initial_value } end_blackboard_variable
	blackboard_variable { need_side_reached VAR BOOLEAN initial_value { result { True } end_result } end_initial_value } end_blackboard_variable
	blackboard_variable { forward DEFINE INT initial_value { case { bl have_flag } end_case result { -1 } end_result result { 1 } end_result} end_initial_value} end_blackboard_variable
} end_blackboard_variables

local_variables {
	#comment# Local Variable declarations go here #end_comment#
	local_variable {tile_searched VAR BOOLEAN initial_value { result { False } end_result } end_initial_value} end_local_variable
	local_variable {will_collide VAR BOOLEAN initial_value { result { False } end_result } end_initial_value} end_local_variable
} end_local_variables


environment {
	environment_variables {
		#comment# Local Variable declarations go here #end_comment#
		environment_variable { x VAR [0, 'x_max'] initial_value { result {0} end_result} end_initial_value} end_environment_variable
		environment_variable { y VAR [0, 'y_max'] initial_value {result {0} end_result} end_initial_value} end_environment_variable
		environment_variable { hole_1 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_2 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_3 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_4 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_5 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_6 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_7 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_8 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { hole_9 FROZENVAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable {
			active_hole
			DEFINE INT
			initial_value {
				case { (equal, (addition, env x, (min, 0, bl forward)), 'maze_start') } end_case result { env hole_1 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 1)) } end_case result { env hole_2 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 2)) } end_case result { env hole_3 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 3)) } end_case result { env hole_4 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 4)) } end_case result { env hole_5 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 5)) } end_case result { env hole_6 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 6)) } end_case result { env hole_7 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 7)) } end_case result { env hole_8 } end_result
				case { (equal, (addition, env x, (min, 0, bl forward)), (addition, 'maze_start', 8)) } end_case result { env hole_9 } end_result
				result { -1 } end_result
			} end_initial_value
		} end_environment_variable
		environment_variable { flag_x VAR ['target_start', 'x_max'] initial_value { result { range, 0, 'x_max', (greater_than_or_equal, value, 'target_start') } end_result } end_initial_value } end_environment_variable
		environment_variable { flag_y VAR [0, 'y_max'] initial_value { result { range, 0, 'y_max', True } end_result } end_initial_value} end_environment_variable
		environment_variable { flag_returned DEFINE BOOLEAN initial_value { result { (and, bl have_flag, (less_than_or_equal, env x, 'home_end')) } end_result } end_initial_value } end_environment_variable
		environment_variable { tile_progress VAR [0, 2] initial_value { result { 0 } end_result } end_initial_value} end_environment_variable
		environment_variable { tile_tracker VAR [0, 2] initial_value { result { 0 } end_result } end_initial_value} end_environment_variable
	} end_environment_variables
	update_values {
		environment_statement {
			env tile_progress
			case { (equal, env tile_tracker, env tile_progress) } end_case result { 0 } end_result
			result { env tile_progress } end_result
		} end_environment_statement
		environment_statement {
			env tile_tracker
			result { env tile_progress } end_result
		} end_environment_statement
		
		#comment# update values for environment #end_comment#
	} end_update_values
} end_environment

checks {
	#comment# check nodes are defined here #end_comment#
	check {
		in_home
		read_variables { zone } end_read_variables
		condition { (equal, bl zone, 'home') } end_condition
	} end_check
	check {
		in_maze
		read_variables { zone } end_read_variables
		condition { (equal, bl zone, 'maze') } end_condition
	} end_check
	check {
		in_target
		read_variables { zone } end_read_variables
		condition { (equal, bl zone, 'target') } end_condition
	} end_check
	check {
		flag_found
		read_variables { have_flag } end_read_variables
		condition { bl have_flag } end_condition
	} end_check
	check {
		need_side
		read_variables { need_side_reached } end_read_variables
		condition { bl need_side_reached } end_condition
	} end_check
	check {
		success_node
		read_variables {} end_read_variables
		condition { True } end_condition
	} end_check
} end_checks

environment_checks {
	#comment# check environment nodes are defined here #end_comment#
	check_environment {
		flag_not_returned
		imports { 'complex_robot_environment' } end_imports
		read_variables {} end_read_variables
		python_function { from 'complex_robot_environment' 'check_flag_not_returned'  } end_python_function
		condition { (not, env flag_returned) } end_condition
	} end_check_environment
	check_environment {
		can_move_forward
		imports { 'complex_robot_environment' } end_imports
		read_variables { forward } end_read_variables
		python_function { from 'complex_robot_environment' 'can_move_forward'  } end_python_function
		condition {
			(and,
				(greater_than_or_equal, (addition, bl forward, env x), 0),
				(less_than_or_equal, (addition, bl forward, env x), 'x_max'),
				(or,
					(equal, env active_hole, -1),
					(equal, env active_hole, env y)
				)
			)
		} end_condition
	} end_check_environment
	check_environment {
		can_move_side
		imports { 'complex_robot_environment' } end_imports
		read_variables {side} end_read_variables
		python_function { from 'complex_robot_environment' 'can_move_side'  } end_python_function
		condition {
			(and,
				(greater_than_or_equal, (addition, bl side, env y), 0),
				(less_than_or_equal, (addition, bl side, env y), 'y_max')
			)
		} end_condition
	} end_check_environment
} end_environment_checks

actions {
	#comment# action nodes are defined here #end_comment#


	action {
		change_side
		imports { } end_imports
		local_variables {} end_local_variables
		read_variables {} end_read_variables
		write_variables { side } end_write_variables
		initial_values {} end_initial_values
		update {
			variable_statement {
				bl side
				case { (equal, bl side, 1) } end_case result { -1 } end_result
				result { 1 } end_result
			} end_variable_statement
			return_statement {
				result { success } end_result
			} end_return_statement
		} end_update
	} end_action
	
	action {
		go_forward
		imports { 'complex_robot_environment' } end_imports
		local_variables {} end_local_variables
		read_variables {forward} end_read_variables
		write_variables {} end_write_variables
		initial_values {} end_initial_values
		update {
			write_environment {
				python_function { from 'complex_robot_environment' 'go_forward' } end_python_function
				update_values {
					environment_statement {
						env x
						case {
							(and,
								(greater_than_or_equal, (addition, bl forward, env x), 0),
								(less_than_or_equal, (addition, bl forward, env x), 'x_max'),
								(or,
									(equal, env active_hole, -1),
									(equal, env active_hole, env y)
								)
							)
						} end_case
						result { (addition, env x, bl forward) } end_result
						result { env x } end_result
					} end_environment_statement
				} end_update_values
			} end_write_environment
			return_statement {
				result { running } end_result
			} end_return_statement
		} end_update
	} end_action


	action {
		go_side
		imports { 'complex_robot_environment' } end_imports
		local_variables {} end_local_variables
		read_variables {side} end_read_variables
		write_variables {} end_write_variables
		initial_values {
		} end_initial_values
		update {
			write_environment {
				python_function { from 'complex_robot_environment' 'go_side' } end_python_function
				update_values {
					environment_statement {
						env y
						case {
							(and,
								(greater_than_or_equal, (addition, bl side, env y), 0),
								(less_than_or_equal, (addition, bl side, env y), 'y_max')
							)
						} end_case
						result { (addition, env y, bl side) } end_result
						result { env y } end_result
					} end_environment_statement
				} end_update_values
			} end_write_environment
			return_statement {
				result { running } end_result
			} end_return_statement
		} end_update
	} end_action

	action {
		never_need_side
		imports {} end_imports
		local_variables {} end_local_variables
		read_variables {} end_read_variables
		write_variables {need_side_reached} end_write_variables
		initial_values {
		} end_initial_values
		update {
			variable_statement {
				bl need_side_reached
				result { False } end_result
			} end_variable_statement
			return_statement {
				result { success } end_result
			} end_return_statement
		} end_update
	} end_action


	
	action {
		search_tile
		imports { 'complex_robot_environment' } end_imports
		local_variables {tile_searched} end_local_variables
		read_variables {} end_read_variables
		write_variables { have_flag } end_write_variables
		initial_values {} end_initial_values
		update {
			read_environment {
				python_function { from 'complex_robot_environment' 'search_tile'} end_python_function
				condition { True } end_condition
				variable_statement_using_env {
					local tile_searched
					case { (equal, env tile_progress, 2) } end_case result { True } end_result
					result { True, False } end_result
				} end_variable_statement_using_env
				variable_statement_using_env {
					bl have_flag
					case { bl have_flag} end_case result { True } end_result
					result { (and, local tile_searched, (equal, env x, env flag_x), (equal, env y, env flag_y)) } end_result
				} end_variable_statement_using_env
			} end_read_environment
			write_environment {
				python_function { from 'complex_robot_environment' 'update_search'} end_python_function
				update_values {
					environment_statement {
						env tile_progress
						case { local tile_searched } end_case result { 2 } end_result
						result { (min, 2, (addition, 1, env tile_progress)) } end_result
					} end_environment_statement
				} end_update_values
			} end_write_environment
			return_statement {
				case {(and, local tile_searched, bl have_flag)} end_case result {success} end_result
				case {local tile_searched} end_case result {failure} end_result
				result { running } end_result
			} end_return_statement
		} end_update
	} end_action
	
	
	action {
		set_zone
		imports { 'complex_robot_environment' } end_imports
		local_variables {} end_local_variables
		read_variables {} end_read_variables
		write_variables { zone } end_write_variables
		initial_values {} end_initial_values
		update {
			read_environment {
				python_function { from 'complex_robot_environment' 'compute_zone' } end_python_function
				condition { True } end_condition
				variable_statement_using_env {
					bl zone
					case { (less_than_or_equal, env x, 'home_end') } end_case result { 'home' } end_result
					case { (greater_than_or_equal, env x, 'target_start') } end_case result { 'target' } end_result
					result { 'maze' } end_result
				} end_variable_statement_using_env
			} end_read_environment
			return_statement {
				result { success } end_result
			} end_return_statement
		} end_update
	} end_action

} end_actions

sub_trees {
	sub_tree {
		sub_forward
		composite {
			try_forward
			sequence
			children {
				can_move_forward
				go_forward
			} end_children
		} end_composite
	} end_sub_tree

	sub_tree {
		sub_side
		composite {
			try_side_or_change
			selector
			children {
				composite {
					try_side
					sequence
					children {
						can_move_side
						go_side
					} end_children
				} end_composite
				decorator {
					return_failure
					X_is_Y X success Y failure
					child change_side
				} end_decorator
			} end_children
		} end_composite
	} end_sub_tree
	
	sub_tree {
		sub_flag
		decorator {
			flag_inverter
			inverter
			child flag_found
		} end_decorator
	} end_sub_tree
} end_sub_trees


#comment# the tree is defined here. replace REPLACE_ME with the root node #end_comment#
tree {
composite {
	control
	parallel policy success_on_all
	children {
		set_zone
		composite {
			control_sequence
			sequence
			children {
				flag_not_returned
				composite {
					control_selector
					selector
					children {
						composite {
							navigate_maze
							sequence
							children {
								in_maze
								decorator {
									move_through_maze_decorator
									X_is_Y X success Y running
									child
									composite {
										move_through_maze
										selector
										children {
											insert { sub_forward } end_insert
											insert { sub_side } end_insert
											success_node
										} end_children
									} end_composite
								} end_decorator
							} end_children
						} end_composite
						composite {
							enter_maze
							sequence
							children {
								decorator {
									maze_inverter
									inverter
									child in_maze
								} end_decorator
								composite {
									traversal_needed
									selector
									children {
										composite {
											go_home
											sequence
											children {
												in_target
												flag_found
											} end_children
										} end_composite
										composite {
											go_target
											sequence
											children {
												in_home
												insert { sub_flag } end_insert
											} end_children
										} end_composite
									} end_children
								} end_composite
								go_forward
							} end_children
						} end_composite
						composite {
							to_side
							sequence
							children {
								in_target
								need_side
								decorator {
									side_reached
									X_is_Y X failure Y success
									child insert {sub_side} end_insert
								} end_decorator
								never_need_side
							} end_children
						} end_composite
						composite {
							search_target
							sequence
							children {
								in_target
								insert { sub_flag } end_insert
								composite {
									search_for_flag
									selector
									children {
										search_tile
										composite {
											move_for_flag
											selector
											children {
												insert { sub_side } end_insert
												go_forward
											} end_children
										} end_composite
									} end_children
								} end_composite
							} end_children
						} end_composite
					} end_children
				} end_composite
			} end_children
		} end_composite
	} end_children
} end_composite
} end_tree

#comment# this section is optional. you may remove it #end_comment#
tick_prerequisite {
#comment# if the condition is True, the tree ticks.
If it is false, everything is done #end_comment#
	True
} end_tick_prerequisite


specifications {
	#comment# INVAR, LTL, and CTL specs go here #end_comment#
	CTLSPEC { (always_globally, (always_finally, env flag_returned 0)) } end_CTLSPEC
} end_specifications