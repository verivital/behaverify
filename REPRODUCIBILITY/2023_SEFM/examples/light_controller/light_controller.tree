constants {
	#comment# constants are used to synchronize values in a .tree file. #end_comment#
	max_counter = 4
} end_constants

variables {
	variable {
		bl fairness_counter VAR [0, 'max_counter']
		assign {
			result {0}
		}
	}
	variable {
		bl direction VAR {'east_to_west', 'west_to_east'}
		assign {
			result {'east_to_west'}
		}
	}
	variable {
		env tunnel_state VAR {'empty', 'east_to_west', 'west_to_east'}
		assign {
			result {'empty'}
		}
	}
	variable {
		env east_cars VAR BOOLEAN
		assign {
			result {True, False}
		}
	}
	variable {
		env west_cars VAR BOOLEAN
		assign {
			result {True, False}
		}
	}
	variable {
		env west_light VAR BOOLEAN
		assign {
			result {False}
		}
	}
	variable {
		env east_light VAR BOOLEAN
		assign {
			result {False}
		}
	}
} end_variables

environment_update {
	variable_statement {
		tunnel_state
		assign {
			case {west_light}
			result {'empty', 'west_to_east'}
			case {east_light}
			result {'empty', 'east_to_west'}
			result {'empty', tunnel_state}
		}
	}
	variable_statement {
		west_cars
		assign {
			case {west_light}
			result {True, False}
			result {True, west_cars}
		}
	}
	variable_statement {
		east_cars
		assign {
			case {east_light}
			result {True, False}
			result {True, east_cars}
		}
	}
} end_environment_update

checks {
	check {
		check_fairness
		read_variables {fairness_counter}
		condition { (less_than, fairness_counter, 'max_counter')}
	}
} end_checks

environment_checks {
	check_environment {
		check_west_and_east_cars
		read_variables {}
		condition {(and, west_cars, east_cars)}
	}
	check_environment {
		check_west_cars
		read_variables {}
		condition {west_cars}
	}
	check_environment {
		check_east_cars
		read_variables {}
		condition {east_cars}
	}
	check_environment {
		check_safety
		read_variables {direction}
		condition {(or, (equal, tunnel_state, 'empty'), (equal, direction, tunnel_state))}
	}
} end_environment_checks

actions {
	action {
		swap_direction
		local_variables {}
		read_variables {}
		write_variables {direction fairness_counter}
		initial_values {}
		update {
			variable_statement {
				direction
				assign {
					case {(equal, direction, 'west_to_east')}
					result {'east_to_west'}
					result {'west_to_east'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
	action {
		set_west
		local_variables {}
		read_variables {}
		write_variables {direction fairness_counter}
		initial_values {}
		update {
			variable_statement {
				direction
				assign {
					result {'west_to_east'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
	action {
		set_east
		local_variables {}
		read_variables {}
		write_variables {direction fairness_counter}
		initial_values {}
		update {
			variable_statement {
				direction
				assign {
					result {'east_to_west'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
	action {
		send_light_signal
		local_variables {}
		read_variables {direction}
		write_variables {fairness_counter}
		initial_values {}
		update {
			write_environment {
				light_signal_func
				variable_statement {
					west_light
					assign {
						case {(equal, direction, 'west_to_east')}
						result {True}
						result {False}
					}
				}
				variable_statement {
					east_light
					assign {
						case {(equal, direction, 'east_to_west')}
						result {True}
						result {False}
					}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {(min, 'max_counter', (addition, fairness_counter, 1))}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
} end_actions

sub_trees {
	sub_tree {
		WEST_AND_EAST
		composite {
			idk
			sequence
			children {
				check_west_and_east_cars
				composite {
					choose_fairly
					selector
					children {
						check_fairness
						swap_direction
					}
				}
			}
		}
	}
	sub_tree {
		WEST_ONLY
		composite {
			idk
			sequence
			children {
				check_west_cars
				set_west
			}
		}
	}
	sub_tree {
		EAST_ONLY
		composite {
			idk
			sequence
			children {
				check_east_cars
				set_east
			}
		}
	}
	sub_tree {
		DIRECTION_SUBTREE
		composite {
			select_direction
			selector
			children {
				insert {WEST_AND_EAST}
				insert {WEST_ONLY}
				insert {EAST_ONLY}
			}
		}
	}
	sub_tree {
		LIGHT_SUBTREE
		composite {
			activate_light
			sequence
			children {
				check_safety
				#comment#
				composite {
					safety_check
					selector
					children {
						check_tunnel_empty
						check_west_east_safe
						check_east_west_safe
					}
				}
				#end_comment#
				send_light_signal
			}
		}
	}
} end_sub_trees

tree {
	composite {
		light_controller
		sequence
		children {
			insert {DIRECTION_SUBTREE}
			insert {LIGHT_SUBTREE}
		}
	}
} end_tree


#comment#
tick_prerequisite {} end_tick_prerequisite
#end_comment#

specifications {
	INVARSPEC {(not, (and, west_light -1, east_light -1))}
	INVARSPEC {(not, (and, west_light -1, (equal, tunnel_state -1, 'east_to_west')))}
	INVARSPEC {(not, (and, east_light -1, (equal, tunnel_state -1, 'west_to_east')))}
	#comment#
	INVARSPEC {(implies, (equal, tunnel_state -1, 'empty'), (or, west_light -1, east_light -1))}
	#end_comment#
	#comment# these will fail, because cars -1 are not guaranteed to ever leave the tunnel #end_comment#
	CTLSPEC {(always_globally, (implies, west_cars -1, (always_finally, west_light -1)))}
	CTLSPEC {(always_globally, (implies, east_cars -1, (always_finally, east_light -1)))}
	LTLSPEC {(globally, (implies, west_cars -1, (finally, west_light -1)))}
	LTLSPEC {(globally, (implies, east_cars -1, (finally, east_light -1)))}
	#comment# so we add a condition to force cars -1 to leave #end_comment#
	CTLSPEC {(implies, (always_globally, (always_finally, (equal, tunnel_state -1, 'empty'))), (always_globally, (implies, west_cars -1, (always_finally, west_light -1))))}
	CTLSPEC {(implies, (always_globally, (always_finally, (equal, tunnel_state -1, 'empty'))), (always_globally, (implies, east_cars -1, (always_finally, east_light -1))))}
	LTLSPEC {(implies, (globally, (finally, (equal, tunnel_state -1, 'empty'))), (globally, (implies, west_cars -1, (finally, west_light -1))))}
	LTLSPEC {(implies, (globally, (finally, (equal, tunnel_state -1, 'empty'))), (globally, (implies, east_cars -1, (finally, east_light -1))))}
} end_specifications