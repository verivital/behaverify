constants {
	MIN_VAL = 2
	MAX_VAL = 5
}
variables { 
	variable { bl blVAR0 VAR [-5, -2]
		assign {
			case {(xnor, True, True)} result { (min, -2, (max, -5, 3))}
			case {(and, True, False)} result { (min, -2, (max, -5, (min, -5, 2)))}
			result {(min, -2, (max, -5, (multiplication, (max, 2, -5), 4)))}
		}
	}
	variable { env envVAR1 VAR {'yes', 'no', 'both'}
		assign {
			result {'both'}
		}
	}
	variable { env envVAR2 array 2 VAR [2, 5]
		range
		assign {
			case {(greater_than_or_equal, blVAR0, blVAR0)} result { (min, 5, (max, 2, (abs, 5)))}
			case {(less_than, (addition, (multiplication, 2, blVAR0), (addition, 5, -5, blVAR0, blVAR0), -4, blVAR0), 4)} result { (min, 5, (max, 2, (max, blVAR0, -5)))}
			result {(min, 5, (max, 2, (count, (xor, (and, True, True), True), (greater_than_or_equal, (subtraction, blVAR0, -2), 4), (less_than, blVAR0, -2), (not_equal, (abs, blVAR0), (subtraction, 5, blVAR0)))))}
		}
	}
	variable { bl blVAR3 VAR {'yes', 'no', 'both'}
		assign {
			result {'both'}
		}
	}
	variable { env envFROZENVAR4 FROZENVAR [2, 5]
		assign {
			case {(greater_than, blVAR0, (index, envVAR2, (max, 0, (min, 1, -3))))} result { (min, 5, (max, 2, (addition, blVAR0, blVAR0)))}
			case {(xor, True, False)} result { (min, 5, (max, 2, (negative, -2)))}
			result {(min, 5, (max, 2, (multiplication, 4, -5, blVAR0)))}
		}
	}
	variable { env envDEFINE5 array 2 DEFINE BOOLEAN
		assign {
			case {(implies, True, False)} result { False}
			result {(less_than_or_equal, 4, (index, envVAR2, (max, 0, (min, 1, envFROZENVAR4))))}
		}
		assign {
			case {True} result { False}
			case {(and, True, True)} result { (xnor, (not_equal, True, False), (xor, (implies, True, True), (not_equal, False, False)))}
			result {(implies, False, False)}
		}
	}
	variable { env envDEFINE6 DEFINE BOOLEAN
		assign {
			case {(not_equal, blVAR3, 'both')} result { (index, envDEFINE5, (max, 0, (min, 1, envFROZENVAR4)))}
			result {(not_equal, (and, False, (greater_than_or_equal, blVAR0, envFROZENVAR4)), (xor, True, False))}
		}
	}
	variable { local localDEFINE7 DEFINE INT
		assign {
			result {(min, 5, (max, 2, (count, (xnor, True, True), (or, False, False))))}
		}
	}
}
environment_update {
	variable_statement{ envVAR2
		index_of { (min, 1, (max, 0, (subtraction, (negative, (index, envVAR2, (max, 0, (min, 1, 2)))), -2)))}
		assign {
			result {(min, 5, (max, 2, (abs, (subtraction, 2, -5))))}
		}
	}
	variable_statement{ envVAR2
		index_of { (min, 1, (max, 0, (addition, (index, envVAR2, (max, 0, (min, 1, blVAR0))), (count, (or, envDEFINE6, True), (less_than_or_equal, -4, -2), (or, True, False), (less_than_or_equal, 2, -5)), -3, (max, 5, -2))))}
		assign {
			case {(greater_than, 3, 5)} result { (min, 5, (max, 2, (max, (addition, blVAR0, (index, envVAR2, (max, 0, (min, 1, 5)))), (max, envFROZENVAR4, -4))))}
			case {(or, (less_than, -2, 4), (xnor, envDEFINE6, False))} result { (min, 5, (max, 2, (negative, (subtraction, (max, -5, 2), 4))))}
			result {(min, 5, (max, 2, (count, (less_than_or_equal, (division, -3, (max, 1, blVAR0)), (min, (division, envFROZENVAR4, (max, 1, -2)), 4)), (not_equal, 'both', 'both'), (equivalent, (and, True, envDEFINE6), (or, False, True)), (greater_than_or_equal, -4, -2))))}
		}
		index_of { (min, 1, (max, 0, (abs, 4)))}
		assign {
			case {False} result { (min, 5, (max, 2, (multiplication, 3, (abs, envFROZENVAR4), (max, -4, -4), (index, envVAR2, (max, 0, (min, 1, 4))))))}
			case {(greater_than, (count, (xnor, False, False), (equivalent, True, envDEFINE6), (xor, False, envDEFINE6)), (negative, envFROZENVAR4))} result { (min, 5, (max, 2, (count, (or, False, envDEFINE6), (equivalent, False, True), (less_than, 4, 4), (less_than_or_equal, 2, -3))))}
			result {(min, 5, (max, 2, (min, (min, 4, -2), (addition, 2, 2, 4))))}
		}
	}
	variable_statement{ envVAR2
		index_of { (min, 1, (max, 0, (min, (max, envFROZENVAR4, envFROZENVAR4), blVAR0)))}
		assign {
			case {True} result { (min, 5, (max, 2, (index, envVAR2, (max, 0, (min, 1, blVAR0)))))}
			result {(min, 5, (max, 2, envFROZENVAR4))}
		}
		index_of { (min, 1, (max, 0, blVAR0))}
		assign {
			case {(not_equal, (min, blVAR0, envFROZENVAR4), (addition, (index, envVAR2, (max, 0, (min, 1, envFROZENVAR4))), -4, -4))} result { (min, 5, (max, 2, (abs, -4)))}
			result {(min, 5, (max, 2, (multiplication, -2, envFROZENVAR4, 5)))}
		}
	}
	variable_statement{ envVAR1
	assign {
		case {(greater_than_or_equal, 4, (addition, 5, (index, envVAR2, (max, 0, (min, 1, blVAR0)))))} result { 'both'}
		result {blVAR3}
	}
	}
	variable_statement{ envVAR1
	assign {
		case {(equal, envDEFINE6, (or, True, (index, envDEFINE5, (max, 0, (min, 1, blVAR0)))))} result { 'both'}
		result {envVAR1}
	}
	}
}
checks{
	check {
		c1
		read_variables {blVAR0 blVAR3}
		condition{(greater_than_or_equal, (subtraction, (division, blVAR0, (max, 1, 4)), (division, -3, (max, 1, -2))), -2)}
	}
	check {
		c2
		read_variables {blVAR0 blVAR3}
		condition{(implies, True, False)}
	}
}
environment_checks {}
actions{
	action {
		a1
		local_variables {localDEFINE7}
		read_variables { }
		write_variables {blVAR0 blVAR3}
		initial_values {

		}
		update {
			read_environment {
				a1_read_before_0
				condition {(index, envDEFINE5, (max, 0, (min, 1, blVAR0)))}
				variable_statement{ blVAR0
				assign {
					result {(min, -2, (max, -5, (division, (subtraction, (abs, -3), (subtraction, blVAR0, envFROZENVAR4)), (min, -1, localDEFINE7))))}
				}
				}
				variable_statement{ blVAR3
				assign {
					result {envVAR1}
				}
				}
				variable_statement{ blVAR0
				assign {
					case {(and, False, True)} result { (min, -2, (max, -5, (min, (count, (or, (equal, (index, envDEFINE5, (max, 0, (min, 1, localDEFINE7))), True), envDEFINE6), (less_than_or_equal, (min, -5, 4), (multiplication, 5, localDEFINE7)), (implies, False, False), (equal, envDEFINE6, (xnor, False, envDEFINE6))), (count, (and, (implies, envDEFINE6, False), True), (greater_than_or_equal, (max, -3, -3), (negative, -4))))))}
					case {(not_equal, envDEFINE6, (xnor, True, False))} result { (min, -2, (max, -5, (abs, envFROZENVAR4)))}
					result {(min, -2, (max, -5, 4))}
				}
				}
			}
			return_statement {
				result {running}
			}
			read_environment {
				a1_read_after_0
				condition {(less_than_or_equal, -2, 2)}
				variable_statement{ blVAR3
				assign {
					result {envVAR1}
				}
				}
			}
		}
	}
	action {
		a2
		local_variables {}
		read_variables { }
		write_variables {blVAR0 blVAR3}
		initial_values {

		}
		update {
			write_environment {
				a2_write_before_1
				variable_statement{ instant envVAR1
				assign {
					case {(xnor, (less_than_or_equal, -4, 4), True)} result { 'both'}
					result {envVAR1}
				}
				}
			}
			read_environment {
				a2_read_before_0
				condition {(greater_than, 5, (index, envVAR2, (max, 0, (min, 1, 3))))}
				variable_statement{ blVAR0
				assign {
					result {(min, -2, (max, -5, (subtraction, (max, 5, -4), (addition, (index, envVAR2, (max, 0, (min, 1, 2))), envFROZENVAR4, 5))))}
				}
				}
			}
			return_statement {
				result {failure}
			}
			variable_statement{ blVAR3
			assign {
				case {True} result { 'no'}
				result {'both'}
			}
			}
		}
	}
	action {
		a3
		local_variables {}
		read_variables { }
		write_variables {blVAR0 blVAR3}
		initial_values {

		}
		update {
			read_environment {
				a3_read_before_1
				condition {(equivalent, (xor, envDEFINE6, True), (xnor, envDEFINE6, False))}
				variable_statement{ blVAR3
				assign {
					case {(index, envDEFINE5, (max, 0, (min, 1, -2)))} result { 'yes'}
					result {blVAR3}
				}
				}
			}
			write_environment {
				a3_write_before_0
				variable_statement{ envVAR2
					index_of { (min, 1, (max, 0, (abs, (multiplication, 2, 4))))}
					assign {
						case {(xnor, True, (index, envDEFINE5, (max, 0, (min, 1, 3))))} result { (min, 5, (max, 2, (division, 3, (min, -1, -4))))}
						case {(not_equal, blVAR0, 3)} result { (min, 5, (max, 2, (min, (count, (less_than, blVAR0, 3), (equivalent, True, False)), envFROZENVAR4)))}
						result {(min, 5, (max, 2, (multiplication, (count, (greater_than_or_equal, blVAR0, -4), (less_than_or_equal, -3, 5), (or, envDEFINE6, False)), (count, (xnor, False, (equivalent, True, envDEFINE6)), (equal, -3, envFROZENVAR4)), (negative, -3), (max, envFROZENVAR4, blVAR0))))}
					}
				}
			}
			return_statement {
				case { False} result { failure}
				case { (not_equal, 'no', 'no')} result { running}
				case { False} result { failure}
				result {failure}
			}
			variable_statement{ blVAR0
			assign {
				case {False} result { (min, -2, (max, -5, (addition, -2, -5, blVAR0, 3)))}
				result {(min, -2, (max, -5, (division, (min, blVAR0, blVAR0), (min, -1, blVAR0))))}
			}
			}
		}
	}
	action {
		a4
		local_variables {localDEFINE7}
		read_variables { }
		write_variables {blVAR0 blVAR3}
		initial_values {
			variable_statement{ localDEFINE7
			assign {
				case {True} result { (min, 5, (max, 2, (max, (negative, blVAR0), 4)))}
				case {(xnor, True, True)} result { (min, 5, (max, 2, (addition, (max, -3, blVAR0), blVAR0, blVAR0)))}
				result {(min, 5, (max, 2, (negative, blVAR0)))}
			}
			}

		}
		update {
			write_environment {
				a4_write_before_0
				variable_statement{ envVAR2
					index_of { (min, 1, (max, 0, (multiplication, blVAR0, blVAR0)))}
					assign {
						case {(and, (less_than_or_equal, -2, (addition, 4, blVAR0)), (index, envDEFINE5, (max, 0, (min, 1, -3))))} result { (min, 5, (max, 2, (division, -3, (min, -1, (multiplication, 5, -3, localDEFINE7)))))}
						case {envDEFINE6} result { (min, 5, (max, 2, 4))}
						result {(min, 5, (max, 2, 2))}
					}
				}
			}
			return_statement {
				case { (greater_than_or_equal, (multiplication, blVAR0, blVAR0, 5, 5), (division, blVAR0, (min, -1, -2)))} result { running}
				case { (equal, blVAR3, 'yes')} result { failure}
				result {failure}
			}
		}
	}
}
sub_trees{}
tree {
	composite {
		seq0
		sequence
		with_partial_memory
		children {
			a4
			c2
			a4
			a1
		}
	}
}
specifications { #comment# INVAR, LTL, and CTL specs go here #end_comment# } end_specifications