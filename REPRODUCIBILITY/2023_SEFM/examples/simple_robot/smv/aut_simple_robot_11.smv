MODULE main
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		resume_from_here_in_subtree__robot_control := -3;
		status__clear_mission := clear_mission.status;
		status__confirm_mission := 
			case
				status__have_mission != failure : status__have_mission;
				status__get_mission != failure : status__get_mission;
				TRUE : failure;
			esac;
		status__get_mission := get_mission.status;
		status__get_position := get_position.status;
		status__go_down := go_down.status;
		status__go_left := go_left.status;
		status__go_right := go_right.status;
		status__go_up := go_up.status;
		status__have_mission := have_mission.status;
		status__move_robot := 
			case
				status__try_right != failure : status__try_right;
				status__try_left != failure : status__try_left;
				status__try_up != failure : status__try_up;
				status__try_down != failure : status__try_down;
				TRUE : failure;
			esac;
		status__reset_completed_mission := 
			case
				status__target_reached != success : status__target_reached;
				status__clear_mission != success : status__clear_mission;
				TRUE : success;
			esac;
		status__reset_completed_mission_FiS := status__reset_completed_mission = failure ? success : status__reset_completed_mission;
		status__robot_control := 
			case
				status__get_position != success : status__get_position;
				status__reset_completed_mission_FiS != success : status__reset_completed_mission_FiS;
				status__confirm_mission != success : status__confirm_mission;
				status__move_robot != success : status__move_robot;
				TRUE : success;
			esac;
		status__target_reached := target_reached.status;
		status__try_down := 
			case
				status__y_too_big != success : status__y_too_big;
				status__go_down != success : status__go_down;
				TRUE : success;
			esac;
		status__try_left := 
			case
				status__x_too_big != success : status__x_too_big;
				status__go_left != success : status__go_left;
				TRUE : success;
			esac;
		status__try_right := 
			case
				status__x_too_small != success : status__x_too_small;
				status__go_right != success : status__go_right;
				TRUE : success;
			esac;
		status__try_up := 
			case
				status__y_too_small != success : status__y_too_small;
				status__go_up != success : status__go_up;
				TRUE : success;
			esac;
		status__x_too_big := x_too_big.status;
		status__x_too_small := x_too_small.status;
		status__y_too_big := y_too_big.status;
		status__y_too_small := y_too_small.status;
		next_child__confirm_mission := 
			case
				(status__have_mission = invalid) : node_names.have_mission;
				(status__get_mission = invalid) : node_names.get_mission;
			esac;
		next_child__move_robot := 
			case
				(status__try_right = invalid) : node_names.try_right;
				(status__try_left = invalid) : node_names.try_left;
				(status__try_up = invalid) : node_names.try_up;
				(status__try_down = invalid) : node_names.try_down;
			esac;
		next_child__reset_completed_mission := 
			case
				(status__target_reached = invalid) : node_names.target_reached;
				(status__clear_mission = invalid) : node_names.clear_mission;
			esac;
		next_child__reset_completed_mission_FiS := node_names.reset_completed_mission;
		next_child__robot_control := 
			case
				(status__get_position = invalid) : node_names.get_position;
				(status__reset_completed_mission_FiS = invalid) : node_names.reset_completed_mission_FiS;
				(status__confirm_mission = invalid) : node_names.confirm_mission;
				(status__move_robot = invalid) : node_names.move_robot;
			esac;
		next_child__try_down := 
			case
				(status__y_too_big = invalid) : node_names.y_too_big;
				(status__go_down = invalid) : node_names.go_down;
			esac;
		next_child__try_left := 
			case
				(status__x_too_big = invalid) : node_names.x_too_big;
				(status__go_left = invalid) : node_names.go_left;
			esac;
		next_child__try_right := 
			case
				(status__x_too_small = invalid) : node_names.x_too_small;
				(status__go_right = invalid) : node_names.go_right;
			esac;
		next_child__try_up := 
			case
				(status__y_too_small = invalid) : node_names.y_too_small;
				(status__go_up = invalid) : node_names.go_up;
			esac;
		clear_mission.active := active_node = node_names.clear_mission;
		clear_mission.reset := active_node = -1;
		get_mission.active := active_node = node_names.get_mission;
		get_mission.reset := active_node = -1;
		get_position.active := active_node = node_names.get_position;
		get_position.reset := active_node = -1;
		go_down.active := active_node = node_names.go_down;
		go_down.reset := active_node = -1;
		go_left.active := active_node = node_names.go_left;
		go_left.reset := active_node = -1;
		go_right.active := active_node = node_names.go_right;
		go_right.reset := active_node = -1;
		go_up.active := active_node = node_names.go_up;
		go_up.reset := active_node = -1;
		have_mission.active := active_node = node_names.have_mission;
		have_mission.reset := active_node = -1;
		target_reached.active := active_node = node_names.target_reached;
		target_reached.reset := active_node = -1;
		x_too_big.active := active_node = node_names.x_too_big;
		x_too_big.reset := active_node = -1;
		x_too_small.active := active_node = node_names.x_too_small;
		x_too_small.reset := active_node = -1;
		y_too_big.active := active_node = node_names.y_too_big;
		y_too_big.reset := active_node = -1;
		y_too_small.active := active_node = node_names.y_too_small;
		y_too_small.reset := active_node = -1;
		--START OF BLACKBOARD DEFINITIONS
		--END OF BLACKBOARD DEFINITIONS
	VAR
		node_names : define_nodes;
		active_node : -1..22;
		clear_mission : success_DEFAULT_module;
		get_mission : success_DEFAULT_module;
		get_position : success_DEFAULT_module;
		go_down : success_DEFAULT_module;
		go_left : success_DEFAULT_module;
		go_right : success_DEFAULT_module;
		go_up : success_DEFAULT_module;
		have_mission : have_mission_module(var_mission);
		target_reached : target_reached_module(var_x, var_target_x, var_y, var_target_y);
		x_too_big : x_too_big_module(var_x, var_target_x);
		x_too_small : x_too_small_module(var_x, var_target_x);
		y_too_big : y_too_big_module(var_target_y, var_y);
		y_too_small : y_too_small_module(var_target_y, var_y);
		--START OF BLACKBOARD VARIABLES DECLARATION
		env_remaining_goals : 0..3;
		env_x_goal : 0..10;
		env_x_true : 0..10;
		env_y_goal : 0..10;
		env_y_true : 0..10;
		var_mission : boolean;
		var_target_x : 0..10;
		var_target_y : 0..10;
		var_x : 0..10;
		var_y : 0..10;
		--END OF BLACKBOARD VARIABLES DECLARATION
	ASSIGN
		init(active_node) := -1;
		--START OF BLACKBOARD VARIABLES INITIALIZATION
		init(env_remaining_goals) := 
			case
				TRUE : {0, 1, 2, 3};
			esac;
		init(env_x_goal) := 
			case
				TRUE : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
			esac;
		init(env_x_true) := 
			case
				TRUE : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
			esac;
		init(env_y_goal) := 
			case
				TRUE : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
			esac;
		init(env_y_true) := 
			case
				TRUE : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
			esac;
		init(var_mission) := 
			case
				TRUE : FALSE;
			esac;
		init(var_target_x) := 
			case
				TRUE : 0;
			esac;
		init(var_target_y) := 
			case
				TRUE : 0;
			esac;
		init(var_x) := 
			case
				TRUE : 0;
			esac;
		init(var_y) := 
			case
				TRUE : 0;
			esac;
		--END OF BLACKBOARD VARIABLES INITIALIZATION
		next(active_node) :=
			case
				active_node = -1 & (env_remaining_goals > 0) : node_names.robot_control;
				active_node = -1 & !((env_remaining_goals > 0)) : -1;
				(active_node = node_names.clear_mission) & (status__clear_mission != invalid) : node_names.reset_completed_mission;
				(active_node = node_names.confirm_mission) & (status__confirm_mission != invalid) : node_names.robot_control;
				(active_node = node_names.confirm_mission) & (status__confirm_mission = invalid) : next_child__confirm_mission;
				(active_node = node_names.get_mission) & (status__get_mission != invalid) : node_names.confirm_mission;
				(active_node = node_names.get_position) & (status__get_position != invalid) : node_names.robot_control;
				(active_node = node_names.go_down) & (status__go_down != invalid) : node_names.try_down;
				(active_node = node_names.go_left) & (status__go_left != invalid) : node_names.try_left;
				(active_node = node_names.go_right) & (status__go_right != invalid) : node_names.try_right;
				(active_node = node_names.go_up) & (status__go_up != invalid) : node_names.try_up;
				(active_node = node_names.have_mission) & (status__have_mission != invalid) : node_names.confirm_mission;
				(active_node = node_names.move_robot) & (status__move_robot != invalid) : node_names.robot_control;
				(active_node = node_names.move_robot) & (status__move_robot = invalid) : next_child__move_robot;
				(active_node = node_names.reset_completed_mission) & (status__reset_completed_mission != invalid) : node_names.reset_completed_mission_FiS;
				(active_node = node_names.reset_completed_mission) & (status__reset_completed_mission = invalid) : next_child__reset_completed_mission;
				(active_node = node_names.reset_completed_mission_FiS) & (status__reset_completed_mission_FiS != invalid) : node_names.robot_control;
				(active_node = node_names.reset_completed_mission_FiS) & (status__reset_completed_mission_FiS = invalid) : next_child__reset_completed_mission_FiS;
				(active_node = node_names.robot_control) & (status__robot_control != invalid) : -1;
				(active_node = node_names.robot_control) & (status__robot_control = invalid) : next_child__robot_control;
				(active_node = node_names.target_reached) & (status__target_reached != invalid) : node_names.reset_completed_mission;
				(active_node = node_names.try_down) & (status__try_down != invalid) : node_names.move_robot;
				(active_node = node_names.try_down) & (status__try_down = invalid) : next_child__try_down;
				(active_node = node_names.try_left) & (status__try_left != invalid) : node_names.move_robot;
				(active_node = node_names.try_left) & (status__try_left = invalid) : next_child__try_left;
				(active_node = node_names.try_right) & (status__try_right != invalid) : node_names.move_robot;
				(active_node = node_names.try_right) & (status__try_right = invalid) : next_child__try_right;
				(active_node = node_names.try_up) & (status__try_up != invalid) : node_names.move_robot;
				(active_node = node_names.try_up) & (status__try_up = invalid) : next_child__try_up;
				(active_node = node_names.x_too_big) & (status__x_too_big != invalid) : node_names.try_left;
				(active_node = node_names.x_too_small) & (status__x_too_small != invalid) : node_names.try_right;
				(active_node = node_names.y_too_big) & (status__y_too_big != invalid) : node_names.try_down;
				(active_node = node_names.y_too_small) & (status__y_too_small != invalid) : node_names.try_up;
				TRUE : active_node;
			esac;
		--START OF BLACKBOARD VARIABLES TRANSITION
		next(env_remaining_goals) :=
			case
				(active_node = -1) & (env_remaining_goals > 0) & (((env_x_goal = env_x_true) & (env_y_goal = env_y_true))) : max(0, (env_remaining_goals - 1));
				(active_node = -1) & (env_remaining_goals > 0) & (TRUE) : env_remaining_goals;
				TRUE : env_remaining_goals;
			esac;
		next(env_x_goal) :=
			case
				(active_node = -1) & (env_remaining_goals > 0) & ((0 = env_remaining_goals)) : env_x_goal;
				(active_node = -1) & (env_remaining_goals > 0) & (((env_x_goal = env_x_true) & (env_y_goal = env_y_true))) : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				(active_node = -1) & (env_remaining_goals > 0) & (TRUE) : env_x_goal;
				TRUE : env_x_goal;
			esac;
		next(env_x_true) :=
			case
				(active_node = -1) & !(status__go_right = invalid) & (TRUE) : min(10, (env_x_true + 1));
				(active_node = -1) & !(status__go_left = invalid) & (TRUE) : max(0, (env_x_true - 1));
				TRUE : env_x_true;
			esac;
		next(env_y_goal) :=
			case
				(active_node = -1) & (env_remaining_goals > 0) & ((0 = env_remaining_goals)) : env_y_goal;
				(active_node = -1) & (env_remaining_goals > 0) & (((env_x_goal = env_x_true) & (env_y_goal = env_y_true))) : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				(active_node = -1) & (env_remaining_goals > 0) & (TRUE) : env_y_goal;
				TRUE : env_y_goal;
			esac;
		next(env_y_true) :=
			case
				(active_node = -1) & !(status__go_up = invalid) & (TRUE) : min(10, (env_y_true + 1));
				(active_node = -1) & !(status__go_down = invalid) & (TRUE) : max(0, (env_y_true - 1));
				TRUE : env_y_true;
			esac;
		next(var_mission) :=
			case
				(active_node = -1) & !(status__clear_mission = invalid) & (TRUE) : FALSE;
				(active_node = -1) & !(status__get_mission = invalid) & (TRUE) : TRUE;
				TRUE : var_mission;
			esac;
		next(var_target_x) :=
			case
				(active_node = -1) & !(status__get_mission = invalid) & (!(TRUE)) : var_target_x;
				(active_node = -1) & !(status__get_mission = invalid) & (TRUE) : env_x_goal;
				TRUE : var_target_x;
			esac;
		next(var_target_y) :=
			case
				(active_node = -1) & !(status__get_mission = invalid) & (!(TRUE)) : var_target_y;
				(active_node = -1) & !(status__get_mission = invalid) & (TRUE) : env_y_goal;
				TRUE : var_target_y;
			esac;
		next(var_x) :=
			case
				(active_node = -1) & !(status__get_position = invalid) & (!(TRUE)) : var_x;
				(active_node = -1) & !(status__get_position = invalid) & (TRUE) : env_x_true;
				TRUE : var_x;
			esac;
		next(var_y) :=
			case
				(active_node = -1) & !(status__get_position = invalid) & (!(TRUE)) : var_y;
				(active_node = -1) & !(status__get_position = invalid) & (TRUE) : env_y_true;
				TRUE : var_y;
			esac;
		--END OF BLACKBOARD VARIABLES TRANSITION

INVARSPEC (count((go_down.active), (go_left.active), (go_right.active), (go_up.active)) <= 1);
LTLSPEC F((env_remaining_goals = 0));
CTLSPEC AF((env_remaining_goals = 0));
MODULE define_nodes
	DEFINE
		robot_control := 0;
		get_position := 1;
		reset_completed_mission_FiS := 2;
		reset_completed_mission := 3;
		target_reached := 4;
		clear_mission := 5;
		confirm_mission := 6;
		have_mission := 7;
		get_mission := 8;
		move_robot := 9;
		try_right := 10;
		x_too_small := 11;
		go_right := 12;
		try_left := 13;
		x_too_big := 14;
		go_left := 15;
		try_up := 16;
		y_too_small := 17;
		go_up := 18;
		try_down := 19;
		y_too_big := 20;
		go_down := 21;
MODULE have_mission_module(var_mission)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				var_mission : success;
				TRUE : failure;
			esac;
MODULE target_reached_module(var_x, var_target_x, var_y, var_target_y)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				((var_x = var_target_x) & (var_y = var_target_y)) : success;
				TRUE : failure;
			esac;
MODULE x_too_big_module(var_x, var_target_x)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				(var_x > var_target_x) : success;
				TRUE : failure;
			esac;
MODULE x_too_small_module(var_x, var_target_x)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				(var_x < var_target_x) : success;
				TRUE : failure;
			esac;
MODULE y_too_big_module(var_target_y, var_y)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				(var_y > var_target_y) : success;
				TRUE : failure;
			esac;
MODULE y_too_small_module(var_target_y, var_y)
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, failure, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				reset : invalid;
				!(active) : status;
				(var_y < var_target_y) : success;
				TRUE : failure;
			esac;
MODULE success_DEFAULT_module
	CONSTANTS
		success, failure, running, invalid;
	VAR
		status : {success, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) := 
			case
				reset : invalid;
				active : {success};
				TRUE : status;
			esac;
