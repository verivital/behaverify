configuration{}
enumerations {
    'yes', 'no', 'both'
}
constants {
    MIN_VAL := 2,
    MAX_VAL := 5
}
variables { 
    variable { bl blVAR0 VAR {'yes', 'no', 'both'}
	assign {case {True} result { 'both'}result {'yes'}}	}
    variable { env envVAR1 array 2 VAR {'yes', 'no', 'both'}
	default {assign {case {(xnor, (xor, False, False), (xor, True, False))} result { blVAR0}result {'no'}}}(loop, loop_0, {((min, 50, (max, -50, (max, (loop, loop_0, {(xnor, True, True), (gte, 2, ((min, 50, (max, -50, (neg, -35)))))} such_that True, ((min, 50, (max, -50, (add, (loop, loop_1, {(or, (and, False, True), True), (xnor, (gt, 9, -18), False), (or, True, False), (neq, 'no', 'no')} such_that True, 16)))))))))), -49} such_that True, index_of {(max, 0, (min, 1, 5))}assign {result {'both'}})	}
    variable { env envVAR2 VAR [2, 5]
	assign {case {False} result { (min, 5, (max, 2, ((min, 50, (max, -50, (add, ((min, 50, (max, -50, (mult, 2, -22)))), 13))))))}case {(lte, 4, (if, (xor, False, True), 19, 5))} result { (min, 5, (max, 2, ((min, 50, (max, -50, (sub, ((min, 50, (max, -50, (add, (loop, loop_0, {((min, 50, (max, -50, (add, (loop, loop_0, {'both', 'both', 'no'} such_that True, (if, (gte, 4, -2), -20, 3)), -5)))), (if, (neq, 'no', 'yes'), 3, -4)} such_that True, 25), (loop, loop_0, {46, (if, (xnor, True, True), ((min, 50, (max, -50, (abs, ((min, 50, (max, -50, (abs, 10)))))))), ((min, 50, (max, -50, (abs, 31)))))} such_that True, 36))))), ((min, 50, (max, -50, (min, (loop, loop_0, {blVAR0, blVAR0} such_that True, 4)))))))))))}result {(min, 5, (max, 2, ((min, 50, (max, -50, (sub, -49, (count, (implies, False, False), (neq, -38, 3), (equivalent, True, False), (and, False, True))))))))}}	}
    variable { env envVAR3 VAR [-5, -2]
	assign {case {False} result { (min, -2, (max, -5, envVAR2))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (add, (loop, loop_0, {'no', 'yes'} such_that True, envVAR2), 21, envVAR2))))))}}	}
    variable { env envFROZENVAR4 FROZENVAR {'yes', 'no', 'both'}
	assign {case {(gte, ((min, 50, (max, -50, (neg, envVAR2)))), (if, (gt, envVAR3, envVAR3), 25, envVAR2))} result { 'both'}result {'both'}}	}
    variable { local localFROZENVAR5 array 2 FROZENVAR [-5, -2]
	default {assign {case {(eq, 'both', blVAR0)} result { (min, -2, (max, -5, ((min, 50, (max, -50, (max, (if, (xor, True, False), 5, 16), -48))))))}case {(and, (eq, True, False), True)} result { (min, -2, (max, -5, ((min, 50, (max, -50, (add, (loop, loop_0, {blVAR0, blVAR0} such_that True, ((min, 50, (max, -50, (neg, -6))))), (loop, loop_0, {(lte, ((min, 50, (max, -50, (min, (loop, loop_0, {'both', 'both'} such_that True, 2))))), 3), (implies, False, True)} such_that True, -2)))))))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (add, (loop, loop_0, {'yes', 'both', 'yes'} such_that True, ((min, 50, (max, -50, (abs, -36))))), (if, (lt, 3, 10), -48, -11)))))))}}}constant_index index_of {0, 1}assign {case {(lt, 4, -5)} result { (min, -2, (max, -5, -5))}case {(eq, True, False)} result { (min, -2, (max, -5, -3))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (sub, 0, (if, (neq, 2, -3), 4, 15)))))))}}	}
    variable { env envDEFINE6 array 2 DEFINE BOOLEAN
	default {
	    assign {
		case {False}
		result { (xnor, True, False)}
		case {(equivalent, (gt, -47, 14), (equivalent, (and, False, False), False))}
		#{case {False}}#
		result { (xor, True, True)}
		result {(eq, (index, envVAR1, (max, 0, (min, 1, envVAR3))), 'both')}
	    }
	}
	(loop, loop_0, {
		((min, 50, (max, -50, (add, -7, 49)))),
		((min, 50, (max, -50, (min, 4, ((min, 50, (max, -50, (add, (loop, loop_0, {'yes', 'both'} such_that True, -14))))))))
		)
	    } such_that True,
	    (loop, loop_1, {envVAR3, envVAR3, envVAR2} such_that True,
		(loop, loop_2, {((min, 50, (max, -50, (neg, 15)))), 5} such_that True,
		    index_of {(max, 0, (min, 1, (if, (lt, 27, 43), -33, 41)))}
		    assign {result {True}}
		)
	    )
	)
    }
    variable { env envDEFINE7 array 2 DEFINE INT
	default {assign {result {(min, -2, (max, -5, ((min, 50, (max, -50, (max, (loop, loop_0, {blVAR0, blVAR0} such_that True, envVAR2)))))))}}}(loop, loop_0, {(and, False, False), (neq, 'both', 'both')} such_that True, (loop, loop_1, {(xnor, True, (and, True, False)), (xor, (eq, (and, True, True), True), (lt, -4, -20))} such_that True, (loop, loop_2, {False, (xnor, (and, False, False), (lte, 0, -4)), True} such_that True, index_of {(max, 0, (min, 1, ((min, 50, (max, -50, (add, ((min, 50, (max, -50, (max, 45, envVAR3)))), (if, (lte, 46, 32), envVAR2, 7), (loop, loop_3, {envVAR2, envVAR3} such_that True, ((min, 50, (max, -50, (max, (loop, loop_4, {((min, 50, (max, -50, (max, (loop, loop_4, {'both', 'both'} such_that True, ((min, 50, (max, -50, (add, (loop, loop_5, {'no', 'yes', 'yes'} such_that True, -8)))))))))), (if, (or, True, False), -4, -5)} such_that True, envVAR3)))))))))))), (max, 0, (min, 1, (count, (xor, (and, True, False), False), (or, (index, envDEFINE6, (max, 0, (min, 1, envVAR3))), (implies, True, True)))))}assign {case {(gt, envVAR3, ((min, 50, (max, -50, (max, -30, envVAR2)))))} result { (min, -2, (max, -5, (if, (gt, ((min, 50, (max, -50, (max, -5, envVAR3)))), -24), ((min, 50, (max, -50, (max, envVAR2, envVAR3)))), (if, (lt, envVAR2, -41), envVAR3, envVAR3))))}case {(index, envDEFINE6, (max, 0, (min, 1, envVAR2)))} result { (min, -2, (max, -5, envVAR2))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (add, ((min, 50, (max, -50, (add, (if, (xor, True, False), envVAR2, envVAR3), (if, (and, False, False), envVAR2, -34))))), -25, (if, (gte, -36, 14), envVAR3, envVAR3)))))))}})))	}
}
environment_update {
    variable_statement{ envVAR1
	(loop, loop_0, {(count, (eq, -2, -18), (xor, (lt, ((min, 50, (max, -50, (mult, (loop, loop_0, {((min, 50, (max, -50, (sub, (loop, loop_0, {((min, 50, (max, -50, (mult, (loop, loop_0, {'yes', 'no', 'both'} such_that True, -6))))), ((min, 50, (max, -50, (mult, 24, ((min, 50, (max, -50, (abs, 5)))), ((min, 50, (max, -50, (neg, -2))))))))} such_that True, ((min, 50, (max, -50, (max, (loop, loop_1, {'yes', 'no'} such_that True, -10)))))))))), ((min, 50, (max, -50, (mult, (loop, loop_0, {(equivalent, False, False), False} such_that True, (count, (neq, 42, (count, (lte, -41, -3), (lte, 37, -4), (xnor, True, False))), (gt, 31, ((min, 50, (max, -50, (sub, -4, -46))))))))))), (if, (xor, False, False), 3, -40)} such_that True, -22))))), ((min, 50, (max, -50, (abs, -30))))), False), (or, True, (or, (implies, True, False), (eq, True, True))), (lt, ((min, 50, (max, -50, (neg, -2)))), (count, (equivalent, True, True), (xor, False, False), (implies, False, True)))), -2} such_that True, (loop, loop_1, {blVAR0, blVAR0, blVAR0} such_that True, index_of {(max, 0, (min, 1, ((min, 50, (max, -50, (max, -47, -1)))))), (max, 0, (min, 1, ((min, 50, (max, -50, (abs, (index, envDEFINE7, (max, 0, (min, 1, -5)))))))))}assign {case {(or, (xnor, True, True), (xor, (index, envDEFINE6, (max, 0, (min, 1, -17))), (or, True, True)))} result { blVAR0}result {'yes'}}))(loop, loop_0, {envFROZENVAR4, envFROZENVAR4, envFROZENVAR4, envFROZENVAR4} such_that True, (loop, loop_1, {envVAR3, envVAR3, envVAR2} such_that True, index_of {(max, 0, (min, 1, ((min, 50, (max, -50, (sub, (loop, loop_2, {'no', 'no'} such_that True, envVAR2))))))), (max, 0, (min, 1, ((min, 50, (max, -50, (abs, 33))))))}assign {case {(lt, ((min, 50, (max, -50, (abs, (index, envDEFINE7, (max, 0, (min, 1, envVAR3))))))), ((min, 50, (max, -50, (add, (loop, loop_2, {'yes', 'yes', 'both', 'both'} such_that True, 26))))))} result { envFROZENVAR4}result {blVAR0}}))	}
    variable_statement{ envVAR2
	assign {
	    case {(equivalent,
		    (index, envDEFINE6, (max, 0, (min, 1, 23))),
		    (eq, ((min, 50, (max, -50, (min, -18, 19)))), ((min, 50, (max, -50, (min, (loop, loop_0, {'no', 'yes'} such_that True, envVAR3))))))
		)
	    }
	    result { (min, 5, (max, 2, ((min, 50, (max, -50, (min, 17, ((min, 50, (max, -50, (min, 25, 42))))))))))}
	    result {(min, 5, (max, 2, (if, (lte, envVAR3, -14), 7, envVAR3)))}}
    }
}
checks{
    check {
	c1
	arguments{}
	read_variables {blVAR0}
	condition{False}
    }
    check {
	c2
	arguments{}
	read_variables {blVAR0}
	condition{(xor, True, (equivalent, False, True))}
    }
}
environment_checks {}
actions{
    action {
	a1
	arguments{}
	local_variables {}
	read_variables { }
	write_variables {blVAR0}
	initial_values {
	    
	}
	update {
	    read_environment {
		a1_read_before_0
		condition {(index, envDEFINE6, (max, 0, (min, 1, -2)))}
		variable_statement{ blVAR0
		    assign {result {'yes'}}				}
	    }
	    return_statement {
		case { (neq, (or, False, True), (neq, 26, -5))} result { running}
		case { (gt, ((min, 50, (max, -50, (mult, (loop, loop_0, {'yes', 'both'} such_that True, 5))))), -23)} result { running}
		result {running}
	    }
	    read_environment {
		a1_read_after_0
		condition {(implies, False, (lt, envVAR3, 30))}
		variable_statement{ blVAR0
		    assign {result {(index, envVAR1, (max, 0, (min, 1, -42)))}}				}
		variable_statement{ blVAR0
		    assign {result {'yes'}}				}
	    }
	}
    }
    action {
	a2
	arguments{}
	local_variables {localFROZENVAR5}
	read_variables { }
	write_variables {blVAR0}
	initial_values {
	    
	}
	update {
	    return_statement {
		case { (or, False, False)} result { running}
		case { (gte, ((min, 50, (max, -50, (neg, -32)))), ((min, 50, (max, -50, (min, (loop, loop_0, {(if, (equivalent, (neq, 2, 3), (lte, 3, -33)), ((min, 50, (max, -50, (mult, (loop, loop_0, {(implies, (neq, 'no', 'no'), False), (equivalent, True, False), (lt, 38, 2)} such_that True, -3))))), ((min, 50, (max, -50, (abs, -2))))), -22} such_that True, (index, localFROZENVAR5, (max, 0, (min, 1, -32)))))))))} result { running}
		result {running}
	    }
	}
    }
    action {
	a3
	arguments{}
	local_variables {}
	read_variables { }
	write_variables {blVAR0}
	initial_values {
	    
	}
	update {
	    write_environment {
		a3_write_before_0
		variable_statement{ instant envVAR2
		    assign {case {False} result { (min, 5, (max, 2, -17))}result {(min, 5, (max, 2, (if, (lte, (if, (eq, -39, (if, (eq, False, True), 43, 48)), ((min, 50, (max, -50, (add, (index, envDEFINE7, (max, 0, (min, 1, -45))), 13)))), ((min, 50, (max, -50, (min, (loop, loop_0, {envVAR3, envVAR3} such_that True, -1)))))), ((min, 50, (max, -50, (neg, envVAR2))))), (if, (neq, envFROZENVAR4, envFROZENVAR4), ((min, 50, (max, -50, (neg, -2)))), ((min, 50, (max, -50, (add, (loop, loop_0, {(if, (gte, -5, -4), 4, 5), ((min, 50, (max, -50, (max, ((min, 50, (max, -50, (abs, 49)))), (count, (lte, -10, ((min, 50, (max, -50, (neg, 36))))), (xnor, False, True), (lt, -3, 5)))))), ((min, 50, (max, -50, (sub, (loop, loop_0, {'no', 'both'} such_that True, ((min, 50, (max, -50, (add, (loop, loop_1, {(and, False, False), (xnor, (equivalent, False, False), False), (gte, -2, (if, (gte, 2, -4), 3, 5))} such_that True, 19), 19)))))))))} such_that True, -31), 28))))), ((min, 50, (max, -50, (max, ((min, 50, (max, -50, (max, (loop, loop_0, {'yes', 'no'} such_that True, 3))))), envVAR2)))))))}}				}
	    }
	    return_statement {
		case { False} result { running}
		result {failure}
	    }
	}
    }
    action {
	a4
	arguments{}
	local_variables {}
	read_variables { }
	write_variables {blVAR0}
	initial_values {
	    
	}
	update {
	    write_environment {
		a4_write_before_0
		variable_statement{ envVAR2
		    assign {case {(lte, ((min, 50, (max, -50, (neg, 21)))), ((min, 50, (max, -50, (mult, (loop, loop_0, {(and, True, (or, True, True)), True, False, (xor, (xnor, (neq, 'both', 'yes'), (gte, 5, 4)), True)} such_that True, envVAR2))))))} result { (min, 5, (max, 2, ((min, 50, (max, -50, (add, (loop, loop_0, {'both', 'no'} such_that True, 38), ((min, 50, (max, -50, (max, -41, 5))))))))))}case {(gt, ((min, 50, (max, -50, (neg, -49)))), ((min, 50, (max, -50, (abs, envVAR3)))))} result { (min, 5, (max, 2, envVAR2))}result {(min, 5, (max, 2, envVAR3))}}				}
	    }
	    return_statement {
		case { (equivalent, (or, True, True), (neq, -39, -6))} result { running}
		case { (or, True, False)} result { success}
		result {failure}
	    }
	}
    }
}
sub_trees{}
tree {
    composite {
	seq0
	sequence
	with_partial_memory
	children {
	    a4{}
	    a3{}
	    a3{}
	}
    }
}
tick_prerequisite{True}
specifications { #{ INVAR, LTL, and CTL specs go here }# } end_specifications