configuration{}
enumerations {
	'yes', 'no', 'both'
}
constants {
	MIN_VAL := 2,
	MAX_VAL := 5
}
variables { 
	variable { bl blVAR0 array 3 VAR [2, 5]
default {assign {case {(lte, ((min, 50, (max, -50, (sub, (loop, loop_0, {((min, 50, (max, -50, (abs, -3)))), ((min, 50, (max, -50, (min, -16, 2))))} such_that True, 3))))), ((min, 50, (max, -50, (mult, (loop, loop_0, {'both', 'yes', 'both', 'both'} such_that True, 2))))))} result { (min, 5, (max, 2, ((min, 50, (max, -50, (min, (loop, loop_0, {((min, 50, (max, -50, (min, (if, (or, False, True), -3, -39), ((min, 50, (max, -50, (add, (loop, loop_0, {'both', 'yes'} such_that True, 5), 37)))))))), ((min, 50, (max, -50, (abs, 25))))} such_that True, ((min, 50, (max, -50, (neg, 4)))))))))))}result {(min, 5, (max, 2, -47))}}}index_of {(max, 0, (min, 2, (if, (lt, 5, -2), -5, -14)))}assign {result {(min, 5, (max, 2, ((min, 50, (max, -50, (mult, (loop, loop_0, {'both', 'yes'} such_that True, 2), ((min, 50, (max, -50, (add, (loop, loop_0, {'both', 'both'} such_that True, (if, (or, False, False), -15, 2)))))), 6))))))}}(loop, loop_0, {((min, 50, (max, -50, (abs, (if, (lte, ((min, 50, (max, -50, (abs, 2)))), 5), ((min, 50, (max, -50, (min, -5, 29)))), ((min, 50, (max, -50, (neg, -9))))))))), ((min, 50, (max, -50, (max, ((min, 50, (max, -50, (max, 30, -2)))), ((min, 50, (max, -50, (sub, (loop, loop_0, {7, -2} such_that True, 17))))))))), ((min, 50, (max, -50, (min, (loop, loop_0, {'yes', 'no'} such_that True, ((min, 50, (max, -50, (max, (loop, loop_1, {-5, ((min, 50, (max, -50, (min, (if, (and, False, True), -5, -40), 6))))} such_that True, 4))))))))))} such_that True, index_of {(max, 0, (min, 2, 2))}assign {case {(equivalent, True, False)} result { (min, 5, (max, 2, ((min, 50, (max, -50, (neg, ((min, 50, (max, -50, (add, (loop, loop_1, {'no', 'both', 'yes', 'yes'} such_that True, -18)))))))))))}case {False} result { (min, 5, (max, 2, ((min, 50, (max, -50, (max, 33, 41))))))}result {(min, 5, (max, 2, (count, (neq, True, False), (or, False, True), (neq, 5, 48), (xor, False, False))))}})	}
	variable { env envVAR1 array 3 VAR {'yes', 'no', 'both'}
default {assign {case {(gt, (index, blVAR0, (max, 0, (min, 2, 5))), ((min, 50, (max, -50, (min, 5, 34)))))} result { 'no'}case {(gte, 2, 3)} result { 'yes'}result {'yes'}}}(loop, loop_0, {(count, (implies, (xor, (equivalent, True, True), (eq, True, False)), True), (gt, ((min, 50, (max, -50, (max, 32, 4)))), -2), (or, (or, True, False), False), (xnor, (lte, 48, -3), (neq, True, False))), (count, (eq, 'yes', 'no'), (xor, True, True), (and, False, False)), (if, (eq, True, (lte, 15, 3)), ((min, 50, (max, -50, (abs, 20)))), ((min, 50, (max, -50, (min, (count, (neq, -25, 4), (xor, False, False)), -21)))))} such_that True, (loop, loop_1, {'both', 'both', 'both', 'yes'} such_that True, index_of {(max, 0, (min, 2, -34))}assign {case {(gt, (count, (or, (implies, False, False), (xnor, False, True)), (xnor, (lt, (index, blVAR0, (max, 0, (min, 2, 3))), 4), False)), 5)} result { 'both'}result {'both'}}))index_of {(max, 0, (min, 2, 29))}assign {result {'no'}}	}
	variable { local localVAR2 VAR [-5, -2]
assign {case {(eq, (count, (lte, -27, (index, blVAR0, (max, 0, (min, 2, 39)))), (or, False, True), (neq, 'yes', 'yes'), (equivalent, True, False)), -16)} result { (min, -2, (max, -5, -4))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (neg, 3))))))}}	}
	variable { bl blVAR3 VAR [2, 5]
assign {result {(min, 5, (max, 2, ((min, 50, (max, -50, (max, (loop, loop_0, {((min, 50, (max, -50, (abs, -3)))), ((min, 50, (max, -50, (mult, (loop, loop_0, {((min, 50, (max, -50, (max, 4, 31)))), ((min, 50, (max, -50, (max, (loop, loop_0, {'both', 'no'} such_that True, ((min, 50, (max, -50, (sub, -42, -4)))))))))} such_that True, (count, (neq, True, True), (gt, 26, -3))), 37))))} such_that True, -4)))))))}}	}
	variable { local localVAR4 VAR {'yes', 'no', 'both'}
assign {case {False} result { 'no'}result {'no'}}	}
	variable { bl blDEFINE5 array 2 DEFINE INT
default {assign {case {(neq, 'no', 'both')} result { (min, -2, (max, -5, ((min, 50, (max, -50, (sub, (loop, loop_0, {(gte, 37, 4), (implies, (implies, True, True), False)} such_that True, 44)))))))}case {(xor, False, False)} result { (min, -2, (max, -5, 13))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (abs, blVAR3))))))}}}constant_index index_of {0, 1}assign {case {(lt, blVAR3, 43)} result { (min, -2, (max, -5, ((min, 50, (max, -50, (abs, 17))))))}result {(min, -2, (max, -5, ((min, 50, (max, -50, (sub, ((min, 50, (max, -50, (neg, -18)))), ((min, 50, (max, -50, (add, -37, (index, blVAR0, (max, 0, (min, 2, blVAR3)))))))))))))}}	}
	variable { env envDEFINE6 DEFINE ENUM
assign {result {(index, envVAR1, (max, 0, (min, 2, blVAR3)))}}	}
	variable { bl blDEFINE7 DEFINE INT
assign {case {False} result { (min, -2, (max, -5, 14))}case {(lt, (count, (eq, (xor, False, True), False), (gte, ((min, 50, (max, -50, (add, 50, -28, -6, blVAR3)))), ((min, 50, (max, -50, (abs, (index, blVAR0, (max, 0, (min, 2, 12)))))))), (xnor, False, True), (gte, 4, ((min, 50, (max, -50, (sub, (loop, loop_0, {blVAR3, blVAR3} such_that True, 2))))))), ((min, 50, (max, -50, (max, (loop, loop_0, {48, ((min, 50, (max, -50, (add, (loop, loop_0, {True, (neq, -2, -6)} such_that True, -3), 33))))} such_that True, -29))))))} result { (min, -2, (max, -5, ((min, 50, (max, -50, (mult, (loop, loop_0, {'no', 'both', 'yes'} such_that True, 46)))))))}result {(min, -2, (max, -5, -22))}}	}
	variable { env envDEFINE8 array 3 DEFINE ENUM
default {assign {result {(index, envVAR1, (max, 0, (min, 2, -16)))}}}(loop, loop_0, {(neq, (if, (xnor, True, False), 2, -48), ((min, 50, (max, -50, (max, 15, -35))))), (or, (gt, ((min, 50, (max, -50, (mult, (loop, loop_0, {(implies, True, False), True} such_that True, -9))))), ((min, 50, (max, -50, (min, -2, -5))))), True)} such_that True, (loop, loop_1, {envDEFINE6, envDEFINE6} such_that True, index_of {(max, 0, (min, 2, (count, (lte, -3, ((min, 50, (max, -50, (add, blDEFINE7, 50, -5))))), (xnor, True, False)))), (max, 0, (min, 2, ((min, 50, (max, -50, (neg, blVAR3))))))}assign {case {(equivalent, (or, False, True), (gte, (index, blDEFINE5, (max, 0, (min, 1, -17))), ((min, 50, (max, -50, (min, blVAR3, blVAR3))))))} result { 'yes'}result {'no'}}))	}
}
environment_update {
	variable_statement{ envVAR1
(loop, loop_0, {((min, 50, (max, -50, (max, (loop, loop_0, {-2, ((min, 50, (max, -50, (mult, (loop, loop_0, {'no', 'yes'} such_that True, 43)))))} such_that True, 10))))), ((min, 50, (max, -50, (max, (loop, loop_0, {'no', 'no'} such_that True, (count, (gte, (if, (equivalent, True, False), -5, -3), -2), (neq, (gt, 5, 3), (xnor, False, True)), (and, (implies, False, False), True), (or, (equivalent, False, False), True))))))), (count, (and, False, (neq, 2, -9)), (gt, 4, (count, (or, True, True), (gt, 3, 40))), (implies, False, True), (lte, ((min, 50, (max, -50, (max, 5, 2)))), (if, (lte, -5, -4), -4, -3)))} such_that True, (loop, loop_1, {(if, (or, False, True), -10, -5), (if, (gte, 13, 40), -4, 4), ((min, 50, (max, -50, (min, (loop, loop_1, {((min, 50, (max, -50, (max, (loop, loop_1, {'no', 'yes'} such_that True, -5))))), -5} such_that True, (if, (lte, -47, -39), 5, 3)))))), ((min, 50, (max, -50, (sub, 2, -5))))} such_that True, (loop, loop_2, {'yes', 'both', 'yes'} such_that True, index_of {(max, 0, (min, 2, ((min, 50, (max, -50, (max, -25, ((min, 50, (max, -50, (neg, -1)))))))))), (max, 0, (min, 2, ((min, 50, (max, -50, (add, (loop, loop_3, {blDEFINE7, blDEFINE7} such_that True, 29), ((min, 50, (max, -50, (abs, (index, blDEFINE5, (max, 0, (min, 1, -9))))))), ((min, 50, (max, -50, (abs, blVAR3))))))))))}assign {case {(or, (lt, -9, -22), True)} result { (index, envDEFINE8, (max, 0, (min, 2, -20)))}case {(neq, envDEFINE6, 'both')} result { 'yes'}result {'both'}})))	}
	variable_statement{ envVAR1
(loop, loop_0, {'no', 'both', 'both', 'both'} such_that True, index_of {(max, 0, (min, 2, 23)), (max, 0, (min, 2, ((min, 50, (max, -50, (mult, -33, blVAR3))))))}assign {case {(or, False, (implies, True, True))} result { envDEFINE6}case {False} result { envDEFINE6}result {envDEFINE6}})	}
	variable_statement{ envVAR1
constant_index index_of {0, 1}assign {case {(implies, False, True)} result { envDEFINE6}case {True} result { (index, envDEFINE8, (max, 0, (min, 2, -43)))}result {'both'}}	}
}
checks{
	check {
		c1
		arguments{}
		read_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		condition{(neq, False, False)}
	}
	check {
		c2
		arguments{}
		read_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		condition{(eq, (neq, 38, (index, blVAR0, (max, 0, (min, 2, 4)))), (equivalent, True, False))}
	}
}
environment_checks {}
actions{
	action {
		a1
		arguments{}
		local_variables {localVAR2}
		read_variables { }
		write_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		initial_values {
			variable_statement{ localVAR2
assign {result {(min, -2, (max, -5, ((min, 50, (max, -50, (mult, ((min, 50, (max, -50, (abs, blVAR3)))), ((min, 50, (max, -50, (sub, (loop, loop_0, {(lt, (count, (equivalent, False, True), (xnor, False, False), (equivalent, False, False), (and, False, True)), ((min, 50, (max, -50, (max, (loop, loop_0, {'no', 'yes'} such_that True, 3)))))), (xnor, (eq, True, False), False)} such_that True, blVAR3))))), blVAR3))))))}}			}

		}
		update {
			variable_statement{ localVAR2
assign {case {(gt, ((min, 50, (max, -50, (abs, blDEFINE7)))), ((min, 50, (max, -50, (min, (loop, loop_0, {localVAR2, localVAR2} such_that True, blVAR3))))))} result { (min, -2, (max, -5, ((min, 50, (max, -50, (abs, ((min, 50, (max, -50, (min, (loop, loop_0, {-2, ((min, 50, (max, -50, (mult, (loop, loop_0, {((min, 50, (max, -50, (sub, (loop, loop_0, {True, False} such_that True, ((min, 50, (max, -50, (min, (loop, loop_1, {False, (gte, -21, -2)} such_that True, -8)))))))))), (if, (implies, (lt, -2, (if, (implies, False, False), 41, -6)), (equivalent, True, (lt, -3, 49))), ((min, 50, (max, -50, (neg, ((min, 50, (max, -50, (add, (loop, loop_0, {'yes', 'yes'} such_that True, 8), 17)))))))), ((min, 50, (max, -50, (min, (loop, loop_0, {(lt, 22, 32), (implies, (implies, False, False), False)} such_that True, 48)))))), ((min, 50, (max, -50, (add, (loop, loop_0, {(or, False, True), (implies, False, True)} such_that True, -4)))))} such_that True, ((min, 50, (max, -50, (sub, 23, -46)))))))))} such_that True, blDEFINE7)))))))))))}result {(min, -2, (max, -5, (index, blDEFINE5, (max, 0, (min, 1, blDEFINE7)))))}}			}
			variable_statement{ localVAR2
assign {result {(min, -2, (max, -5, (count, (neq, 'both', 'yes'), (eq, 'both', 'yes'))))}}			}
			return_statement {
				case { (xor, False, True)} result { failure}
				case { (neq, False, True)} result { success}
				result {running}
			}
			read_environment {
				a1_read_after_0
				condition {(gt, blVAR3, ((min, 50, (max, -50, (max, (loop, loop_0, {'no', 'no'} such_that True, (index, blDEFINE5, (max, 0, (min, 1, -23)))))))))}
				variable_statement{ blVAR0
constant_index index_of {0, 1}assign {case {(and, (equivalent, True, False), (or, (gt, 3, (index, blDEFINE5, (max, 0, (min, 1, localVAR2)))), False))} result { (min, 5, (max, 2, 43))}result {(min, 5, (max, 2, ((min, 50, (max, -50, (neg, -7))))))}}				}
			}
		}
	}
	action {
		a2
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		initial_values {

		}
		update {
			return_statement {
				case { (gte, blDEFINE7, (if, (eq, False, False), blVAR3, blVAR3))} result { running}
				case { False} result { failure}
				result {running}
			}
			write_environment {
				a2_write_after_0
				variable_statement{ instant envVAR1
(loop, loop_0, {envDEFINE6, envDEFINE6, envDEFINE6, envDEFINE6} such_that True, (loop, loop_1, {envDEFINE6, envDEFINE6, envDEFINE6} such_that True, (loop, loop_2, {2, (count, (neq, False, (xnor, True, False)), (lt, -2, 9), (or, (eq, 12, -14), (and, True, False))), ((min, 50, (max, -50, (sub, (loop, loop_2, {'yes', 'yes'} such_that True, 47))))), ((min, 50, (max, -50, (max, ((min, 50, (max, -50, (min, -4, -30)))), (if, (gte, -21, -5), -10, -5)))))} such_that True, index_of {(max, 0, (min, 2, ((min, 50, (max, -50, (sub, ((min, 50, (max, -50, (min, blVAR3, (index, blDEFINE5, (max, 0, (min, 1, 39))))))), blDEFINE7))))))}assign {result {'yes'}})))index_of {(max, 0, (min, 2, -4))}assign {result {(index, envVAR1, (max, 0, (min, 2, blDEFINE7)))}}				}
			}
		}
	}
	action {
		a3
		arguments{}
		local_variables {localVAR2}
		read_variables { }
		write_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		initial_values {

		}
		update {
			return_statement {
				case { True} result { success}
				case { (and, False, False)} result { running}
				result {running}
			}
		}
	}
	action {
		a4
		arguments{}
		local_variables {}
		read_variables { }
		write_variables {blVAR0, blVAR3, blDEFINE5, blDEFINE7}
		initial_values {

		}
		update {
			variable_statement{ blVAR0
constant_index index_of {0, 1}assign {case {(equivalent, (or, True, True), (and, False, False))} result { (min, 5, (max, 2, -12))}case {(and, (xor, True, False), (lte, (index, blVAR0, (max, 0, (min, 2, blDEFINE7))), -46))} result { (min, 5, (max, 2, ((min, 50, (max, -50, (sub, (loop, loop_0, {3, ((min, 50, (max, -50, (add, (loop, loop_0, {'both', 'no'} such_that True, 43), -3))))} such_that True, blDEFINE7)))))))}result {(min, 5, (max, 2, (count, (lt, blDEFINE7, blDEFINE7), (and, False, False), (neq, 'both', 'yes'), (lte, -50, -6))))}}			}
			write_environment {
				a4_write_before_0
				variable_statement{ envVAR1
(loop, loop_0, {'no', 'yes', 'both', 'yes'} such_that True, (loop, loop_1, {(or, False, True), (xor, True, False), (gt, -5, (if, (gt, 24, 5), -31, -20)), (eq, False, False)} such_that True, index_of {(max, 0, (min, 2, ((min, 50, (max, -50, (sub, ((min, 50, (max, -50, (sub, (loop, loop_2, {'yes', 'no'} such_that True, ((min, 50, (max, -50, (mult, (loop, loop_3, {-20, ((min, 50, (max, -50, (add, (loop, loop_3, {(lte, ((min, 50, (max, -50, (neg, 5)))), 3), (gt, -22, -5), (xor, False, (neq, (and, False, False), (lte, -5, 44)))} such_that True, ((min, 50, (max, -50, (max, 5, -5))))))))), (if, (eq, 39, -29), 37, -4)} such_that True, (index, blVAR0, (max, 0, (min, 2, 5)))), 2))))))))), -44))))))}assign {result {(index, envVAR1, (max, 0, (min, 2, -4)))}}))index_of {(max, 0, (min, 2, ((min, 50, (max, -50, (neg, (if, (xnor, False, True), -4, 40))))))), (max, 0, (min, 2, ((min, 50, (max, -50, (max, ((min, 50, (max, -50, (min, (loop, loop_0, {'both', 'no'} such_that True, blDEFINE7))))), ((min, 50, (max, -50, (neg, ((min, 50, (max, -50, (min, (loop, loop_0, {'no', 'both'} such_that True, 0)))))))))))))))}assign {case {(lt, blDEFINE7, 12)} result { 'no'}case {(lt, -46, (if, (neq, 'no', 'yes'), ((min, 50, (max, -50, (add, (loop, loop_0, {(lt, ((min, 50, (max, -50, (sub, -3, 3)))), 5), (or, False, True)} such_that True, (index, blDEFINE5, (max, 0, (min, 1, blDEFINE7)))))))), ((min, 50, (max, -50, (add, (loop, loop_0, {(eq, 'yes', 'no'), (gte, ((min, 50, (max, -50, (sub, (loop, loop_0, {(implies, True, (eq, 'both', 'both')), (neq, False, False)} such_that True, -4))))), 50), (implies, (and, True, True), (gte, 5, 47))} such_that True, 20)))))))} result { 'no'}result {'yes'}}				}
			}
			return_statement {
				case { (gt, blVAR3, blDEFINE7)} result { success}
				result {running}
			}
		}
	}
}
sub_trees{}
tree {
	decorator {
		dec_inv0
		inverter
		child {
			composite {
				p_one1
				parallel policy success_on_one
				
				children {
					c2{}
					a3{}
					a2{}
				}
			}
		}
	}
}
tick_prerequisite{True}
specifications { #{ INVAR, LTL, and CTL specs go here }# } end_specifications