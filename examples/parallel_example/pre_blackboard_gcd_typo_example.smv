MODULE main
	DEFINE
		max_active_node := 14;
		next_status :=
			case
				(active_node < 0) : invalid;
				(active_node = 0) : next(statuses[0]);
				(active_node = 1) : next(statuses[1]);
				(active_node = 2) : next(statuses[2]);
				(active_node = 3) : next(statuses[3]);
				(active_node = 4) : next(statuses[4]);
				(active_node = 5) : next(statuses[5]);
				(active_node = 6) : next(statuses[6]);
				(active_node = 7) : next(statuses[7]);
				(active_node = 8) : next(statuses[8]);
				(active_node = 9) : next(statuses[9]);
				(active_node = 10) : next(statuses[10]);
				(active_node = 11) : next(statuses[11]);
				(active_node = 12) : next(statuses[12]);
				(active_node = 13) : next(statuses[13]);
				(active_node = 14) : next(statuses[14]);
				TRUE : invalid;
			esac;
		statuses := [root.status, guard_node.status, guard_node1.status, gcd_root.status, check_a_exists.status, init_a.status, check_b_exists.status, init_b.status, subtract_seq.status, swap_seq.status, check_r_gt_q.status, r_minus_q.status, store_r.status, update_r.status, update_q.status];
		parents := [-1, 0, 0, 0, 1, 1, 2, 2, 3, 3, 8, 8, 9, 9, 9];
		leafs := {-2, 4, 5, 6, 7, 10, 11, 12, 13, 14};
		selectors := {-2, 1, 2, 3};
		sequences := {-2, 0, 8, 9};
		parallels := {-2};
		decorators := {-2};
		max_children := [2, 1, 1, 1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1];
		children_start_index := [1, 4, 6, 8, 0, 0, 0, 0, 10, 12, 0, 0, 0, 0, 0];
		last_child := [3, 5, 7, 9, -1, -1, -1, -1, 11, 14, -1, -1, -1, -1, -1];
	VAR
		active_node : -2..max_active_node;
		previous_status : {failure, running, success, invalid};
		root : node_sequence(statuses, active_node, 0, previous_status, 3);
		guard_node : node_selector(statuses, active_node, 1, previous_status, 5);
		guard_node1 : node_selector(statuses, active_node, 2, previous_status, 7);
		gcd_root : node_selector(statuses, active_node, 3, previous_status, 9);
		check_a_exists : node_check_blackboard_variable_exists(statuses, active_node, 4, blackboard, 0);
		init_a : node_set_blackboard_variables(statuses, active_node, 5);
		init_a_SET_a : init_a_SET_a_module(active_node,5, blackboard, other_info);
		init_a_SET_status : init_a_SET_status_module(active_node,5, blackboard, other_info);
		check_b_exists : node_check_blackboard_variable_exists(statuses, active_node, 6, blackboard, 1);
		init_b : node_set_blackboard_variables(statuses, active_node, 7);
		init_b_SET_b : init_b_SET_b_module(active_node,7, blackboard, other_info);
		init_b_SET_status : init_b_SET_status_module(active_node,7, blackboard, other_info);
		subtract_seq : node_sequence(statuses, active_node, 8, previous_status, 11);
		swap_seq : node_sequence(statuses, active_node, 9, previous_status, 14);
		check_r_gt_q : node_check_blackboard_variable_value(statuses, active_node, 10, blackboard, 2, check_r_gt_q_CHECK_r);
		check_r_gt_q_CHECK_r : check_r_gt_q_CHECK_r_module(active_node, 10, blackboard, other_info);
		r_minus_q : node_set_blackboard_variables(statuses, active_node, 11);
		r_minus_q_SET_r : r_minus_q_SET_r_module(active_node,11, blackboard, other_info);
		r_minus_q_SET_status : r_minus_q_SET_status_module(active_node,11, blackboard, other_info);
		store_r : node_set_blackboard_variables(statuses, active_node, 12);
		store_r_SET_temp : store_r_SET_temp_module(active_node,12, blackboard, other_info);
		store_r_SET_status : store_r_SET_status_module(active_node,12, blackboard, other_info);
		update_r : node_set_blackboard_variables(statuses, active_node, 13);
		update_r_SET_r : update_r_SET_r_module(active_node,13, blackboard, other_info);
		update_r_SET_status : update_r_SET_status_module(active_node,13, blackboard, other_info);
		update_q : node_set_blackboard_variables(statuses, active_node, 14);
		update_q_SET_q : update_q_SET_q_module(active_node,14, blackboard, other_info);
		update_q_SET_status : update_q_SET_status_module(active_node,14, blackboard, other_info);
		blackboard : blackboard_module;
		other_info : other_info_module;
	INVAR
		blackboard.variable_exists[blackboard.a] = init_a_SET_a.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.a] = init_a_SET_a.a;
	INVAR
		init_a.status = init_a_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.b] = init_b_SET_b.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.b] = init_b_SET_b.b;
	INVAR
		init_b.status = init_b_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.r] = r_minus_q_SET_r.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.r] = r_minus_q_SET_r.r;
	INVAR
		r_minus_q.status = r_minus_q_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.temp] = store_r_SET_temp.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.temp] = store_r_SET_temp.temp;
	INVAR
		store_r.status = store_r_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.r] = update_r_SET_r.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.r] = update_r_SET_r.r;
	INVAR
		update_r.status = update_r_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.q] = update_q_SET_q.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.q] = update_q_SET_q.q;
	INVAR
		update_q.status = update_q_SET_status.status;
	ASSIGN
		init(active_node) := -1;
		init(previous_status) := invalid;
		next(active_node) :=
			case
				(-2 = active_node) : -2;
				(-1 = active_node) : 0;
				!(next_status = invalid) : parents[active_node];
				(0> max_children[active_node]) : -2;
				(children_start_index[active_node] + 0> max_active_node) : -2;
				(statuses[children_start_index[active_node] + 0] = invalid) : children_start_index[active_node] + 0;
				(1> max_children[active_node]) : -2;
				(children_start_index[active_node] + 1> max_active_node) : -2;
				(statuses[children_start_index[active_node] + 1] = invalid) : children_start_index[active_node] + 1;
				(2> max_children[active_node]) : -2;
				(children_start_index[active_node] + 2> max_active_node) : -2;
				(statuses[children_start_index[active_node] + 2] = invalid) : children_start_index[active_node] + 2;
				TRUE : -2;
			esac;
		next(previous_status) :=
			case
				(active_node < 0) : invalid;
				(active_node = 0) : next(statuses[0]);
				(active_node = 1) : next(statuses[1]);
				(active_node = 2) : next(statuses[2]);
				(active_node = 3) : next(statuses[3]);
				(active_node = 4) : next(statuses[4]);
				(active_node = 5) : next(statuses[5]);
				(active_node = 6) : next(statuses[6]);
				(active_node = 7) : next(statuses[7]);
				(active_node = 8) : next(statuses[8]);
				(active_node = 9) : next(statuses[9]);
				(active_node = 10) : next(statuses[10]);
				(active_node = 11) : next(statuses[11]);
				(active_node = 12) : next(statuses[12]);
				(active_node = 13) : next(statuses[13]);
				(active_node = 14) : next(statuses[14]);
				TRUE : statuses[active_node];
			esac;
		next(blackboard.variable[0]) := 
			case
				(active_node in {5}) : 0..4;
				TRUE : blackboard.variable[0];
			esac;
		next(blackboard.variable_exists[0]) := 
			case
				(active_node in {5}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[0];
			esac;
		next(blackboard.variable[1]) := 
			case
				(active_node in {7}) : 0..4;
				TRUE : blackboard.variable[1];
			esac;
		next(blackboard.variable_exists[1]) := 
			case
				(active_node in {7}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[1];
			esac;
		next(blackboard.variable[2]) := 
			case
				(active_node in {11, 13}) : 0..4;
				TRUE : blackboard.variable[2];
			esac;
		next(blackboard.variable_exists[2]) := 
			case
				(active_node in {11, 13}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[2];
			esac;
		next(blackboard.variable[3]) := 
			case
				(active_node in {12}) : 0..4;
				TRUE : blackboard.variable[3];
			esac;
		next(blackboard.variable_exists[3]) := 
			case
				(active_node in {12}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[3];
			esac;
		next(blackboard.variable[4]) := 
			case
				(active_node in {14}) : 0..4;
				TRUE : blackboard.variable[4];
			esac;
		next(blackboard.variable_exists[4]) := 
			case
				(active_node in {14}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[4];
			esac;
LTLSPEC F(G(blackboard.variable[blackboard.q] = 0));

--LTLSPEC F(G((blackboard.variable[blackboard.a] mod blackboard.variable[blackboard.r] = 0) & (blackboard.variable[blackboard.b] mod blackboard.variable[blackboard.r] = 0)));



MODULE node_sequence(statuses, active_node, id, prev_status, last_child)
	VAR
		status : {success, failure, running, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				(active_node = id) & !(status = invalid) : status;
				(id = active_node) & (prev_status = invalid) : invalid;
				(id = active_node) & (prev_status = running) : running;
				(id = active_node) & (prev_status = failure) : failure;
				(id = active_node) & (statuses[last_child] = success) : success;
				(id = active_node) : invalid;
				TRUE : status;
			esac;
MODULE node_selector(statuses, active_node, id, prev_status, last_child)
	VAR
		status : {success, failure, running, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				(active_node = id) & !(status = invalid) : status;
				(id = active_node) & (prev_status = invalid) : invalid;
				(id = active_node) & (prev_status = running) : running;
				(id = active_node) & (prev_status = success) : success;
				(id = active_node) & (statuses[last_child] = failure) : failure;
				(id = active_node) : invalid;
				TRUE : status;
			esac;
MODULE node_check_blackboard_variable_exists(statuses, active_node, id, blackboard, variable)
	VAR
		status : {success, failure, running, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				(active_node = id) & !(status = invalid) : status;
				(id = active_node) & (blackboard.variable_exists[variable]) : success;
				(id = active_node) & !(blackboard.variable_exists[variable]) : failure;
				TRUE : status;
			esac;
MODULE node_set_blackboard_variables(statuses, active_node, id)
	VAR
		status : {success, failure, running, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				(active_node = id) & !(status = invalid) : status;
				(id = active_node) : {failure, running, success};
				TRUE : status;
			esac;
MODULE node_check_blackboard_variable_value(statuses, active_node, id, blackboard, variable, check)
	VAR
		status : {success, failure, running, invalid};
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				(active_node = id) & !(status = invalid) : status;
				(id = active_node) & !(blackboard.variable_exists[variable]) : failure;
				(id = active_node) & (blackboard.variable_exists[variable]) & (check.result) : success;
				(id = active_node) & (blackboard.variable_exists[variable]) & !(check.result) : failure;
				TRUE : status;
			esac;
MODULE blackboard_module
	DEFINE
		a := 0;
		b := 1;
		r := 2;
		temp := 3;
		q := 4;
	VAR
		variable : array 0..4 of 0..4;
		variable_exists : array 0..4 of boolean;
	ASSIGN
		init(variable_exists[0]) := FALSE;
		init(variable_exists[1]) := FALSE;
		init(variable_exists[2]) := FALSE;
		init(variable_exists[3]) := FALSE;
		init(variable_exists[4]) := FALSE;

--a : 0
----init_a
--b : 1
----init_b
--r : 2
----r_minus_q
----update_r
--temp : 3
----store_r
--q : 4
----update_q
MODULE other_info_module
	DEFINE
		bruh := 0;

MODULE init_a_SET_a_module(active_node, node_id, blackboard, other_info)
	VAR
		a : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(a) :=
			case
				(active_node = node_id) : a;
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE :  {FALSE, TRUE};
			esac;
MODULE init_a_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE init_b_SET_b_module(active_node, node_id, blackboard, other_info)
	VAR
		b : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(b) :=
			case
				(active_node = node_id) : b;
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE :  {FALSE, TRUE};
			esac;
MODULE init_b_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE check_r_gt_q_CHECK_r_module(active_node, node_id, blackboard, other_info)
	VAR
		result : boolean;
	INVAR
		result = ((blackboard.variable[blackboard.r] >= blackboard.variable[blackboard.q]) & (blackboard.variable_exists[blackboard.r]) & (blackboard.variable_exists[blackboard.q]));

MODULE r_minus_q_SET_r_module(active_node, node_id, blackboard, other_info)
	VAR
		r : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(r) :=
			case
				(active_node = node_id) : max(0, r - blackboard.variable[blackboard.q]);
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
			
MODULE r_minus_q_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE store_r_SET_temp_module(active_node, node_id, blackboard, other_info)
	VAR
		temp : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(temp) :=
			case
				(active_node = node_id) : blackboard.variable[blackboard.r];
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
			
MODULE store_r_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE update_r_SET_r_module(active_node, node_id, blackboard, other_info)
	VAR
		r : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(r) :=
			case
				(active_node = node_id) & !(blackboard_var_exists) : max(blackboard.variable[blackboard.a], blackboard.variable[blackboard.b]);
				(active_node = node_id) : blackboard.variable[blackboard.q];
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
			
MODULE update_r_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE update_q_SET_q_module(active_node, node_id, blackboard, other_info)
	VAR
		q : 0..4;
		blackboard_var_exists : boolean;
	ASSIGN
		next(q) :=
			case
				(active_node = node_id) & !(blackboard_var_exists) : min(blackboard.variable[blackboard.a], blackboard.variable[blackboard.b]);
				(active_node = node_id) : blackboard.variable[blackboard.r];
				TRUE : 0..4;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
			
MODULE update_q_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;
