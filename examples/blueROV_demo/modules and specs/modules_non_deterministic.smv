MODULE am_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		am_warning : 0..1;
		am_warning_exists : boolean;
	ASSIGN
		init(am_warning) := 0;
		init(am_warning_exists) := FALSE;
		next(am_warning) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : am_warning;
			esac;
		next(am_warning_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : am_warning_exists;
			esac;
MODULE battery_level_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		battery_level : 0..1;
		battery_level_exists : boolean;
	ASSIGN
		--init(battery_level) := {2, 3, 4, 5};
		init(battery_level) := 1;
		init(battery_level_exists) := FALSE;
		next(battery_level) :=
			case
				(active_node in nodes_with_access) : max(0, battery_level - 1);
				TRUE : battery_level;
			esac;
		next(battery_level_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : battery_level_exists;
			esac;
MODULE battery_low_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		battery_low_warning : 0..1;
		battery_low_warning_exists : boolean;
	ASSIGN
		init(battery_low_warning) := 0;
		init(battery_low_warning_exists) := FALSE;
		next(battery_low_warning) :=
			case
				(active_node in nodes_with_access) & (next(variables[variable_names.battery_level]) > 0) : 0;
				(active_node in nodes_with_access) : 1;
				TRUE : battery_low_warning;
			esac;
		next(battery_low_warning_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : battery_low_warning_exists;
			esac;

MODULE HSD_out_dot_heading_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		HSD_out_dot_heading : 0..1;
		HSD_out_dot_heading_exists : boolean;
	ASSIGN
		init(HSD_out_dot_heading) := 0;
		init(HSD_out_dot_heading_exists) := FALSE;
		next(HSD_out_dot_heading) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : HSD_out_dot_heading;
			esac;
		next(HSD_out_dot_heading_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : HSD_out_dot_heading_exists;
			esac;


MODULE HSD_out_dot_speed_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		HSD_out_dot_speed : 0..1;
		HSD_out_dot_speed_exists : boolean;
	ASSIGN
		init(HSD_out_dot_speed) := 0;
		init(HSD_out_dot_speed_exists) := FALSE;
		next(HSD_out_dot_speed) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : HSD_out_dot_speed;
			esac;
		next(HSD_out_dot_speed_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : HSD_out_dot_speed_exists;
			esac;


MODULE HSD_out_dot_depth_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		HSD_out_dot_depth : 0..1;
		HSD_out_dot_depth_exists : boolean;
	ASSIGN
		init(HSD_out_dot_depth) := 0;
		init(HSD_out_dot_depth_exists) := FALSE;
		next(HSD_out_dot_depth) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : HSD_out_dot_depth;
			esac;
		next(HSD_out_dot_depth_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : HSD_out_dot_depth_exists;
			esac;

MODULE p_mission_len_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		p_mission_len : 0..1;
		p_mission_len_exists : boolean;
	ASSIGN
		init(p_mission_len) := 0;
		init(p_mission_len_exists) := FALSE;
		next(p_mission_len) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : p_mission_len;
			esac;
		next(p_mission_len_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : p_mission_len_exists;
			esac;


MODULE waypoints_completed_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names)
	VAR
		waypoints_completed : 0..1;
		waypoints_completed_exists : boolean;
	ASSIGN
		init(waypoints_completed) := 0;
		init(waypoints_completed_exists) := FALSE;
		next(waypoints_completed) :=
			case
				active_node in nodes_with_access : {0, 1};
				TRUE : waypoints_completed;
			esac;
		next(waypoints_completed_exists) :=
			case
				active_node in nodes_with_access : TRUE;
				TRUE : waypoints_completed_exists;
			esac;


MODULE battery_low_fs_CHECK_battery_low_warning_module(active_node, id, blackboard, variable_names)
	DEFINE
		result := ((blackboard.variables[variable_names.battery_low_warning]) = 0);


MODULE check_am_CHECK_am_warning_module(active_node, id, blackboard, variable_names)
	DEFINE
		result := ((blackboard.variables[variable_names.am_warning]) = 0);
		

MODULE am_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;


MODULE battery_management_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;

MODULE surface_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;

MODULE loiter_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;

MODULE waypoint_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;

MODULE speed_max_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;

MODULE speed_min_task_SET_status_module(active_node, id, blackboard, node_names, variable_names)
	DEFINE
		status :=
			case
				(active_node = id) : {success, running, failure};
				TRUE : invalid;
			esac;