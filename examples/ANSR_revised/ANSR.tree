configuration {
}
enumerations {
}

constants {
    path_max := 20, x_max := 399, y_max := 399, z_max := 25
}

variables {
    variable { bl drone_x VAR [0, x_max] assign{result{0}}}
    variable { bl drone_y VAR [0, y_max] assign{result{0}}}
    variable { bl drone_z VAR [0, z_max] assign{result{0}}}
    variable { bl previous_x VAR [0, x_max] assign{result{0}}}
    variable { bl previous_y VAR [0, y_max] assign{result{0}}}
    variable { bl previous_z VAR [0, z_max] assign{result{0}}}
    variable { bl drone_x_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl drone_y_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl destination_x VAR [0, x_max] assign{result{0}}}
    variable { bl destination_y VAR [0, y_max] assign{result{0}}}
    variable { bl destination_z VAR [0, z_max] assign{result{0}}}
    variable { bl next_x VAR [0, x_max] assign{result{0}}}
    variable { bl next_y VAR [0, y_max] assign{result{0}}}
    variable { bl next_z VAR [0, z_max] assign{result{0}}}
    variable { bl next_x_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl next_y_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { local success_read VAR BOOLEAN assign{result{False}}}
    variable { env fake VAR INT [0, 1] assign{result{0}}}
}

environment_update {
}

checks {
    check {
	not_at_destination
	arguments{}
	read_variables {drone_x, drone_y, drone_z, destination_x, destination_y, destination_z}
	condition {
	    (and,
		(eq, drone_x, destination_x),
		(eq, drone_y, destination_y),
		(eq, drone_z, destination_z)
	    )
	}
    }
}

environment_checks {
}

actions {
    action {
	read_position
	arguments{}
	local_variables{success_read}
	read_variables{}
	write_variables{previous_x, previous_y, previous_z, drone_x, drone_y, drone_z, drone_x_delta, drone_y_delta}
	initial_values{}
	update{
	    variable_statement {
		previous_x
		assign{result{drone_x}}
	    }
	    variable_statement {
		previous_y
		assign{result{drone_y}}
	    }
	    variable_statement {
		previous_z
		assign{result{drone_z}}
	    }
	    read_environment {
		read_position_function
		condition {success_read}
		variable_statement{
		    drone_x
		    assign{result{drone_x, (max, 0, (sub, drone_x, 1)), (min, x_max, (add, drone_x, 1))}}
		}
		variable_statement{
		    drone_y
		    assign{result{drone_y, (max, 0, (sub, drone_y, 1)), (min, y_max, (add, drone_y, 1))}}
		}
		variable_statement{
		    drone_z
		    assign{result{drone_z, (max, 0, (sub, drone_z, 1)), (min, z_max, (add, drone_z, 1))}}
		}
		variable_statement{
		    drone_x_delta
		    assign{
			case{
			    (or,
				(neq, drone_x, previous_x),
				(neq, drone_y, previous_y),
				(neq, drone_z, previous_z)
			    )
			}
			result{(min, 1, (max, -1, (sub, drone_x, previous_x)))}
			result{drone_x_delta}
		    }
		}
		variable_statement{
		    drone_y_delta
		    assign{
			case{
			    (or,
				(neq, drone_x, previous_x),
				(neq, drone_y, previous_y),
				(neq, drone_z, previous_z)
			    )
			}
			result{(min, 1, (max, -1, (sub, drone_y, previous_y)))}
			result{drone_y_delta}
		    }
		}
				
	    }
	    return_statement{
		case{success_read}result{success}result{running}
	    }
	}
    }
    action {
	read_destination
	arguments{}
	local_variables{success_read}
	read_variables{}
	write_variables{destination_x, destination_y, destination_z}
	initial_values{}
	update{
	    read_environment {
		read_destination_function
		condition {success_read}
		variable_statement{
		    destination_x
		    assign{result{destination_x, (max, 0, (sub, destination_x, 1)), (min, x_max, (add, destination_x, 1))}}
		}
		variable_statement{
		    destination_y
		    assign{result{destination_y, (max, 0, (sub, destination_y, 1)), (min, y_max, (add, destination_y, 1))}}
		}
		variable_statement{
		    destination_z
		    assign{result{destination_z, (max, 0, (sub, destination_z, 1)), (min, z_max, (add, destination_z, 1))}}
		}
	    }
	    return_statement{
		case{success_read}result{success}result{running}
	    }
	}
    }
    action {
	compute_next
	arguments{}
	local_variables{}
	read_variables{drone_x, drone_y, drone_z, drone_x_delta, drone_y_delta}
	write_variables{next_x, next_y, next_z}
	initial_values{}
	update{
	    read_environment{
		compute_path_function
		variable_statement {
		    next_x
		    assign{result{0}}
		}
		variable_statement {
		    next_y
		    assign{result{0}}
		}
		variable_statement {
		    next_z
		    assign{result{0}}
		}
	    }
	    return_statement{result{success}}
	}
    }
    action {
	send_next
	local_variables{}
	read_variables{next_x, next_y, next_z}
	write_variables{}
	initial_values{}
	update{
	    write_environment{
		send_path_function
		variable_statement{
		    fake
		    assign{result{0}}
		}
	    }
	    return_statement{result{success}}
	}
    }
}
sub_trees {
}

tree {
    composite{ drone_control sequence children{
	    read_position {}
	    composite{ at_destination_selector selector children{
		    not_at_destination {}
		    read_destination {} #{This needs to not return success if it fails}#
		}
	    }
	    compute_next {}
	    sent_next {}
	}
    }
}

tick_prerequisite {
    True
}

specifications {
}