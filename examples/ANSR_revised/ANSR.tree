configuration {
}
enumerations {
}

constants {
    path_max := 20, x_max := 399, y_max := 399, z_max := 25
}

variables {
    variable { bl map_exists VAR BOOLEAN assign{result{False}}}
    variable { bl drone_x VAR [0, x_max] assign{result{0}}}
    variable { bl drone_y VAR [0, y_max] assign{result{0}}}
    variable { bl drone_z VAR [0, z_max] assign{result{0}}}
    variable { bl previous_x VAR [0, x_max] assign{result{0}}}
    variable { bl previous_y VAR [0, y_max] assign{result{0}}}
    variable { bl previous_z VAR [0, z_max] assign{result{0}}}
    variable { bl drone_x_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl drone_y_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl destination_x VAR [0, x_max] assign{result{0}}}
    variable { bl destination_y VAR [0, y_max] assign{result{0}}}
    variable { bl destination_z VAR [0, z_max] assign{result{0}}}
    variable { bl valid_destination VAR BOOLEAN assign{result{False}}}
    variable { bl next_x VAR [0, x_max] assign{result{0}}}
    variable { bl next_y VAR [0, y_max] assign{result{0}}}
    variable { bl next_z VAR [0, z_max] assign{result{0}}}
    variable { bl next_x_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { bl next_y_delta VAR {-1, 0, 1} assign{result{0}}}
    variable { local success_read VAR BOOLEAN assign{result{False}}}
    variable { env fake VAR [0, 1] assign{result{0}}}
}

environment_update {
}

checks {
    check {
	not_at_destination
	arguments{}
	read_variables {drone_x, drone_y, drone_z, destination_x, destination_y, destination_z}
	condition {
	    (and,
		(eq, drone_x, destination_x),
		(eq, drone_y, destination_y),
		(eq, drone_z, destination_z)
	    )
	}
    }
    check {
	valid_destination_check
	arguments {}
	read_variables{valid_destination}
	condition{valid_destination}
    }
}

environment_checks {
}

actions {
    action {
	read_position
	arguments{}
	local_variables{success_read}
	read_variables{}
	write_variables{previous_x, previous_y, previous_z, drone_x, drone_y, drone_z, drone_x_delta, drone_y_delta}
	initial_values{}
	update{
	    variable_statement {
		previous_x
		assign{result{drone_x}}
	    }
	    variable_statement {
		previous_y
		assign{result{drone_y}}
	    }
	    variable_statement {
		previous_z
		assign{result{drone_z}}
	    }
	    read_environment {
		read_position_function
		condition_variable {success_read}
		condition {True}
		variable_statement{
		    drone_x
		    assign{result{drone_x, (max, 0, (sub, drone_x, 1)), (min, x_max, (add, drone_x, 1))}}
		}
		variable_statement{
		    drone_y
		    assign{result{drone_y, (max, 0, (sub, drone_y, 1)), (min, y_max, (add, drone_y, 1))}}
		}
		variable_statement{
		    drone_z
		    assign{result{drone_z, (max, 0, (sub, drone_z, 1)), (min, z_max, (add, drone_z, 1))}}
		}
		variable_statement{
		    drone_x_delta
		    assign{
			case{
			    (or,
				(neq, drone_x, previous_x),
				(neq, drone_y, previous_y),
				(neq, drone_z, previous_z)
			    )
			}
			result{(min, 1, (max, -1, (sub, drone_x, previous_x)))}
			result{drone_x_delta}
		    }
		}
		variable_statement{
		    drone_y_delta
		    assign{
			case{
			    (or,
				(neq, drone_x, previous_x),
				(neq, drone_y, previous_y),
				(neq, drone_z, previous_z)
			    )
			}
			result{(min, 1, (max, -1, (sub, drone_y, previous_y)))}
			result{drone_y_delta}
		    }
		}
				
	    }
	    return_statement{result{success}}
	}
    }
    action {
	read_destination
	arguments{}
	local_variables{success_read}
	read_variables{}
	write_variables{destination_x, destination_y, destination_z}
	initial_values{}
	update{
	    read_environment {
		read_destination_function
		condition_variable {success_read}
		condition{True}
		variable_statement{
		    destination_x
		    assign{result{destination_x, (max, 0, (sub, destination_x, 1)), (min, x_max, (add, destination_x, 1))}}
		}
		variable_statement{
		    destination_y
		    assign{result{destination_y, (max, 0, (sub, destination_y, 1)), (min, y_max, (add, destination_y, 1))}}
		}
		variable_statement{
		    destination_z
		    assign{result{destination_z, (max, 0, (sub, destination_z, 1)), (min, z_max, (add, destination_z, 1))}}
		}
	    }
	    return_statement{
		case{success_read}result{success}result{running}
	    }
	}
    }
    action {
	request_new_destination
	arguments{}
	local_variables{}
	read_variables{}
	write_variables{}
	initial_values{}
	update{
	    write_environment {
		request_new_destination_function
		variable_statement {
		    fake
		    assign{result{0}}
		}
	    }
	    return_statement{
		result{failure}
	    }
	}
    }
    action {
	read_map
	arguments{}
	local_variables{success_read}
	read_variables{}
	write_variables{map_exists}
	initial_values{}
	update{
	    read_environment {
		read_map_function
		condition {True}
		variable_statement{
		    map_exists
		    assign{result{True}}
		}
	    }
	    return_statement{
		case{map_exists}result{success}result{failure}
	    }
	}
    }
    action {
	compute_next
	arguments{}
	local_variables{}
	read_variables{drone_x, drone_y, drone_z, drone_x_delta, drone_y_delta}
	write_variables{next_x, next_y, next_z, valid_destination}
	initial_values{}
	update{
	    read_environment{
		compute_path_function
		condition_variable {valid_destination}
		condition {True}
		variable_statement {
		    next_x
		    assign{result{0}}
		}
		variable_statement {
		    next_y
		    assign{result{0}}
		}
		variable_statement {
		    next_z
		    assign{result{0}}
		}
	    }
	    return_statement{case{valid_destination}result{success}result{failure}}
	}
    }
    action {
	send_next
	arguments{}
	local_variables{}
	read_variables{next_x, next_y, next_z}
	write_variables{}
	initial_values{}
	update{
	    write_environment{
		send_path_function
		variable_statement{
		    fake
		    assign{result{0}}
		}
	    }
	    return_statement{result{success}}
	}
    }
}
sub_trees {
}

tree {
    composite{ drone_control sequence children{
	    #{}#read_map {} #{success if map exists, failure otherwise}#
	    #{}#read_position {} #{success, always}#
	    composite{ destination_selector selector children{
		    #{decide if we need a new destination. our current destination is fine if it both 1. is not where we are, and 2. is reachable}#
		    composite{ current_destination sequence children {
			    #{}#not_at_destination {}
			    #{}#valid_destination_check {}
			}
		    }
		    #{}#read_destination {} #{success if destination received, running otherwise. validity checked below}#
		}
	    }
	    composite{ plot_course selector children{
		    compute_next {} #{success if course plotted, failure otherwise}#
		    #{}#request_new_destination {} #{returns failure, always}#
		}
	    }   
	    #{}#send_next {}
	}
    }
}

tick_prerequisite {
    True
}

specifications {
}