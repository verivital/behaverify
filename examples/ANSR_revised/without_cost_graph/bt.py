#!/usr/bin/env python3
'''
Serena's edits for BT. Uses code generated by BehaVerify.
'''
import os # added to prevent adk from doing something weird on takeoff
import math # for flooring points
from collections import namedtuple # for faking points
import random # for faking points
import sys
import numpy as np
import py_trees
import py_trees_ros.trees
import py_trees.console as console
import rclpy


import ebt.bt.ANSR as ANSR
import ebt.bt.ANSR_environment as ANSR_environment
# import ebt.bt.serene_randomizer as serene_randomizer_module

import geometry_msgs.msg
import adk_node.msg
import std_msgs.msg
from visualization_msgs.msg import Marker, MarkerArray
import nav_msgs.msg
from rclpy.parameter import Parameter
import vanderbilt_interfaces.msg
from vanderbilt_utils.interface_definitions import message_settings
from rclpy.qos import QoSProfile, QoSDurabilityPolicy
from vanderbilt_interfaces.msg import ObstacleMap

FAKE_POINT = namedtuple('fake_point', ['x', 'y', 'z'])

class BT(rclpy.node.Node):
    def __init__(self):
        print(os.popen("ros2 service call /airsim_node/SimpleFlight/takeoff airsim_interfaces/srv/Takeoff wait_on_last_task:\ false").read())
        super().__init__('BT_node',
                         allow_undeclared_parameters=True,
                         automatically_declare_parameters_from_overrides=True)
        self.messages = message_settings.Messages()

        self.declare_parameter('default_snapshot_stream', 'false')
        self.robot_radius = self.get_parameter_or(
            'robot_radius', Parameter('robot_radius', Parameter.Type.DOUBLE, 0.01))
        self.get_logger().info("Robot radius is %s" % self.robot_radius.value)
        self.robot_radius = self.robot_radius.value

        self.desired_altitude = self.get_parameter_or(
            'desired_altitude', Parameter('desired_altitude', Parameter.Type.DOUBLE, 5.0))
        self.get_logger().info("Desired altitude is %s" % self.desired_altitude.value)
        # Add 1.0 to altitude to increase height for planner use
        self.desired_altitude = self.desired_altitude.value

        self.area_search_flag = self.get_parameter_or(
            'area_search_flag', Parameter('area_search_flag', Parameter.Type.BOOL, False))
        self.get_logger().info("Area Search is %s" % self.area_search_flag.value)
        self.area_search_flag = self.area_search_flag.value

        self.area_search_altitude = self.get_parameter_or(
            'area_search_altitude', Parameter('area_search_altitude', Parameter.Type.DOUBLE, 25.0))
        self.get_logger().info("Area Search altitude is %s" % self.area_search_altitude.value)
        self.area_search_altitude = self.area_search_altitude.value

        self.alt_tol = self.get_parameter_or(
            'alt_tol', Parameter('alt_tol', Parameter.Type.DOUBLE, 1.0))
        self.get_logger().info("Altitude tolerance is %s" % self.alt_tol.value)
        self.alt_tol = self.alt_tol.value

        self.scale = self.get_parameter_or(
            'scale', Parameter('scale', Parameter.Type.DOUBLE, 0.1))
        self.get_logger().info("Scale is %s" % self.scale.value)
        self.scale = self.scale.value

        self.obstacle_radius = self.get_parameter_or(
            'obstacle_radius', Parameter('obstacle_radius', Parameter.Type.DOUBLE, 0.01))
        self.get_logger().info("Obstacle radius is %s" % self.obstacle_radius.value)
        self.obstacle_radius = self.obstacle_radius.value * self.scale

        self.obstacle_offset = self.get_parameter_or(
            'obstacle_offset', Parameter('obstacle_offset', Parameter.Type.INTEGER, 3))
        self.get_logger().info("Obstacle offset is %s" % self.obstacle_offset.value)
        self.obstacle_offset = self.obstacle_offset.value

        self.debug = self.get_parameter_or(
            'debug', Parameter('debug', Parameter.Type.BOOL, False))
        self.debug = self.debug.value
        self.get_logger().info("Debugging is %s" % self.debug)

        self.publish_waypoints = self.get_parameter_or(
            'publish_waypoints', Parameter('publish_waypoints', Parameter.Type.BOOL, True))
        self.publish_waypoints = self.publish_waypoints.value
        self.get_logger().info("publish_waypoints is %s" % self.publish_waypoints)

        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        self.get_logger().info('---------------------------------------------------------------------------------------#################################################################################################################################################################-------------------------------')
        # note! I made a change at the top of this method also!!!
        # with open('/output/serene.log', 'w', encoding = 'utf-8') as serene_log:
        #     serene_log.write('starting!\n')
        # with open('/output/serene_parse.log', 'w', encoding = 'utf-8') as serene_log:
        #     serene_log.write('\n')

        safety_radius = 2 #if obstacle is within this distance using max metric on x, y, then count as obstacle.
        safety_altitude = 2 #must be at least this distance above an obstacle to not be an obstacle
        flight_heights = [5, 12, 25] #heights we can plan at
        velocity = 10.0 #drone speed
        altitude_safety_margin = .5 #how far above the specified point we actually request to fly.

        def function_cost(point1, point2):
            return (1.5 if point1[0] != point2[0] and point1[1] != point2[1] else 1.0) * point2[2]

        # bt uses ENU with (0, 0) as bottom left
        # planner uses ENU with (0, 0) as center
        # odometry uses NED with (0, 0) as center
        # obstacle map uses NEU with (0, 0) as bottom left

        def function_convert_planner_to_bt(map_info, point):
            return (
                round(point.x - map_info['origin_position'][0]),
                round(point.y - map_info['origin_position'][1]),
                round(point.z)
            )

        def function_convert_odometry_to_bt(map_info, point):
            # NOT FINISHED
            return (
                math.floor(point.y - map_info['origin_position'][1]),
                math.floor(point.x - map_info['origin_position'][0]),
                math.floor(-1 * point.z)
            )

        def function_convert_bt_to_a_star(map_info, point):
            z = flight_heights[0]
            for height in reversed(flight_heights):
                if point[2] >= height:
                    z = height
                    break
            return (
                point[0],
                point[1],
                z
            )

        def function_convert_bt_to_waypoint(map_info, point, height_modifier):
            return (
                float(point[1] + map_info['origin_position'][1] + .5),
                float(point[0] + map_info['origin_position'][0] + .5),
                float(-1 * (point[2] + height_modifier))
            )

        def function_near_goal(drone, goal):
            return (
                drone[2] >= goal[2] and
                abs(drone[0] - goal[0]) <= 1 and
                abs(drone[1] - goal[1]) <= 1
            )

        def function_near_path_segment_end(drone, end_point):
            return (
                abs(drone[0] - end_point[0]) <= safety_radius and
                abs(drone[1] - end_point[1]) <= safety_radius
            )

        def function_near_path_point(drone, point):
            return (
                abs(drone[0] - point[0]) <= safety_radius and
                abs(drone[1] - point[1]) <= safety_radius
            )

        def function_obstacle_at_point(map_info, obstacle_map, point):
            if point[0] < 0 or point[0] > map_info['x_size'] or point[1] < 0 or point[1] > map_info['y_size']:
                return True
            for x in range(max(0, point[0] - safety_radius), min(map_info['x_size'], point[0] + safety_radius)):
                for y in range(max(0, point[1] - safety_radius), min(map_info['y_size'], point[1] + safety_radius)):
                    if obstacle_map[x][y] + safety_altitude >= point[2]:
                        return True
            return False

        def function_reformat_obstacle_map(map_info, obstacle_map):
            return np.transpose(np.reshape(obstacle_map, (map_info['y_size'], map_info['x_size'])), (1, 0))

        real_goals = False

        goals_generator = None

        if not real_goals:
            def generate_goals():
                new_goals = [
                    FAKE_POINT(random.randint(-100, 100), random.randint(-100, 100), random.choice(flight_heights))
                    for _ in range(random.randint(1, 10))
                ]
                return (-1, new_goals)
            goals_generator = {
                'chance' : .99,
                'function' : generate_goals
            }

        with open('/output/serene.log', 'w', encoding = 'utf-8') as serene_log:
            serene_log.write('starting!\n')
            blackboard_reader = ANSR.create_blackboard()
            serene_log.write('blackboard reader created\n')
            environment = ANSR_environment.ANSR_environment()
            serene_log.write('environment created\n')
            ANSR.initialize_blackboard(blackboard_reader, flight_heights)
            serene_log.write('blackboard initialized\n')
            environment.initialize_environment(altitude_safety_margin, velocity, goals_generator = goals_generator)
            serene_log.write('environment initialized\n')
            root = ANSR.create_tree(
                environment,
                function_convert_bt_to_a_star,
                function_convert_bt_to_waypoint,
                function_convert_planner_to_bt,
                function_convert_odometry_to_bt,
                function_cost,
                function_near_goal,
                function_near_path_point,
                function_near_path_segment_end,
                function_obstacle_at_point,
                function_reformat_obstacle_map
            )
            serene_log.write('root created.\nDone with serene startup code!\n')

        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')
        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')
        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')
        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')
        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')
        self.get_logger().info(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#################################################################################################################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;')

        tree = py_trees_ros.trees.BehaviourTree(
            root=root,
            unicode_tree_debug=self.debug
        )

        with open('/output/serene.log', 'a', encoding = 'utf-8') as serene_log:
            serene_log.write('tree created\n')
        try:
            tree.setup(timeout=15.0)
        except py_trees_ros.exceptions.TimedOutError as e:
            console.logerror(console.red + "failed to setup the tree, aborting [{}]".format(str(e)) + console.reset)
            tree.shutdown()
            rclpy.shutdown()
            sys.exit(1)
        except KeyboardInterrupt:
            # not a warning, nor error, usually a user-initiated shutdown
            console.logerror("tree setup interrupted")
            tree.shutdown()
            rclpy.shutdown()
            sys.exit(1)

        with open('/output/serene.log', 'a', encoding = 'utf-8') as serene_log:
            serene_log.write('tree initialized\n')
            environment.setup_pub_sub(tree.node, sub_goal = real_goals)
            serene_log.write('environment pub-sub created\n')
            serene_log.write('starting ticks!\n')

        tree.tick_tock(period_ms=100.0)

        try:
            rclpy.spin(tree.node)
        except KeyboardInterrupt:
            pass

        tree.shutdown()
        rclpy.shutdown()

    # def _create_topicsbb(self):
    #     """
    #     Create a parallel behaviour that will be responsible for
    #     populating the blackboard with data from ROS topics.

    #     Returns:
    #         the parallel behaviour
    #     """
    #     topics2bb = py_trees.composites.Parallel(
    #         name="Topics2BB",
    #         policy=py_trees.common.ParallelPolicy.SuccessOnOne()
    #     )
    #     world2bb = ebt.bt.bb_subscriber.ToBlackboard(
    #         name="World2BB",
    #         topic_name=self.messages.obstacle_map_raw.topic,
    #         qos_profile=self.messages.obstacle_map_raw.qos_profile,
    #         blackboard_variables={"obstacle_map": None},
    #         topic_type=self.messages.obstacle_map_raw.msg_type
    #     )
    #     gtperception2bb = ebt.bt.bb_subscriber.ToBlackboard(
    #         name="GTPerception2BB",
    #         topic_name="/adk_node/ground_truth/perception",
    #         qos_profile=QoSProfile(
    #             reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE,
    #             durability=rclpy.qos.QoSDurabilityPolicy.VOLATILE,
    #             history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    #             depth=1),
    #         blackboard_variables={"gt_perception": None},
    #         topic_type=adk_node.msg.TargetPerception
    #     )
    #     odom2bb = ebt.bt.bb_subscriber.ToBlackboard(
    #         name="Odom2BB",
    #         topic_name="/adk_node/SimpleFlight/odom_local_ned",
    #         qos_profile=QoSProfile(
    #             reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE,
    #             durability=rclpy.qos.QoSDurabilityPolicy.VOLATILE,
    #             history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    #             depth=1),
    #         blackboard_variables={"odometry": None},
    #         topic_type=nav_msgs.msg.Odometry
    #     )
    #     goal2bb = ebt.bt.bb_subscriber.ToBlackboard(
    #         name="goal2BB",
    #         topic_name=self.messages.goal.topic,
    #         qos_profile=self.messages.goal.qos_profile,
    #         blackboard_variables={"goal": None},
    #         topic_type=self.messages.goal.msg_type
    #     )
    #     mission2bb = ebt.bt.bb_subscriber.ToBlackboard(
    #         name="mission2BB",
    #         topic_name=self.messages.mission_spec.topic,
    #         qos_profile=self.messages.mission_spec.qos_profile,
    #         blackboard_variables={"mission": None},
    #         topic_type=self.messages.mission_spec.msg_type
    #     )

    #     gtperception_sequence = self._create_gtperception_sequence(gtperception2bb)
    #     world_sequence = self._create_world_sequence(world2bb)

    #     topics2bb.add_children([
    #         goal2bb,
    #         odom2bb,
    #         mission2bb,
    #         gtperception_sequence,
    #         world_sequence
    #     ])

    #     return topics2bb

    # def _create_gtperception_sequence(self, bb_subscriber):
    #     goal_sequence = py_trees.composites.Sequence(name="GTPerception", memory=False)
    #     wait_for_perception = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForGTPerception",
    #         variable_name="gt_perception"
    #     )
    #     task_process_perception = ebt.bt.task_process_perception.TaskHandler(
    #         name="ProcessGTPerceptionMsg",
    #         perception_key="gt_perception",
    #         target_key="target_found",
    #         mission_key="mission"
    #     )

    #     publish_target_found = py_trees_ros.publishers.FromBlackboard(
    #         name="task_publish_target_found",
    #         topic_name="/adk_node/vanderbilt/ebt/target_found",
    #         topic_type=std_msgs.msg.String,
    #         qos_profile=self.messages.obstacle_map_raw.qos_profile,
    #         blackboard_variable="target_found"
    #     )

    #     goal_sequence.add_children([
    #         bb_subscriber,
    #         wait_for_perception,
    #         task_process_perception,
    #         publish_target_found])
    #     return goal_sequence

    # def _create_world_sequence(self, bb_subscriber):
    #     # ToDo:
    #     # Maybe there is a better BT structure for this...
    #     goal_sequence = py_trees.composites.Sequence(name="UpdateGoal", memory=False)
    #     wait_for_obstaclemap_data = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForObstacleMap_0)",
    #         variable_name="obstacle_map.data"
    #     )
    #     task_transform_obstacles = ebt.bt.task_transform_obstacles.TaskHandler(
    #         name="TransformObstacles",
    #         obstacle_radius=self.obstacle_radius,
    #         desired_altitude=self.desired_altitude,
    #         scale=self.scale,
    #         alt_tol=self.alt_tol
    #     )

    #     #Todo: message definition in utils!
    #     publish_slice_rviz = py_trees_ros.publishers.FromBlackboard(
    #         name="task_publish_slice_rviz",
    #         topic_name="/adk_node/vanderbilt/ebt/slice",
    #         topic_type=nav_msgs.msg.OccupancyGrid,
    #         qos_profile=self.messages.obstacle_map_raw.qos_profile,
    #         blackboard_variable="slice_rviz"
    #     )

    #     goal_sequence.add_children([
    #         bb_subscriber,
    #         wait_for_obstaclemap_data,
    #         task_transform_obstacles,
    #         publish_slice_rviz])
    #     return goal_sequence

    # def _create_update_landmark_sequence(self):
    #     """
    #     Create a sequence behaviour that will be responsible for
    #     updating the current landmark.

    #     Returns:
    #         the sequence behaviour
    #     """
    #     update_landmark_sequence = py_trees.composites.Sequence(name="UpdateLandmarkSequence", memory=False)
    #     condition_close_to_landmark = ebt.bt.condition_close_to_landmark.TaskHandler(
    #         name="CloseToLandmark",
    #     )
    #     task_update_landmark = ebt.bt.task_update_landmark.TaskHandler(
    #         name="UpdateLandmark",
    #     )

    #     update_landmark_sequence.add_children([
    #         condition_close_to_landmark,
    #         task_update_landmark
    #     ])

    #     return update_landmark_sequence

    # def _create_update_move_action_sequence(self):
    #     """
    #     Create a sequence behaviour that will be responsible for
    #     updating the movement of the drone.

    #     Returns:
    #         the sequence behaviour
    #     """
    #     update_move_action_sequence = py_trees.composites.Sequence(name="UpdateMoveActionSequence", memory=False)
    #     task_update_subgoal = ebt.bt.task_update_subgoal.TaskHandler(
    #         name="UpdateSubgoal",
    #         robot_radius=self.robot_radius,
    #         scale=self.scale
    #     )

    #     task_calculate_path = ebt.bt.task_calculate_path.TaskHandler(
    #         name="CalculatePath",
    #         desired_altitude=self.desired_altitude,
    #         qos_profile=py_trees_ros.utilities.qos_profile_unlatched()
    #     )

    #     update_move_action_sequence.add_children([
    #         task_update_subgoal,
    #         task_calculate_path
    #     ])

    #     return update_move_action_sequence

    # def _create_update_control_selector(self):
    #     """
    #     Create a selector behaviour that will be responsible for
    #     updating the control sequence.

    #     Returns:
    #         the selector behaviour
    #     """
    #     update_control_selector = py_trees.composites.Selector(name="UpdateControlSelector", memory=False)

    #     update_landmark_sequence = self._create_update_landmark_sequence()

    #     update_move_action_sequence = self._create_update_move_action_sequence()

    #     update_control_selector.add_children([
    #         update_landmark_sequence,
    #         update_move_action_sequence
    #     ])

    #     return update_control_selector

    # def _create_area_search_sequence(self):
    #     full_seq = py_trees.composites.Sequence(name="FullSeq", memory=False)
    #     alt_change_up_seq = py_trees.composites.Sequence(name="AltChangeUpSeq", memory=False)
    #     alt_change_down_seq = py_trees.composites.Sequence(name="AltChangeDownSeq", memory=False)
    #     task_area_search = ebt.bt.task_area_search.TaskHandler(
    #         name="AreaSearch",
    #         altitude=self.area_search_altitude)

    #     task_alt_change_up = ebt.bt.task_alt_change.TaskHandler(
    #         name="AltChange_up",
    #         altitude=self.area_search_altitude
    #     )

    #     task_alt_change_down = ebt.bt.task_alt_change.TaskHandler(
    #         name="AltChange_down",
    #         altitude=self.desired_altitude
    #     )

    #     wait_for_area_search = ebt.bt.wait_for_area_search.TaskHandler(
    #         name="WaitForAreaSearch"
    #     )


    #     wait_for_alt_change_up = ebt.bt.wait_for_alt_change.TaskHandler(
    #         name="WaitForAltChange_up",
    #         altitude=self.area_search_altitude
    #     )

    #     wait_for_alt_change_down = ebt.bt.wait_for_alt_change.TaskHandler(
    #         name="WaitForAltChange_down",
    #         altitude=self.desired_altitude
    #     )

    #     alt_change_up_seq.add_children([
    #         task_alt_change_up,
    #         wait_for_alt_change_up
    #     ])
    #     alt_change_up_onehot = py_trees.decorators.OneShot(name="AltChangeUpOneShot", child=alt_change_up_seq,
    #                                                        policy=py_trees.common.OneShotPolicy.ON_SUCCESSFUL_COMPLETION)

    #     alt_change_down_seq.add_children([
    #         task_alt_change_down,
    #         wait_for_alt_change_down
    #     ])
    #     alt_change_down_onehot = py_trees.decorators.OneShot(name="AltChangeDownOneShot", child=alt_change_down_seq,
    #                                                           policy=py_trees.common.OneShotPolicy.ON_SUCCESSFUL_COMPLETION)

    #     area_search_onehot = py_trees.decorators.OneShot(name="AreaSearchOneShot", child=task_area_search,
    #                                                         policy=py_trees.common.OneShotPolicy.ON_SUCCESSFUL_COMPLETION)

    #     full_seq.add_children([
    #         alt_change_up_onehot,
    #         area_search_onehot,
    #         alt_change_down_onehot
    #     ])

    #     return full_seq


    # def _create_control_sequence(self):
    #     """
    #     Create a sequence behaviour that will be responsible for
    #     controlling the robot.

    #     Returns:
    #         the sequence behaviour
    #     """
    #     control_sequence = py_trees.composites.Sequence(name="ControlSequence", memory=False)

    #     area_search_sequence = py_trees.decorators.OneShot(name="area_search_oneshot",
    #                                                        child=self._create_area_search_sequence(),
    #                                                        policy=py_trees.common.OneShotPolicy.ON_SUCCESSFUL_COMPLETION)

    #     task_setup_landmark_trigger = ebt.bt.task_setup_ld_trigger.TaskHandler(
    #         name="SetupLandmarkTrigger"
    #     )
    #     task_setup_landmark_path = ebt.bt.task_setup_landmark_path.TaskHandler(
    #         name="SetupLandmarkPath",
    #         blackboard_variable="landmark_path",
    #         desired_altitude=self.desired_altitude,
    #         alt_tol=self.alt_tol,
    #         obstacle_offset=self.obstacle_offset,
    #         robot_radius=self.robot_radius,
    #         arrive_radius=5.0,
    #     )


    #     path_setup_sel = py_trees.composites.Selector(name="PathSetupSel", memory=False)
    #     path_setup_sel.add_children([
    #         task_setup_landmark_trigger,
    #         task_setup_landmark_path
    #     ])

    #     wait_for_obstaclemap_data = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForObstacleMap_1",
    #         variable_name="obstacle_map.data"
    #     )

    #     wait_for_init_goal = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForInitGoal",
    #         variable_name="goal.pose.position.x"
    #     )
    #     greater_than_zero = lambda x, y: len(x) > len(y)
    #     is_path_ready = py_trees.behaviours.CheckBlackboardVariableValue(
    #         name="IsPathReady",
    #         check=py_trees.common.ComparisonExpression(
    #             variable="landmark_path",
    #             value=[],
    #             operator=greater_than_zero
    #         )
    #     )

    #     update_control_selector = self._create_update_control_selector()

    #     if self.area_search_flag:
    #         control_sequence.add_children([
    #             wait_for_obstaclemap_data,
    #             area_search_sequence,
    #             wait_for_init_goal,
    #             path_setup_sel,
    #             is_path_ready,
    #             update_control_selector,
    #         ])
    #     else:
    #         control_sequence.add_children([
    #             wait_for_obstaclemap_data,
    #             wait_for_init_goal,
    #             path_setup_sel,
    #             is_path_ready,
    #             update_control_selector,
    #         ])
    #     return control_sequence

    # def _create_goal_event_publishing_sequence(self):
    #     goal_event_sequence = py_trees.composites.Sequence(name="GoalEventSequence", memory=False)
    #     wait_for_goal_event = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForGoalEvent",
    #         variable_name="goal_event"
    #     )
    #     publish_ebt_goal_event = py_trees_ros.publishers.FromBlackboard(
    #         name="task_publish_goal_event",
    #         topic_name="/adk_node/vanderbilt/goal_event",
    #         topic_type=std_msgs.msg.String,
    #         qos_profile=self.messages.invalid_goal.qos_profile,
    #         blackboard_variable="goal_event"
    #     )
    #     goal_event_sequence.add_children([
    #         wait_for_goal_event,
    #         publish_ebt_goal_event
    #     ])
    #     return goal_event_sequence

    # def _create_publishing_sequence(self):
    #     publishing_sequence = py_trees.composites.Sequence(name="PublishingSequence", memory=False)

    #     wait_for_waypoint_data = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForWPData",
    #         variable_name="waypoint_path"
    #     )
    #     wait_for_subgoal_data = py_trees.behaviours.WaitForBlackboardVariable(
    #         name="WaitForSGData",
    #         variable_name="subgoal_vis_data"
    #     )

    #     if self.publish_waypoints:
    #         publish_waypointlist = py_trees_ros.publishers.FromBlackboard(
    #             name="task_publish_waypointlist",
    #             topic_name="/adk_node/input/waypoints",
    #             topic_type=adk_node.msg.WaypointPath,
    #             qos_profile=QoSProfile(
    #                 reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE,
    #                 durability=rclpy.qos.QoSDurabilityPolicy.TRANSIENT_LOCAL,
    #                 history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    #                 depth=1),
    #             blackboard_variable="waypoint_path"
    #         )
    #     else:
    #         publish_waypointlist = py_trees.behaviours.Success(name="PublisherPlaceholder")

    #     publish_subggoal_vis_data = py_trees_ros.publishers.FromBlackboard(
    #         name="task_publish_subgoal_vis_data",
    #         topic_name="/adk_node/vanderbilt/ebt/subgoal_vis_data",
    #         topic_type=MarkerArray,
    #         qos_profile=QoSProfile(
    #             reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE,
    #             durability=rclpy.qos.QoSDurabilityPolicy.TRANSIENT_LOCAL,
    #             history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,
    #             depth=1),
    #         blackboard_variable="subgoal_vis_data"
    #     )
    #     publishing_sequence.add_children([
    #         wait_for_waypoint_data,
    #         publish_waypointlist,
    #         wait_for_subgoal_data,
    #         publish_subggoal_vis_data
    #     ])
    #     return publishing_sequence


    # def _create_tasks(self):
    #     """
    #     Create a parallel behaviour that will be responsible for
    #     executing the tasks.

    #     Returns:
    #         the parallel behaviour
    #     """
    #     # map_oneshot = self._create_map_sequence()
    #     control_sequence = self._create_control_sequence()

    #     tasks = py_trees.composites.Parallel(
    #         name="Tasks",
    #         policy=py_trees.common.ParallelPolicy.SuccessOnSelected(
    #             children=[control_sequence],
    #             synchronise=False
    #         )
    #     )
    #     plotter = ebt.bt.task_plotter.TaskHandler(
    #         name="PlotterNode",
    #         odom_blackboard_variable="odometry"
    #     )

    #     goal_update_sequence = self._create_goal_event_publishing_sequence()

    #     publishing = self._create_publishing_sequence()
    #     tasks.add_children([
    #         # map_oneshot,
    #         control_sequence,
    #         plotter,
    #         goal_update_sequence,
    #         publishing
    #     ])

    #     return tasks

    # def create_root(self):
    #     """
    #     Create a basic tree and start a 'Topics2BB' work sequence that
    #     will become responsible for data gathering behaviours.

    #     Returns:
    #         the root of the tree
    #     """
    #     root = py_trees.composites.Parallel(
    #         name="Airsim_BT",
    #         policy=py_trees.common.ParallelPolicy.SuccessOnOne()
    #     )

    #     init_goal_event = py_trees.decorators.OneShot(name="InitGoalEventOneShot",
    #                                                   child=ebt.bt.task_init_goal_event.TaskHandler(name="InitGoalEvent"),
    #                                                   policy=py_trees.common.OneShotPolicy.ON_SUCCESSFUL_COMPLETION)
    #     topics2bb = self._create_topicsbb()
    #     tasks = self._create_tasks()
    #     root.add_children([
    #         init_goal_event,
    #         topics2bb,
    #         tasks
    #     ])

    #     return root

def main(args=None):
    print('Starting BT_Node')
    rclpy.init(args=args)
    node = BT()

    try:
        rclpy.spin(node)
    except (KeyboardInterrupt, rclpy.executors.ExternalShutdownException):
        pass

    print('Stopping BT_Node')
    node.destroy_node()
    rclpy.try_shutdown()


if __name__ == '__main__':
    main()
