MODULE main
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		resume_from_here_in_subtree__BlueROV := -3;
		resume_from_here_in_subtree__topics2bb := -3;
		resume_from_here_in_subtree__battery2bb := -3;
		resume_from_here_in_subtree__rth2bb := -3;
		resume_from_here_in_subtree__geofence2bb := -3;
		resume_from_here_in_subtree__lec2_am_r_2bb := -3;
		resume_from_here_in_subtree__lec2_am_l_2bb := -3;
		resume_from_here_in_subtree__pipe_lost2bb := -3;
		resume_from_here_in_subtree__sensor_failure2bb := -3;
		resume_from_here_in_subtree__waypoints_completed2bb := -3;
		resume_from_here_in_subtree__ddlec2bb := -3;
		resume_from_here_in_subtree__fls2bb := -3;
		resume_from_here_in_subtree__fls_warning2bb := -3;
		resume_from_here_in_subtree__rtreach2bb := -3;
		resume_from_here_in_subtree__rtreach_unsafe_value2bb := -3;
		resume_from_here_in_subtree__rtreach_index2bb := -3;
		resume_from_here_in_subtree__dd_tasks := -3;
		resume_from_here_in_subtree__mission_server := -3;
		resume_from_here_in_subtree__obstacle_avoidance := -3;
		resume_from_here_in_subtree__rth_task := -3;
		resume_from_here_in_subtree__home2bb := -3;
		resume_from_here_in_subtree__rth_task_1 := -3;
		resume_from_here_in_subtree__home2bb_1 := -3;
		resume_from_here_in_subtree__tracking_task := -3;
		resume_from_here_in_subtree__lec2am_speed_cmd := -3;
		resume_from_here_in_subtree__lec2am_mapping_cmd := -3;
		trace_running_source_surface_task_2 := (surface_task_2.status = running) ? node_names.surface_task_2 : -2;
		trace_running_source_emergency_stop_tasks := 
			case
				!(trace_running_source_surface_task_2 = -2) : trace_running_source_surface_task_2;
				TRUE : -2;
			esac;
		trace_running_source_emergency_stop_check_1 := 
			case
				!(trace_running_source_emergency_stop_tasks = -2) : trace_running_source_emergency_stop_tasks;
				TRUE : -2;
			esac;
		trace_running_source_emergency_stop_check := 
			case
				!(trace_running_source_emergency_stop_check_1 = -2) : trace_running_source_emergency_stop_check_1;
				TRUE : -2;
			esac;
		trace_running_source_tracking := (tracking.status = running) ? node_names.tracking : -2;
		trace_running_source_track_pipe_mission := 
			case
				!(trace_running_source_tracking = -2) : trace_running_source_tracking;
				TRUE : -2;
			esac;
		trace_running_source_loiter_task_1 := (loiter_task_1.status = running) ? node_names.loiter_task_1 : -2;
		trace_running_source_waypoint_end := 
			case
				!(trace_running_source_loiter_task_1 = -2) : trace_running_source_loiter_task_1;
				TRUE : -2;
			esac;
		trace_running_source_waypoints_sif_1 := 
			case
				!(trace_running_source_waypoint_end = -2) : trace_running_source_waypoint_end;
				TRUE : -2;
			esac;
		trace_running_source_waypoints_sif := 
			case
				!(trace_running_source_waypoints_sif_1 = -2) : trace_running_source_waypoints_sif_1;
				TRUE : -2;
			esac;
		trace_running_source_waypoint_selector := 
			case
				!(trace_running_source_waypoints_sif = -2) : trace_running_source_waypoints_sif;
				(waypoint_selector.status = running) : node_names.waypoint_selector;
				TRUE : -2;
			esac;
		trace_running_source_waypoint_mission := 
			case
				!(trace_running_source_waypoint_selector = -2) : trace_running_source_waypoint_selector;
				TRUE : -2;
			esac;
		trace_running_source_priorities := 
			case
				!(trace_running_source_emergency_stop_check = -2) : trace_running_source_emergency_stop_check;
				!(trace_running_source_track_pipe_mission = -2) : trace_running_source_track_pipe_mission;
				!(trace_running_source_waypoint_mission = -2) : trace_running_source_waypoint_mission;
				TRUE : -2;
			esac;
		child_index_to_resume_from__emergency_stop_tasks := 
			case
				(resume_from_here_in_subtree__priorities in {38}) : 1;
				TRUE : -2;
			esac;
		child_index_to_resume_from__track_pipe_mission := 
			case
				(resume_from_here_in_subtree__priorities in {65}) : 1;
				TRUE : -2;
			esac;
		child_index_to_resume_from__waypoint_end := 
			case
				(resume_from_here_in_subtree__priorities in {95}) : 1;
				TRUE : -2;
			esac;
		child_index_to_resume_from__waypoint_mission := 
			case
				(resume_from_here_in_subtree__priorities in {89, 95}) : 1;
				TRUE : -2;
			esac;
		BlueROV.active := !(var_BLUEROV_SURFACED);
		--START OF BLACKBOARD DEFINITIONS
		var_BLUEROV_SURFACED_stage_1 := 
			case
				!(surface_task.active) : var_BLUEROV_SURFACED;
				TRUE : TRUE;
			esac;
		var_BLUEROV_SURFACED_stage_2 := 
			case
				!(surface_task_1.active) : var_BLUEROV_SURFACED_stage_1;
				TRUE : TRUE;
			esac;
		var_BLUEROV_SURFACED_stage_3 := 
			case
				!(surface_task_2.active) : var_BLUEROV_SURFACED_stage_2;
				TRUE : TRUE;
			esac;
		var_BLUEROV_SURFACED_stage_4 := 
			case
				!(surface_task_3.active) : var_BLUEROV_SURFACED_stage_3;
				TRUE : TRUE;
			esac;
		var_BLUEROV_SURFACED_stage_5 := 
			case
				!(surface_task_4.active) : var_BLUEROV_SURFACED_stage_4;
				TRUE : TRUE;
			esac;
		var_HSD_out_stage_1 := 
			case
				!(speed_min_task.active) : var_HSD_out;
				TRUE : uuv_min_speed;
			esac;
		var_HSD_out_stage_2 := 
			case
				!(speed_min_task_1.active) : var_HSD_out_stage_1;
				TRUE : uuv_min_speed;
			esac;
		var_HSD_out_stage_3 := 
			case
				!(speed_max_task.active) : var_HSD_out_stage_2;
				TRUE : uuv_max_speed;
			esac;
		var_battery := var_battery_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_battery := var_battery_stage_1;
		var_battery_low_warning_stage_1 := 
			case
				!(battery2bb.active) : var_battery_low_warning;
				TRUE : var_battery_stage_1 <= 0;
			esac;
		var_bb_fls_warning_stage_1 := 
			case
				!(fls_warning2bb.active) : var_bb_fls_warning;
				TRUE : var_bb_fls_warning | var_obstacle_in_view_stage_1;
			esac;
		var_bb_geofence := var_bb_geofence_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_geofence := var_bb_geofence_stage_1;
		var_bb_geofence_warning_stage_1 := 
			case
				!(geofence2bb.active) : var_bb_geofence_warning;
				TRUE : var_bb_geofence_warning | var_bb_geofence_stage_1;
			esac;
		var_bb_home_dist := var_bb_home_dist_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_home_dist := var_bb_home_dist_stage_2;
		var_bb_home_reached_stage_1 := 
			case
				!(home2bb.active) : var_bb_home_reached;
				TRUE : var_bb_home_reached | var_bb_home_dist_stage_1 < 15;
			esac;
		var_bb_home_reached_stage_2 := 
			case
				!(home2bb_1.active) : var_bb_home_reached_stage_1;
				TRUE : var_bb_home_reached_stage_1 | var_bb_home_dist_stage_2 < 15;
			esac;
		var_bb_obstacle_warning := var_bb_obstacle_warning_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_obstacle_warning := var_bb_obstacle_warning_stage_1;
		var_bb_pipe_lost_warning_stage_1 := 
			case
				!(pipe_lost2bb.active) : var_bb_pipe_lost_warning;
				TRUE : var_bb_pipelost_stage_1 & var_bb_mission = pipe_following;
			esac;
		var_bb_pipelost := var_bb_pipelost_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_pipelost := var_bb_pipelost_stage_1;
		var_bb_rth := var_bb_rth_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_rth := var_bb_rth_stage_1;
		var_bb_rth_warning_stage_1 := 
			case
				!(rth2bb.active) : var_bb_rth_warning;
				TRUE : var_bb_rth_warning | var_bb_rth_stage_1;
			esac;
		var_bb_rth_warning_stage_2 := 
			case
				!(mission_server.active) : var_bb_rth_warning_stage_1;
				var_next_mission : var_finished_missions_stage_1;
				TRUE : var_bb_rth_warning_stage_1;
			esac;
		var_bb_sensor_failure := var_bb_sensor_failure_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_sensor_failure := var_bb_sensor_failure_stage_1;
		var_bb_sensor_failure_warning_stage_1 := 
			case
				!(sensor_failure2bb.active) : var_bb_sensor_failure_warning;
				TRUE : var_bb_sensor_failure_warning | var_bb_sensor_failure_stage_1;
			esac;
		var_bb_waypoints_completed := var_bb_waypoints_completed_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_bb_waypoints_completed := var_bb_waypoints_completed_stage_1;
		var_cm_hsd_input_stage_1 := 
			case
				!(obstacle_avoidance.active) : var_cm_hsd_input;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : var_cm_hsd_input;
			esac;
		var_cm_hsd_input_stage_2 := 
			case
				!(surface_task.active) : var_cm_hsd_input_stage_1;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_surface_task;
			esac;
		var_cm_hsd_input_stage_3 := 
			case
				!(surface_task_1.active) : var_cm_hsd_input_stage_2;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_surface_task;
			esac;
		var_cm_hsd_input_stage_4 := 
			case
				!(surface_task_2.active) : var_cm_hsd_input_stage_3;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_surface_task;
			esac;
		var_cm_hsd_input_stage_5 := 
			case
				!(surface_task_3.active) : var_cm_hsd_input_stage_4;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_surface_task;
			esac;
		var_cm_hsd_input_stage_6 := 
			case
				!(surface_task_4.active) : var_cm_hsd_input_stage_5;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_surface_task;
			esac;
		var_cm_hsd_input_stage_7 := 
			case
				!(rth_task.active) : var_cm_hsd_input_stage_6;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_rth_task;
			esac;
		var_cm_hsd_input_stage_8 := 
			case
				!(rth_task_1.active) : var_cm_hsd_input_stage_7;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_rth_task;
			esac;
		var_cm_hsd_input_stage_9 := 
			case
				!(loiter_task.active) : var_cm_hsd_input_stage_8;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_loiter_task;
			esac;
		var_cm_hsd_input_stage_10 := 
			case
				!(tracking_task.active) : var_cm_hsd_input_stage_9;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_tracking_task;
			esac;
		var_cm_hsd_input_stage_11 := 
			case
				!(loiter_task_1.active) : var_cm_hsd_input_stage_10;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_loiter_task;
			esac;
		var_cm_hsd_input_stage_12 := 
			case
				!(waypoint_task.active) : var_cm_hsd_input_stage_11;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_waypoint_task;
			esac;
		var_cm_hsd_input_stage_13 := 
			case
				!(loiter_task_2.active) : var_cm_hsd_input_stage_12;
				var_bb_obstacle_warning_stage_1 : cm_obstacle_avoidance_task;
				TRUE : cm_loiter_task;
			esac;
		var_dd_output := var_dd_output_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_dd_output := var_dd_output_stage_1;
		var_dd_xy_axis_degradation_stage_1 := 
			case
				!(ddlec2bb.active) : var_dd_xy_axis_degradation;
				TRUE : var_dd_output_stage_1 = xy_warn | var_dd_xy_axis_degradation & !(var_dd_output_stage_1 = safe);
			esac;
		var_dd_z_axis_warning_stage_1 := 
			case
				!(ddlec2bb.active) : var_dd_z_axis_warning;
				TRUE : var_dd_output_stage_1 = z_warn | var_dd_z_axis_warning & !(var_dd_output_stage_1 = safe);
			esac;
		var_emergency_stop_warning_stage_1 := 
			case
				!(fls_warning2bb.active) : var_emergency_stop_warning;
				TRUE : var_emergency_stop_warning | var_obstacle_in_view_stage_1;
			esac;
		var_emergency_stop_warning_stage_2 := 
			case
				!(mission_server.active) : var_emergency_stop_warning_stage_1;
				var_next_mission & !(var_finished_missions_stage_1) & e_stop = var_bb_mission_stage_1 : TRUE;
				TRUE : var_emergency_stop_warning_stage_1;
			esac;
		var_finished_missions := var_finished_missions_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_finished_missions := var_finished_missions_stage_1;
		var_fls_range := var_fls_range_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_fls_range := var_fls_range_stage_1;
		var_lec2_am_l := var_lec2_am_l_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_lec2_am_l := var_lec2_am_l_stage_1;
		var_lec2_am_l_pipe_warning_stage_1 := 
			case
				!(lec2_am_l_2bb.active) : var_lec2_am_l_pipe_warning;
				TRUE : var_lec2_am_l_stage_1 = pipe | var_lec2_am_l_stage_1 = speed_pipe;
			esac;
		var_lec2_am_l_speed_warning_stage_1 := 
			case
				!(lec2_am_l_2bb.active) : var_lec2_am_l_speed_warning;
				TRUE : var_lec2_am_l_stage_1 = speed | var_lec2_am_l_stage_1 = speed_pipe;
			esac;
		var_lec2_am_r := var_lec2_am_r_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_lec2_am_r := var_lec2_am_r_stage_1;
		var_lec2_am_r_pipe_warning_stage_1 := 
			case
				!(lec2_am_r_2bb.active) : var_lec2_am_r_pipe_warning;
				TRUE : var_lec2_am_r_stage_1 = pipe | var_lec2_am_r_stage_1 = speed_pipe;
			esac;
		var_lec2_am_r_speed_warning_stage_1 := 
			case
				!(lec2_am_r_2bb.active) : var_lec2_am_r_speed_warning;
				TRUE : var_lec2_am_r_stage_1 = speed | var_lec2_am_r_stage_1 = speed_pipe;
			esac;
		var_next_mission_stage_1 := 
			case
				!(mission_server.active) : var_next_mission;
				TRUE : FALSE;
			esac;
		var_next_mission_stage_2 := 
			case
				!(next_mission.active) : var_next_mission_stage_1;
				TRUE : TRUE;
			esac;
		var_obstacle_in_view := var_obstacle_in_view_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_obstacle_in_view := var_obstacle_in_view_stage_1;
		var_obstacle_standoff_warning_stage_1 := 
			case
				!(fls2bb.active) : var_obstacle_standoff_warning;
				TRUE : var_fls_range_stage_1 = danger_zone;
			esac;
		var_pipe_mapping_enable_stage_1 := 
			case
				!(pipe_mapping_disable_task.active) : var_pipe_mapping_enable;
				TRUE : FALSE;
			esac;
		var_pipe_mapping_enable_stage_2 := 
			case
				!(pipe_mapping_disable_task_1.active) : var_pipe_mapping_enable_stage_1;
				TRUE : FALSE;
			esac;
		var_pipe_mapping_enable_stage_3 := 
			case
				!(pipe_mapping_enable_task.active) : var_pipe_mapping_enable_stage_2;
				TRUE : TRUE;
			esac;
		var_rtreach_long_term_warning_stage_1 := 
			case
				!(rtreach2bb.active) : var_rtreach_long_term_warning;
				TRUE : var_rtreach_result_stage_1 = long | var_rtreach_result_stage_1 = short_long;
			esac;
		var_rtreach_result := var_rtreach_result_stage_1;
		LINK_TO_PREVIOUS_FINAL_var_rtreach_result := var_rtreach_result_stage_1;
		var_rtreach_warning_stage_1 := 
			case
				!(rtreach2bb.active) : var_rtreach_warning;
				TRUE : var_rtreach_result_stage_1 = short | var_rtreach_result_stage_1 = short_long;
			esac;
		--END OF BLACKBOARD DEFINITIONS
	VAR
		node_names : define_nodes;
		resume_from_here_in_subtree__priorities : {24, 38, 65, 89, 95};
		BlueROV : composite_parallel_success_on_all_without_memory_5(topics2bb, dd_tasks, mission_server, obstacle_avoidance, priorities);
		battery2bb : battery2bb_module(battery2bb_update_success);
		battery_check : decorator_X_is_Y(battery_check_1, success, failure);
		battery_check_1 : composite_selector_without_memory_2(battery_low_fs, surface_task);
		battery_low_fs : battery_low_fs_module(var_battery_low_warning_stage_1);
		check_geofence : check_geofence_module(var_bb_geofence_warning_stage_1);
		check_lec2am_lp : check_lec2am_lp_module(var_lec2_am_l_pipe_warning_stage_1);
		check_lec2am_ls : check_lec2am_ls_module(var_lec2_am_l_speed_warning_stage_1);
		check_lec2am_rp : check_lec2am_rp_module(var_lec2_am_r_pipe_warning_stage_1);
		check_lec2am_rs : check_lec2am_rs_module(var_lec2_am_r_speed_warning_stage_1);
		check_pipe_post : check_pipe_post_module(var_bb_pipe_lost_warning_stage_1);
		check_rth : check_rth_module(var_bb_rth_warning_stage_2);
		check_sensor_failure : check_sensor_failure_module(var_bb_sensor_failure_warning_stage_1);
		check_surface : check_surface_module(var_bb_home_reached);
		check_waypoints_completed : check_waypoints_completed_module(var_bb_waypoints_completed_stage_1);
		dd_lec_task : running_DEFAULT_module();
		dd_tasks : composite_selector_without_memory_2(reallocate_check, dd_lec_task);
		ddlec2bb : ddlec2bb_module(ddlec2bb_update_success);
		emergency_stop_check : decorator_X_is_Y(emergency_stop_check_1, success, failure);
		emergency_stop_check_1 : composite_selector_without_memory_2(emergency_stop_fs, emergency_stop_tasks);
		emergency_stop_fs : emergency_stop_fs_module(var_emergency_stop_warning_stage_2);
		emergency_stop_task : success_DEFAULT_module();
		emergency_stop_tasks : composite_sequence_with_memory_2(emergency_stop_task, surface_task_2, child_index_to_resume_from__emergency_stop_tasks);
		fls2bb : fls2bb_module(fls2bb_update_success);
		fls_warning2bb : fls_warning2bb_module(fls_warning2bb_update_success);
		geofence2bb : geofence2bb_module(geofence2bb_update_success);
		geofence_selector : decorator_X_is_Y(geofence_selector_1, success, failure);
		geofence_selector_1 : composite_selector_without_memory_2(check_geofence, rth_par_1);
		home2bb : home2bb_module(home2bb_update_success);
		home2bb_1 : home2bb_1_module(home2bb_1_update_success);
		home_reached_selector : decorator_X_is_Y(home_reached_selector_1, success, failure);
		home_reached_selector_1 : composite_selector_without_memory_2(check_surface, surface_task_3);
		is_reallocation_requested : is_reallocation_requested_module(var_dd_xy_axis_degradation_stage_1);
		is_track_pipe_mission_requested : is_track_pipe_mission_requested_module(var_bb_mission_stage_1);
		is_waypoint_requested : is_waypoint_requested_module(var_bb_mission_stage_1);
		lec2_am_l_2bb : lec2_am_l_2bb_module(lec2_am_l_2bb_update_success);
		lec2_am_r_2bb : lec2_am_r_2bb_module(lec2_am_r_2bb_update_success);
		lec2am_l_mapping_check : decorator_X_is_Y(lec2am_l_mapping_check_1, success, failure);
		lec2am_l_mapping_check_1 : composite_selector_without_memory_2(check_lec2am_lp, pipe_mapping_disable_task);
		lec2am_l_speed_check : decorator_X_is_Y(lec2am_l_speed_check_1, success, failure);
		lec2am_l_speed_check_1 : composite_selector_without_memory_2(check_lec2am_ls, speed_min_task);
		lec2am_mapping_cmd : composite_selector_without_memory_3(lec2am_l_mapping_check, lec2am_r_mapping_check, pipe_mapping_enable_task);
		lec2am_r_mapping_check : decorator_X_is_Y(lec2am_r_mapping_check_1, success, failure);
		lec2am_r_mapping_check_1 : composite_selector_without_memory_2(check_lec2am_rp, pipe_mapping_disable_task_1);
		lec2am_r_speed_check : decorator_X_is_Y(lec2am_r_speed_check_1, success, failure);
		lec2am_r_speed_check_1 : composite_selector_without_memory_2(check_lec2am_rs, speed_min_task_1);
		lec2am_speed_cmd : composite_selector_without_memory_3(lec2am_l_speed_check, lec2am_r_speed_check, speed_max_task);
		loiter_task : running_DEFAULT_module();
		loiter_task_1 : running_DEFAULT_module();
		loiter_task_2 : running_DEFAULT_module();
		mission_server : running_DEFAULT_module();
		next_mission : success_DEFAULT_module();
		obstacle_avoidance : running_DEFAULT_module();
		obstacle_standoff_check : decorator_X_is_Y(obstacle_standoff_check_1, success, failure);
		obstacle_standoff_check_1 : composite_selector_without_memory_2(obstacle_standoff_fs, surface_task_4);
		obstacle_standoff_fs : obstacle_standoff_fs_module(var_obstacle_standoff_warning_stage_1);
		pipe_lost2bb : pipe_lost2bb_module(pipe_lost2bb_update_success);
		pipe_lost_selector : decorator_X_is_Y(pipe_lost_selector_1, success, failure);
		pipe_lost_selector_1 : composite_selector_without_memory_2(check_pipe_post, loiter_task);
		pipe_mapping_disable_task : running_DEFAULT_module();
		pipe_mapping_disable_task_1 : running_DEFAULT_module();
		pipe_mapping_enable_task : success_DEFAULT_module();
		priorities : composite_selector_without_memory_11(battery_check, sensor_failure_selector, emergency_stop_check, home_reached_selector, obstacle_standoff_check, rth_selector, geofence_selector, pipe_lost_selector, track_pipe_mission, waypoint_mission, loiter_task_2);
		reallocate_check : decorator_X_is_Y(reallocate_check_1, success, failure);
		reallocate_check_1 : composite_selector_without_memory_2(is_reallocation_requested, reallocate_task);
		reallocate_task : running_DEFAULT_module();
		rth2bb : rth2bb_module(rth2bb_update_success);
		rth_par : composite_parallel_success_on_all_without_memory_2(rth_task, home2bb);
		rth_par_1 : composite_parallel_success_on_all_without_memory_2(rth_task_1, home2bb_1);
		rth_selector : decorator_X_is_Y(rth_selector_1, success, failure);
		rth_selector_1 : composite_selector_without_memory_2(check_rth, rth_par);
		rth_task : running_DEFAULT_module();
		rth_task_1 : running_DEFAULT_module();
		rtreach2bb : rtreach2bb_module(rtreach2bb_update_success);
		rtreach_index2bb : rtreach_index2bb_module(rtreach_index2bb_update_success);
		rtreach_unsafe_value2bb : rtreach_unsafe_value2bb_module(rtreach_unsafe_value2bb_update_success);
		sensor_failure2bb : sensor_failure2bb_module(sensor_failure2bb_update_success);
		sensor_failure_selector : decorator_X_is_Y(sensor_failure_selector_1, success, failure);
		sensor_failure_selector_1 : composite_selector_without_memory_2(check_sensor_failure, surface_task_1);
		speed_max_task : running_DEFAULT_module();
		speed_min_task : running_DEFAULT_module();
		speed_min_task_1 : running_DEFAULT_module();
		surface_task : running_DEFAULT_module();
		surface_task_1 : running_DEFAULT_module();
		surface_task_2 : running_DEFAULT_module();
		surface_task_3 : running_DEFAULT_module();
		surface_task_4 : running_DEFAULT_module();
		topics2bb : composite_parallel_success_on_all_without_memory_14(battery2bb, rth2bb, geofence2bb, lec2_am_r_2bb, lec2_am_l_2bb, pipe_lost2bb, sensor_failure2bb, waypoints_completed2bb, ddlec2bb, fls2bb, fls_warning2bb, rtreach2bb, rtreach_unsafe_value2bb, rtreach_index2bb);
		track_pipe_mission : composite_sequence_with_memory_2(is_track_pipe_mission_requested, tracking, child_index_to_resume_from__track_pipe_mission);
		tracking : composite_parallel_success_on_all_without_memory_3(tracking_task, lec2am_speed_cmd, lec2am_mapping_cmd);
		tracking_task : running_DEFAULT_module();
		waypoint_end : composite_sequence_with_memory_2(next_mission, loiter_task_1, child_index_to_resume_from__waypoint_end);
		waypoint_mission : composite_sequence_with_memory_2(is_waypoint_requested, waypoint_selector, child_index_to_resume_from__waypoint_mission);
		waypoint_selector : composite_selector_without_memory_2(waypoints_sif, waypoint_task);
		waypoint_task : running_DEFAULT_module();
		waypoints_completed2bb : waypoints_completed2bb_module(waypoints_completed2bb_update_success);
		waypoints_sif : decorator_X_is_Y(waypoints_sif_1, success, failure);
		waypoints_sif_1 : composite_selector_without_memory_2(check_waypoints_completed, waypoint_end);
		--START OF BLACKBOARD VARIABLES DECLARATION
		var_BLUEROV_SURFACED : boolean;
		var_HSD_out : {uuv_min_speed, uuv_max_speed};
		var_battery_stage_1 : 0..1;
		battery2bb_update_success : boolean;
		var_battery_low_warning : boolean;
		var_bb_fls_warning : boolean;
		var_bb_geofence_stage_1 : boolean;
		var_bb_geofence_warning : boolean;
		var_bb_home_dist_stage_1 : {10, 100};
		var_bb_home_dist_stage_2 : {10, 100};
		var_bb_home_reached : boolean;
		var_bb_mission : {waypoint_following, e_stop, pipe_following};
		var_bb_mission_stage_1 : {waypoint_following, e_stop, pipe_following};
		var_bb_obstacle_warning_stage_1 : boolean;
		var_bb_pipe_lost_warning : boolean;
		var_bb_pipe_mapping_enable : boolean;
		var_bb_pipelost_stage_1 : boolean;
		var_bb_rth_stage_1 : boolean;
		var_bb_rth_warning : boolean;
		var_bb_sensor_failure_stage_1 : boolean;
		var_bb_sensor_failure_warning : boolean;
		var_bb_waypoints_completed_stage_1 : boolean;
		var_cm_hsd_input : {cm_surface_task, cm_rth_task, cm_loiter_task, cm_obstacle_avoidance_task, cm_tracking_task, cm_waypoint_task};
		var_dd_output_stage_1 : {safe, xy_warn, z_warn};
		var_dd_xy_axis_degradation : boolean;
		var_dd_z_axis_warning : boolean;
		ddlec2bb_update_success : boolean;
		var_emergency_stop_warning : boolean;
		var_finished_missions_stage_1 : boolean;
		fls2bb_update_success : boolean;
		var_fls_range_stage_1 : {danger_zone, safe};
		fls_warning2bb_update_success : boolean;
		geofence2bb_update_success : boolean;
		home2bb_1_update_success : boolean;
		home2bb_update_success : boolean;
		var_lec2_am_l_stage_1 : {safe, speed, pipe, speed_pipe};
		lec2_am_l_2bb_update_success : boolean;
		var_lec2_am_l_pipe_warning : boolean;
		var_lec2_am_l_speed_warning : boolean;
		var_lec2_am_r_stage_1 : {safe, speed, pipe, speed_pipe};
		lec2_am_r_2bb_update_success : boolean;
		var_lec2_am_r_pipe_warning : boolean;
		var_lec2_am_r_speed_warning : boolean;
		var_lec_dd_am : boolean;
		var_lec_dd_am_warning : boolean;
		var_next_mission : boolean;
		var_obstacle_in_view_stage_1 : boolean;
		var_obstacle_standoff_warning : boolean;
		pipe_lost2bb_update_success : boolean;
		var_pipe_mapping_enable : boolean;
		rth2bb_update_success : boolean;
		rtreach2bb_update_success : boolean;
		rtreach_index2bb_update_success : boolean;
		var_rtreach_long_term_warning : boolean;
		var_rtreach_result_stage_1 : {safe, short, long, short_long};
		rtreach_unsafe_value2bb_update_success : boolean;
		var_rtreach_warning : boolean;
		sensor_failure2bb_update_success : boolean;
		waypoints_completed2bb_update_success : boolean;
		--END OF BLACKBOARD VARIABLES DECLARATION
	ASSIGN
		init(resume_from_here_in_subtree__priorities) := 24;
		--START OF BLACKBOARD VARIABLES INITIALIZATION
		init(var_BLUEROV_SURFACED) := 
			case
				TRUE : FALSE;
			esac;
		init(var_battery_stage_1) := 
			case
				TRUE : 1;
			esac;
		init(var_battery_low_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_fls_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_geofence_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_geofence_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_home_dist_stage_1) := 
			case
				TRUE : 10;
			esac;
		init(var_bb_home_reached) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_mission) := 
			case
				TRUE : waypoint_following;
			esac;
		init(var_bb_obstacle_warning_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_pipe_lost_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_pipe_mapping_enable) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_pipelost_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_rth_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_rth_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_sensor_failure_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_sensor_failure_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_bb_waypoints_completed_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_dd_xy_axis_degradation) := 
			case
				TRUE : FALSE;
			esac;
		init(var_dd_z_axis_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_emergency_stop_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_finished_missions_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_fls_range_stage_1) := 
			case
				TRUE : safe;
			esac;
		init(var_lec2_am_l_pipe_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_lec2_am_l_speed_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_lec2_am_r_pipe_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_lec2_am_r_speed_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_lec_dd_am) := 
			case
				TRUE : FALSE;
			esac;
		init(var_lec_dd_am_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_next_mission) := 
			case
				TRUE : FALSE;
			esac;
		init(var_obstacle_in_view_stage_1) := 
			case
				TRUE : FALSE;
			esac;
		init(var_obstacle_standoff_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_pipe_mapping_enable) := 
			case
				TRUE : FALSE;
			esac;
		init(var_rtreach_long_term_warning) := 
			case
				TRUE : FALSE;
			esac;
		init(var_rtreach_warning) := 
			case
				TRUE : FALSE;
			esac;
		--END OF BLACKBOARD VARIABLES INITIALIZATION
		next(resume_from_here_in_subtree__priorities) := 
			case
				(BlueROV.status in {success, failure}) : node_names.priorities;
				(priorities.status in {success, failure}) : node_names.priorities;
				TRUE : max(trace_running_source_priorities, node_names.priorities);
			esac;
		--START OF BLACKBOARD VARIABLES TRANSITION
		next(var_BLUEROV_SURFACED) := var_BLUEROV_SURFACED_stage_5;
		next(var_HSD_out) := var_HSD_out_stage_3;
		next(var_battery_stage_1) := 
			case
				next(!(battery2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_battery;
				next(battery2bb_update_success) : {0, 1};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_battery;
			esac;
		next(battery2bb_update_success) := 
			case
				next(!(BlueROV.active)) : battery2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_battery_low_warning) := var_battery_low_warning_stage_1;
		next(var_bb_fls_warning) := var_bb_fls_warning_stage_1;
		next(var_bb_geofence_stage_1) := 
			case
				next(!(geofence2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_geofence;
				next(geofence2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_geofence;
			esac;
		next(var_bb_geofence_warning) := var_bb_geofence_warning_stage_1;
		next(var_bb_home_dist_stage_1) := 
			case
				next(!(home2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_home_dist;
				next(home2bb_update_success) : {10, 100};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_home_dist;
			esac;
		var_bb_home_dist_stage_2 := 
			case
				!(home2bb_1.active) : var_bb_home_dist_stage_1;
				home2bb_1_update_success : {10, 100};
				TRUE : var_bb_home_dist_stage_1;
			esac;
		next(var_bb_home_reached) := var_bb_home_reached_stage_2;
		next(var_bb_mission) := var_bb_mission_stage_1;
		var_bb_mission_stage_1 := 
			case
				!(mission_server.active) : var_bb_mission;
				var_next_mission & !(var_finished_missions_stage_1) : {waypoint_following, e_stop, pipe_following};
				TRUE : var_bb_mission;
			esac;
		next(var_bb_obstacle_warning_stage_1) := 
			case
				next(!(obstacle_avoidance.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_obstacle_warning;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_bb_pipe_lost_warning) := var_bb_pipe_lost_warning_stage_1;
		next(var_bb_pipe_mapping_enable) := 
			case
				next(!(BlueROV.active)) : var_bb_pipe_mapping_enable;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_bb_pipelost_stage_1) := 
			case
				next(!(pipe_lost2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_pipelost;
				next(pipe_lost2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_pipelost;
			esac;
		next(var_bb_rth_stage_1) := 
			case
				next(!(rth2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_rth;
				next(rth2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_rth;
			esac;
		next(var_bb_rth_warning) := var_bb_rth_warning_stage_2;
		next(var_bb_sensor_failure_stage_1) := 
			case
				next(!(sensor_failure2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_sensor_failure;
				next(sensor_failure2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_sensor_failure;
			esac;
		next(var_bb_sensor_failure_warning) := var_bb_sensor_failure_warning_stage_1;
		next(var_bb_waypoints_completed_stage_1) := 
			case
				next(!(waypoints_completed2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_bb_waypoints_completed;
				next(waypoints_completed2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_bb_waypoints_completed;
			esac;
		next(var_cm_hsd_input) := var_cm_hsd_input_stage_13;
		next(var_dd_output_stage_1) := 
			case
				next(!(ddlec2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_dd_output;
				next(ddlec2bb_update_success) : {safe, xy_warn, z_warn};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_dd_output;
			esac;
		next(var_dd_xy_axis_degradation) := var_dd_xy_axis_degradation_stage_1;
		next(var_dd_z_axis_warning) := var_dd_z_axis_warning_stage_1;
		next(ddlec2bb_update_success) := 
			case
				next(!(BlueROV.active)) : ddlec2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_emergency_stop_warning) := var_emergency_stop_warning_stage_2;
		next(var_finished_missions_stage_1) := 
			case
				next(!(mission_server.active)) : LINK_TO_PREVIOUS_FINAL_var_finished_missions;
				next(var_next_mission) & LINK_TO_PREVIOUS_FINAL_var_finished_missions : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_finished_missions;
			esac;
		next(fls2bb_update_success) := 
			case
				next(!(BlueROV.active)) : fls2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_fls_range_stage_1) := 
			case
				next(!(fls2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_fls_range;
				next(fls2bb_update_success) : {danger_zone, safe};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_fls_range;
			esac;
		next(fls_warning2bb_update_success) := 
			case
				next(!(BlueROV.active)) : fls_warning2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(geofence2bb_update_success) := 
			case
				next(!(BlueROV.active)) : geofence2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(home2bb_1_update_success) := 
			case
				next(!(BlueROV.active)) : home2bb_1_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(home2bb_update_success) := 
			case
				next(!(BlueROV.active)) : home2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_lec2_am_l_stage_1) := 
			case
				next(!(lec2_am_l_2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_lec2_am_l;
				next(lec2_am_l_2bb_update_success) : {safe, speed, pipe, speed_pipe};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_lec2_am_l;
			esac;
		next(lec2_am_l_2bb_update_success) := 
			case
				next(!(BlueROV.active)) : lec2_am_l_2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_lec2_am_l_pipe_warning) := var_lec2_am_l_pipe_warning_stage_1;
		next(var_lec2_am_l_speed_warning) := var_lec2_am_l_speed_warning_stage_1;
		next(var_lec2_am_r_stage_1) := 
			case
				next(!(lec2_am_r_2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_lec2_am_r;
				next(lec2_am_r_2bb_update_success) : {safe, speed, pipe, speed_pipe};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_lec2_am_r;
			esac;
		next(lec2_am_r_2bb_update_success) := 
			case
				next(!(BlueROV.active)) : lec2_am_r_2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_lec2_am_r_pipe_warning) := var_lec2_am_r_pipe_warning_stage_1;
		next(var_lec2_am_r_speed_warning) := var_lec2_am_r_speed_warning_stage_1;
		next(var_lec_dd_am) := 
			case
				next(!(BlueROV.active)) : var_lec_dd_am;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_lec_dd_am_warning) := 
			case
				next(!(BlueROV.active)) : var_lec_dd_am_warning;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_next_mission) := var_next_mission_stage_2;
		next(var_obstacle_in_view_stage_1) := 
			case
				next(!(fls_warning2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_obstacle_in_view;
				next(fls_warning2bb_update_success) : {TRUE, FALSE};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_obstacle_in_view;
			esac;
		next(var_obstacle_standoff_warning) := var_obstacle_standoff_warning_stage_1;
		next(pipe_lost2bb_update_success) := 
			case
				next(!(BlueROV.active)) : pipe_lost2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_pipe_mapping_enable) := var_pipe_mapping_enable_stage_3;
		next(rth2bb_update_success) := 
			case
				next(!(BlueROV.active)) : rth2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(rtreach2bb_update_success) := 
			case
				next(!(BlueROV.active)) : rtreach2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(rtreach_index2bb_update_success) := 
			case
				next(!(BlueROV.active)) : rtreach_index2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_rtreach_long_term_warning) := var_rtreach_long_term_warning_stage_1;
		next(var_rtreach_result_stage_1) := 
			case
				next(!(rtreach2bb.active)) : LINK_TO_PREVIOUS_FINAL_var_rtreach_result;
				next(rtreach2bb_update_success) : {safe, short, long, short_long};
				TRUE : LINK_TO_PREVIOUS_FINAL_var_rtreach_result;
			esac;
		next(rtreach_unsafe_value2bb_update_success) := 
			case
				next(!(BlueROV.active)) : rtreach_unsafe_value2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(var_rtreach_warning) := var_rtreach_warning_stage_1;
		next(sensor_failure2bb_update_success) := 
			case
				next(!(BlueROV.active)) : sensor_failure2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		next(waypoints_completed2bb_update_success) := 
			case
				next(!(BlueROV.active)) : waypoints_completed2bb_update_success;
				TRUE : {TRUE, FALSE};
			esac;
		--END OF BLACKBOARD VARIABLES TRANSITION
-- mission is pipetracking, obstacle avoidance triggered, prove pipetracking/waypoint is resumed?
-- the mission isn't really suspended by obstacle avoidance.....

-- intentionally break trees in order to prove these specs are actually relevant. make more .bt files in order to do this.

-- see what happens if pipe mission actually ends. NO WAY TO DO THIS.
-- the only way to set a new mission is if waypoint_mission completes.

-- differentiate between failsafes that end the mission vs bad states that can be recovered from
-- mission endings probably cause the surface and we just end
-- a bad state is something like we have to avoid an obstacle. can we detect end of bad state and continue with mission as intended?


--failsafes:
-- battery_low_warning
-- sensor_failure_warning
-- emergency_stop_warning
-- home reached?????
-- obstacle_standoff_warning???

-- --battery failsafe always results in a surface task
-- LTLSPEC G (var_battery_low_warning_stage_1 -> (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- true
-- --battery failsafe is pernament
-- LTLSPEC G (var_battery_low_warning_stage_1 -> G (var_battery_low_warning_stage_1)); -- this is false, var_battery_low_warning can be unset

-- --sensor failsafe always results in a surface task
-- LTLSPEC G (var_bb_sensor_failure_warning_stage_1 -> (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- true
-- --sensor failsafe is pernament
-- LTLSPEC G (var_bb_sensor_failure_warning_stage_1 -> G (var_bb_sensor_failure_warning_stage_1)); -- true, it's pernament

-- --emergency failsafe always results in a surface task
-- LTLSPEC G (var_emergency_stop_warning_stage_1 -> (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- true
-- --emergency failsafe is pernament
-- LTLSPEC G (var_emergency_stop_warning_stage_1 -> G (var_emergency_stop_warning_stage_1)); -- true, it's pernament

-- --home_reached always results in a surface task
-- LTLSPEC G (var_bb_home_reached_stage_1 -> (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- false
-- LTLSPEC G (var_bb_home_reached_stage_1 -> X(surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- true
-- --home_reached is pernament
-- LTLSPEC G (var_bb_home_reached_stage_1 -> G (var_bb_home_reached_stage_1)); -- true, it's pernament

-- --obstacle_standoff always results in a surface task
-- LTLSPEC G (var_obstacle_standoff_warning_stage_1 -> (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)); -- true
-- --obstacle_standoff is pernament
-- LTLSPEC G (var_obstacle_standoff_warning_stage_1 -> G (var_obstacle_standoff_warning_stage_1)); -- this is false, var_obstacle_standoff_warning can be unset



-- --surface task cannot be entered multiple times during a single tick
-- LTLSPEC G (count(surface_task.active, surface_task_1.active, surface_task_2.active, surface_task_3.active, surface_task_4.active) < 2); -- true

-- --speed_min is only set once and speed_min and max are mutually exclusive
-- LTLSPEC G (speed_max_task.active -> (!(speed_min_task.active) & !(speed_min_task_1.active))); -- true
-- LTLSPEC G (speed_min_task.active -> (!(speed_max_task.active) & !(speed_min_task_1.active))); -- true
-- LTLSPEC G (speed_min_task_1.active -> (!(speed_min_task.active) & !(speed_max_task.active))); -- true


-- --when we tick, exactly one of the priorities tasks is selected. not 0, not 2.
-- LTLSPEC G (BlueROV.active -> count(surface_task.active, surface_task_1.active, surface_task_2.active, surface_task_3.active, surface_task_4.active, rth_task.active, rth_task_1.active, loiter_task.active, tracking_task.active,  loiter_task_1.active, waypoint_task.active, loiter_task_2.active) = 1); -- true, but slow

-- --multiple failsafes can be activated
-- LTLSPEC G (!(var_battery_low_warning_stage_1 & var_bb_geofence_warning_stage_1)); -- both can be set, this spec should be false.



-- --the missions eventually run out
-- LTLSPEC F (var_finished_missions_stage_1); -- this should be false.
-- --honestly, no good way to do this without a bunch of restrictions.




-- --the blueROV surfaces eventually
-- LTLSPEC F (surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active); -- this should be false, because missions don't need to end


-- --the blueROV surfaces eventually if battery gets low.
-- LTLSPEC G ((F var_battery = 0) -> F var_BLUEROV_SURFACED);



-- --obstacles eventually end
-- LTLSPEC G (var_bb_obstacle_warning -> F (!(var_bb_obstacle_warning) | var_BLUEROV_SURFACED)); -- fails. there is no way to prove that obstacles will not be detected at every step


-- --obstacle avoidance task command is ordered if bb_obstacle_warning
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_1 = cm_obstacle_avoidance_task)); -- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_2 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_3 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_4 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_5 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_6 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_7 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_8 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_9 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_10 = cm_obstacle_avoidance_task));-- true
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_11 = cm_obstacle_avoidance_task));-- true, but slow
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_12 = cm_obstacle_avoidance_task));-- true, very slow
-- LTLSPEC G (var_bb_obstacle_warning_stage_1 -> (var_cm_hsd_input_stage_13 = cm_obstacle_avoidance_task));-- probably true, extremely slow


-- --loiter_task_1 is unreachable (it is reachable. i meant loiter task 2... lol)
-- CTLSPEC EF (loiter_task_1.active); -- True
-- LTLSPEC G (!(loiter_task_1.active)); -- False, so it's eventually active



-- --loiter_task_2 is unreachable
-- CTLSPEC EF (loiter_task_2.active); -- False now.
-- LTLSPEC G (!(loiter_task_2.active)); -- True now, formerly false. slow though. see below
-- False. It's reachable... because i had an error in the file. specifically, i assumed emergency_stop_warning would be initialized to false, which may not be true, because bb_misison can be set to e_stop at start. fixed. for now. rechekcing if reachable.


-- --surface guarantees, but in ctl
-- CTLSPEC EF(var_BLUEROV_SURFACED); -- true, it is possible to reach the surface
-- CTLSPEC AF(var_BLUEROV_SURFACED); -- false, you are not guaranteed to reach the surface




------------------------------------------------------------
--specifications from contingency manager.
-- prioritize 1. do no harm, 2. keep the UUV safe, 3. completing the mission.


-- --1. do no harm
-- --this specification is TRUE if surfacing is safe and will not do harm. proof: obstacle avoidance always takes priority, but sometimes surfacing can interrupt.
-- --this specification is FALSE if surfacing is NOT always safe.
-- --for the true version, refer back to prior specifications which prove tht if  failsafe is set, we surface, and that if bb_obstacle_warning is set, we do obstacle avoidance
-- --for the false version, use the following specification to prove a violation
-- LTLSPEC G(var_bb_obstacle_warning_stage_1 -> !(emergency_stop_task.active)); -- FALSE. it is possible for obstacle avoidance ot be going, and emergency_stop_task to occur, which overwrites everthing else
-- --CTL version
-- CTLSPEC EF(var_bb_obstacle_warning_stage_1 & emergency_stop_task.active); -- TRUE. it is possible blah blah.

-- --2. keep the UUV safe
-- --exactly the same as specification 1. unclear on the difference to be honest.


-- --3. completing the mission
-- --impossible to show that the mission will be completed without asserting the mission is completed, or using a fairness constraint to do the same thing.
-- --however, we can show that if failsafes are not triggered and there is no obstacle avoidance, then we do our mission.

-- LTLSPEC G ((BlueROV.active & !(surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active)) -> (var_bb_mission_stage_1 = waypoint_following & (loiter_task_1.active | waypoint_task.active)) | (var_bb_mission_stage_1 = pipe_following & tracking_task.active)); --FALSE. return to home might be triggered.
-- LTLSPEC G ((BlueROV.active & !(surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active | rth_task.active | rth_task_1.active)) -> (var_bb_mission_stage_1 = waypoint_following & (loiter_task_1.active | waypoint_task.active)) | (var_bb_mission_stage_1 = pipe_following & (tracking_task.active | loiter_task.active)));  --TRUE. but this is very sketchy. Specifically, this is ONLY true because pipe_following cannot end. The issue i see with the currrent layout is that pipe_lost_warning is set BEFORE the mission is updated. Thus, if pipe_tracking could end, the following scenario could take place.
-- --tick 1. mission is pipe_tracking. mission ends.
-- --tick 2. pipe_lost_warning is set to true. mission is set to waypoint_following. tree executes loiter_task because pipe_lost_warning is set to true
-- --tick 3+. tree continues to execute loiter_task. it is not possible to unset this. eventually, battery runs out, and bluerov surfaces.
LTLSPEC G ((BlueROV.active & !(surface_task.active | surface_task_1.active | surface_task_2.active | surface_task_3.active | surface_task_4.active | rth_task.active | rth_task_1.active)) -> (var_bb_mission_stage_1 = waypoint_following & var_cm_hsd_input_stage_13 = cm_waypoint_task) | (var_bb_mission_stage_1 = pipe_following & var_cm_hsd_input_stage_13 = cm_tracking_task) | (var_cm_hsd_input_stage_13 = cm_obstacle_avoidance_task) | var_cm_hsd_input_stage_13 = cm_loiter_task);  --TRUE.


MODULE define_nodes
	DEFINE
		BlueROV := 0;
		topics2bb := 1;
		battery2bb := 2;
		rth2bb := 3;
		geofence2bb := 4;
		lec2_am_r_2bb := 5;
		lec2_am_l_2bb := 6;
		pipe_lost2bb := 7;
		sensor_failure2bb := 8;
		waypoints_completed2bb := 9;
		ddlec2bb := 10;
		fls2bb := 11;
		fls_warning2bb := 12;
		rtreach2bb := 13;
		rtreach_unsafe_value2bb := 14;
		rtreach_index2bb := 15;
		dd_tasks := 16;
		reallocate_check := 17;
		reallocate_check_1 := 18;
		is_reallocation_requested := 19;
		reallocate_task := 20;
		dd_lec_task := 21;
		mission_server := 22;
		obstacle_avoidance := 23;
		priorities := 24;
		battery_check := 25;
		battery_check_1 := 26;
		battery_low_fs := 27;
		surface_task := 28;
		sensor_failure_selector := 29;
		sensor_failure_selector_1 := 30;
		check_sensor_failure := 31;
		surface_task_1 := 32;
		emergency_stop_check := 33;
		emergency_stop_check_1 := 34;
		emergency_stop_fs := 35;
		emergency_stop_tasks := 36;
		emergency_stop_task := 37;
		surface_task_2 := 38;
		home_reached_selector := 39;
		home_reached_selector_1 := 40;
		check_surface := 41;
		surface_task_3 := 42;
		obstacle_standoff_check := 43;
		obstacle_standoff_check_1 := 44;
		obstacle_standoff_fs := 45;
		surface_task_4 := 46;
		rth_selector := 47;
		rth_selector_1 := 48;
		check_rth := 49;
		rth_par := 50;
		rth_task := 51;
		home2bb := 52;
		geofence_selector := 53;
		geofence_selector_1 := 54;
		check_geofence := 55;
		rth_par_1 := 56;
		rth_task_1 := 57;
		home2bb_1 := 58;
		pipe_lost_selector := 59;
		pipe_lost_selector_1 := 60;
		check_pipe_post := 61;
		loiter_task := 62;
		track_pipe_mission := 63;
		is_track_pipe_mission_requested := 64;
		tracking := 65;
		tracking_task := 66;
		lec2am_speed_cmd := 67;
		lec2am_l_speed_check := 68;
		lec2am_l_speed_check_1 := 69;
		check_lec2am_ls := 70;
		speed_min_task := 71;
		lec2am_r_speed_check := 72;
		lec2am_r_speed_check_1 := 73;
		check_lec2am_rs := 74;
		speed_min_task_1 := 75;
		speed_max_task := 76;
		lec2am_mapping_cmd := 77;
		lec2am_l_mapping_check := 78;
		lec2am_l_mapping_check_1 := 79;
		check_lec2am_lp := 80;
		pipe_mapping_disable_task := 81;
		lec2am_r_mapping_check := 82;
		lec2am_r_mapping_check_1 := 83;
		check_lec2am_rp := 84;
		pipe_mapping_disable_task_1 := 85;
		pipe_mapping_enable_task := 86;
		waypoint_mission := 87;
		is_waypoint_requested := 88;
		waypoint_selector := 89;
		waypoints_sif := 90;
		waypoints_sif_1 := 91;
		check_waypoints_completed := 92;
		waypoint_end := 93;
		next_mission := 94;
		loiter_task_1 := 95;
		waypoint_task := 96;
		loiter_task_2 := 97;
MODULE leaf_module(internal_status_module)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status_module.internal_status : invalid;
MODULE composite_parallel_success_on_all_without_memory_3(child_0, child_1, child_2)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				(child_0.internal_status = failure) : failure;
				(child_1.internal_status = failure) : failure;
				(child_2.internal_status = failure) : failure;
				!(child_0.internal_status = success) : child_0.internal_status;
				!(child_1.internal_status = success) : child_1.internal_status;
				!(child_2.internal_status = success) : child_2.internal_status;
				TRUE : success;
			esac;
		child_0.active := active;
		child_1.active := active;
		child_2.active := active;
MODULE composite_selector_without_memory_2(child_0, child_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				!(child_0.internal_status = failure) : child_0.internal_status;
				!(child_1.internal_status = failure) : child_1.internal_status;
				TRUE : failure;
			esac;
		child_0.active := active;
		child_1.active := child_0.status = failure;
MODULE composite_selector_without_memory_11(child_0, child_1, child_2, child_3, child_4, child_5, child_6, child_7, child_8, child_9, child_10)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				!(child_0.internal_status = failure) : child_0.internal_status;
				!(child_1.internal_status = failure) : child_1.internal_status;
				!(child_2.internal_status = failure) : child_2.internal_status;
				!(child_3.internal_status = failure) : child_3.internal_status;
				!(child_4.internal_status = failure) : child_4.internal_status;
				!(child_5.internal_status = failure) : child_5.internal_status;
				!(child_6.internal_status = failure) : child_6.internal_status;
				!(child_7.internal_status = failure) : child_7.internal_status;
				!(child_8.internal_status = failure) : child_8.internal_status;
				!(child_9.internal_status = failure) : child_9.internal_status;
				!(child_10.internal_status = failure) : child_10.internal_status;
				TRUE : failure;
			esac;
		child_0.active := active;
		child_1.active := child_0.status = failure;
		child_2.active := child_1.status = failure;
		child_3.active := child_2.status = failure;
		child_4.active := child_3.status = failure;
		child_5.active := child_4.status = failure;
		child_6.active := child_5.status = failure;
		child_7.active := child_6.status = failure;
		child_8.active := child_7.status = failure;
		child_9.active := child_8.status = failure;
		child_10.active := child_9.status = failure;
MODULE composite_parallel_success_on_all_without_memory_2(child_0, child_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				(child_0.internal_status = failure) : failure;
				(child_1.internal_status = failure) : failure;
				!(child_0.internal_status = success) : child_0.internal_status;
				!(child_1.internal_status = success) : child_1.internal_status;
				TRUE : success;
			esac;
		child_0.active := active;
		child_1.active := active;
MODULE composite_parallel_success_on_all_without_memory_14(child_0, child_1, child_2, child_3, child_4, child_5, child_6, child_7, child_8, child_9, child_10, child_11, child_12, child_13)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				(child_0.internal_status = failure) : failure;
				(child_1.internal_status = failure) : failure;
				(child_2.internal_status = failure) : failure;
				(child_3.internal_status = failure) : failure;
				(child_4.internal_status = failure) : failure;
				(child_5.internal_status = failure) : failure;
				(child_6.internal_status = failure) : failure;
				(child_7.internal_status = failure) : failure;
				(child_8.internal_status = failure) : failure;
				(child_9.internal_status = failure) : failure;
				(child_10.internal_status = failure) : failure;
				(child_11.internal_status = failure) : failure;
				(child_12.internal_status = failure) : failure;
				(child_13.internal_status = failure) : failure;
				!(child_0.internal_status = success) : child_0.internal_status;
				!(child_1.internal_status = success) : child_1.internal_status;
				!(child_2.internal_status = success) : child_2.internal_status;
				!(child_3.internal_status = success) : child_3.internal_status;
				!(child_4.internal_status = success) : child_4.internal_status;
				!(child_5.internal_status = success) : child_5.internal_status;
				!(child_6.internal_status = success) : child_6.internal_status;
				!(child_7.internal_status = success) : child_7.internal_status;
				!(child_8.internal_status = success) : child_8.internal_status;
				!(child_9.internal_status = success) : child_9.internal_status;
				!(child_10.internal_status = success) : child_10.internal_status;
				!(child_11.internal_status = success) : child_11.internal_status;
				!(child_12.internal_status = success) : child_12.internal_status;
				!(child_13.internal_status = success) : child_13.internal_status;
				TRUE : success;
			esac;
		child_0.active := active;
		child_1.active := active;
		child_2.active := active;
		child_3.active := active;
		child_4.active := active;
		child_5.active := active;
		child_6.active := active;
		child_7.active := active;
		child_8.active := active;
		child_9.active := active;
		child_10.active := active;
		child_11.active := active;
		child_12.active := active;
		child_13.active := active;
MODULE composite_sequence_with_memory_2(child_0, child_1, resume_point)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				(0 >= resume_point) & !(child_0.internal_status = success) : child_0.internal_status;
				(1 >= resume_point) & !(child_1.internal_status = success) : child_1.internal_status;
				TRUE : success;
			esac;
		child_0.active := active & (0 >= resume_point);
		child_1.active := active & ((1 >= resume_point) & ((1 = resume_point) | (child_0.status = success)));
MODULE composite_selector_without_memory_3(child_0, child_1, child_2)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				!(child_0.internal_status = failure) : child_0.internal_status;
				!(child_1.internal_status = failure) : child_1.internal_status;
				!(child_2.internal_status = failure) : child_2.internal_status;
				TRUE : failure;
			esac;
		child_0.active := active;
		child_1.active := child_0.status = failure;
		child_2.active := child_1.status = failure;
MODULE composite_parallel_success_on_all_without_memory_5(child_0, child_1, child_2, child_3, child_4)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				(child_0.internal_status = failure) : failure;
				(child_1.internal_status = failure) : failure;
				(child_2.internal_status = failure) : failure;
				(child_3.internal_status = failure) : failure;
				(child_4.internal_status = failure) : failure;
				!(child_0.internal_status = success) : child_0.internal_status;
				!(child_1.internal_status = success) : child_1.internal_status;
				!(child_2.internal_status = success) : child_2.internal_status;
				!(child_3.internal_status = success) : child_3.internal_status;
				!(child_4.internal_status = success) : child_4.internal_status;
				TRUE : success;
			esac;
		child_0.active := active;
		child_1.active := active;
		child_2.active := active;
		child_3.active := active;
		child_4.active := active;
MODULE decorator_X_is_Y(child_0, incoming_status, outgoing_status)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status :=
			case
				child_0.status = incoming_status : outgoing_status;
				TRUE : child_0.status;
			esac;
		child_0.active :=
			case
				!(active) : FALSE;
				TRUE : TRUE;
			esac;
MODULE battery2bb_module(battery2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := battery2bb_update_success ? success : running;
MODULE battery_low_fs_module(var_battery_low_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_battery_low_warning_stage_1 = FALSE) ? success : failure;
MODULE check_geofence_module(var_bb_geofence_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_geofence_warning_stage_1 = FALSE) ? success : failure;
MODULE check_lec2am_lp_module(var_lec2_am_l_pipe_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_lec2_am_l_pipe_warning_stage_1 = FALSE) ? success : failure;
MODULE check_lec2am_ls_module(var_lec2_am_l_speed_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_lec2_am_l_speed_warning_stage_1 = FALSE) ? success : failure;
MODULE check_lec2am_rp_module(var_lec2_am_r_pipe_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_lec2_am_r_pipe_warning_stage_1 = FALSE) ? success : failure;
MODULE check_lec2am_rs_module(var_lec2_am_r_speed_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_lec2_am_r_speed_warning_stage_1 = FALSE) ? success : failure;
MODULE check_pipe_post_module(var_bb_pipe_lost_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_pipe_lost_warning_stage_1 = FALSE) ? success : failure;
MODULE check_rth_module(var_bb_rth_warning_stage_2)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_rth_warning_stage_2 = FALSE) ? success : failure;
MODULE check_sensor_failure_module(var_bb_sensor_failure_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_sensor_failure_warning_stage_1 = FALSE) ? success : failure;
MODULE check_surface_module(var_bb_home_reached)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_home_reached = FALSE) ? success : failure;
MODULE check_waypoints_completed_module(var_bb_waypoints_completed_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_waypoints_completed_stage_1 = FALSE) ? success : failure;
MODULE ddlec2bb_module(ddlec2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := ddlec2bb_update_success ? success : running;
MODULE emergency_stop_fs_module(var_emergency_stop_warning_stage_2)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_emergency_stop_warning_stage_2 = FALSE) ? success : failure;
MODULE fls2bb_module(fls2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := fls2bb_update_success ? success : running;
MODULE fls_warning2bb_module(fls_warning2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := fls_warning2bb_update_success ? success : running;
MODULE geofence2bb_module(geofence2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := geofence2bb_update_success ? success : running;
MODULE home2bb_module(home2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := home2bb_update_success ? success : running;
MODULE home2bb_1_module(home2bb_1_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := home2bb_1_update_success ? success : running;
MODULE is_reallocation_requested_module(var_dd_xy_axis_degradation_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_dd_xy_axis_degradation_stage_1 = FALSE) ? success : failure;
MODULE is_track_pipe_mission_requested_module(var_bb_mission_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_mission_stage_1 = pipe_following) ? success : failure;
MODULE is_waypoint_requested_module(var_bb_mission_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_bb_mission_stage_1 = waypoint_following) ? success : failure;
MODULE lec2_am_l_2bb_module(lec2_am_l_2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := lec2_am_l_2bb_update_success ? success : running;
MODULE lec2_am_r_2bb_module(lec2_am_r_2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := lec2_am_r_2bb_update_success ? success : running;
MODULE obstacle_standoff_fs_module(var_obstacle_standoff_warning_stage_1)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := (var_obstacle_standoff_warning_stage_1 = FALSE) ? success : failure;
MODULE pipe_lost2bb_module(pipe_lost2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := pipe_lost2bb_update_success ? success : running;
MODULE rth2bb_module(rth2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := rth2bb_update_success ? success : running;
MODULE rtreach2bb_module(rtreach2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := rtreach2bb_update_success ? success : running;
MODULE rtreach_index2bb_module(rtreach_index2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := rtreach_index2bb_update_success ? success : running;
MODULE rtreach_unsafe_value2bb_module(rtreach_unsafe_value2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := rtreach_unsafe_value2bb_update_success ? success : running;
MODULE sensor_failure2bb_module(sensor_failure2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := sensor_failure2bb_update_success ? success : running;
MODULE waypoints_completed2bb_module(waypoints_completed2bb_update_success)
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := waypoints_completed2bb_update_success ? success : running;
MODULE success_DEFAULT_module
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := success;
MODULE running_DEFAULT_module
	CONSTANTS
		success, failure, running, invalid;
	DEFINE
		status := active ? internal_status : invalid;
		internal_status := running;
