MODULE main
	DEFINE
		max_active_node := 102;
		statuses := [BlueROV.status, topics2bb.status, dd_tasks.status, mission_server.status, obstacle_avoidance.status, priorities.status, battery2bb.status, rth2bb.status, geofence2bb.status, lec2_am_r_2bb.status, lec2_am_l_2bb.status, pipe_lost2bb.status, sensor_failure2bb.status, waypoints_completed2bb.status, mission2bb.status, ddlec2bb.status, fls2bb.status, fls_warning2bb.status, hsd_pipe2bb.status, hsd_wp2bb.status, hsd_rth2bb.status, hsd_surface2bb.status, rtreach2bb.status, reallocate_check_SIF.status, dd_lec_task.status, reallocate_check.status, is_reallocation_requested.status, reallocate_task.status, battery_check_SIF.status, sensor_failure_selector_SIF.status, emergency_stop_check_SIF.status, home_reached_selector_SIF.status, obstacle_standoff_check_SIF.status, rth_selector_SIF.status, geofence_selector_SIF.status, pipe_lost_selector_SIF.status, track_pipe_mission.status, waypoint_mission.status, loiter_task.status, battery_check.status, battery_low_fs.status, surface_task.status, sensor_failure_selector.status, check_sensor_failure.status, surface_task1.status, emergency_stop_check.status, emergency_stop_fs.status, emergency_stop_tasks.status, emergency_stop_task.status, surface_task2.status, home_reached_selector.status, check_surface.status, surface_task3.status, obstacle_standoff_check.status, obstacle_standoff_fs.status, surface_task4.status, rth_selector.status, check_rth.status, rth_par.status, rth_task.status, home2bb.status, geofence_selector.status, check_geofence.status, rth_par1.status, rth_task1.status, home2bb1.status, pipe_lost_selector.status, check_pipe_post.status, loiter_task1.status, is_track_pipe_mission_requested.status, tracking.status, track_pipe_mission_end.status, tracking_task.status, lec2am_speed_cmd.status, lec2am_mapping_cmd.status, lec2am_l_speed_check_SIF.status, lec2am_r_speed_check_SIF.status, speed_max_task.status, lec2am_l_speed_check.status, check_lec2am_ls.status, speed_min_task.status, lec2am_r_speed_check.status, check_lec2am_rs.status, speed_min_task1.status, lec2am_l_mapping_check_SIF.status, lec2am_r_mapping_check_SIF.status, pipe_mapping_enable_task.status, lec2am_l_mapping_check.status, check_lec2am_lp.status, pipe_mapping_disable_task.status, lec2am_r_mapping_check.status, check_lec2am_rp.status, pipe_mapping_disable_task1.status, evaluate.status, is_waypoint_requested.status, waypoint_selector.status, waypoints_sif_SIF.status, waypoint_task.status, waypoints_sif.status, check_waypoints_completed.status, waypoint_end.status, next_mission.status, loiter_task2.status];
		parents := [-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 23, 25, 25, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 28, 39, 39, 29, 42, 42, 30, 45, 45, 47, 47, 31, 50, 50, 32, 53, 53, 33, 56, 56, 58, 58, 34, 61, 61, 63, 63, 35, 66, 66, 36, 36, 36, 70, 70, 70, 73, 73, 73, 75, 78, 78, 76, 81, 81, 74, 74, 74, 84, 87, 87, 85, 90, 90, 71, 37, 37, 95, 95, 96, 98, 98, 100, 100];
		leafs := {-3, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 26, 27, 38, 40, 41, 43, 44, 46, 48, 49, 51, 52, 54, 55, 57, 59, 60, 62, 64, 65, 67, 68, 69, 72, 77, 79, 80, 82, 83, 86, 88, 89, 91, 92, 93, 94, 97, 99, 101, 102};
		selectors := {-3, 2, 5, 25, 39, 42, 45, 50, 53, 56, 61, 66, 73, 74, 78, 81, 87, 90, 95, 98};
		sequences := {-3, 36, 37, 47, 71, 100};
		parallels_synchronised_all := {-3};
		parallels_unsynchronised_all := {-3, 0, 1, 58, 63, 70};
		parallels_synchronised_one := {-3};
		parallels_unsynchronised_one := {-3};
		parallels := {-3, 0, 1, 58, 63, 70};
		decorators := {-3, 23, 28, 29, 30, 31, 32, 33, 34, 35, 75, 76, 84, 85, 96};
		first_child := [1, 6, 23, -2, -2, 28, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 25, -2, 26, -2, -2, 39, 42, 45, 50, 53, 56, 61, 66, 69, 94, -2, 40, -2, -2, 43, -2, -2, 46, -2, 48, -2, -2, 51, -2, -2, 54, -2, -2, 57, -2, 59, -2, -2, 62, -2, 64, -2, -2, 67, -2, -2, -2, 72, 93, -2, 75, 84, 78, 81, -2, 79, -2, -2, 82, -2, -2, 87, 90, -2, 88, -2, -2, 91, -2, -2, -2, -2, 96, 98, -2, 99, -2, 101, -2, -2];
		last_child := [5, 22, 24, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, 27, -1, -1, 39, 42, 45, 50, 53, 56, 61, 66, 71, 95, -1, 41, -1, -1, 44, -1, -1, 47, -1, 49, -1, -1, 52, -1, -1, 55, -1, -1, 58, -1, 60, -1, -1, 63, -1, 65, -1, -1, 68, -1, -1, -1, 74, 93, -1, 77, 86, 78, 81, -1, 80, -1, -1, 83, -1, -1, 87, 90, -1, 89, -1, -1, 92, -1, -1, -1, -1, 97, 98, -1, 100, -1, 102, -1, -1];
		resume_status_0 := 0;
		resume_status_1 := 1;
		resume_status_6 := 6;
		resume_status_7 := 7;
		resume_status_8 := 8;
		resume_status_9 := 9;
		resume_status_10 := 10;
		resume_status_11 := 11;
		resume_status_12 := 12;
		resume_status_13 := 13;
		resume_status_14 := 14;
		resume_status_15 := 15;
		resume_status_16 := 16;
		resume_status_17 := 17;
		resume_status_18 := 18;
		resume_status_19 := 19;
		resume_status_20 := 20;
		resume_status_21 := 21;
		resume_status_22 := 22;
		resume_status_2 := 2;
		resume_status_3 := 3;
		resume_status_4 := 4;
		resume_status_59 := 59;
		resume_status_60 := 60;
		resume_status_64 := 64;
		resume_status_65 := 65;
		resume_status_72 := 72;
		resume_status_73 := 73;
		resume_status_74 := 74;
		next_node := [next_node_0, next_node_1, next_node_2, next_node_3, next_node_4, next_node_5, next_node_6, next_node_7, next_node_8, next_node_9, next_node_10, next_node_11, next_node_12, next_node_13, next_node_14, next_node_15, next_node_16, next_node_17, next_node_18, next_node_19, next_node_20, next_node_21, next_node_22, next_node_23, next_node_24, next_node_25, next_node_26, next_node_27, next_node_28, next_node_29, next_node_30, next_node_31, next_node_32, next_node_33, next_node_34, next_node_35, next_node_36, next_node_37, next_node_38, next_node_39, next_node_40, next_node_41, next_node_42, next_node_43, next_node_44, next_node_45, next_node_46, next_node_47, next_node_48, next_node_49, next_node_50, next_node_51, next_node_52, next_node_53, next_node_54, next_node_55, next_node_56, next_node_57, next_node_58, next_node_59, next_node_60, next_node_61, next_node_62, next_node_63, next_node_64, next_node_65, next_node_66, next_node_67, next_node_68, next_node_69, next_node_70, next_node_71, next_node_72, next_node_73, next_node_74, next_node_75, next_node_76, next_node_77, next_node_78, next_node_79, next_node_80, next_node_81, next_node_82, next_node_83, next_node_84, next_node_85, next_node_86, next_node_87, next_node_88, next_node_89, next_node_90, next_node_91, next_node_92, next_node_93, next_node_94, next_node_95, next_node_96, next_node_97, next_node_98, next_node_99, next_node_100, next_node_101, next_node_102];
		next_node_0 := 
			case
				(previous_node <1) : next_node_1;
				(previous_node <2) : next_node_2;
				(previous_node <3) : next_node_3;
				(previous_node <4) : next_node_4;
				(previous_node <5) : next_node_5;
				TRUE : parents[0];
			esac;
		next_node_1 := 
			case
				(previous_node <6) : next_node_6;
				(previous_node <7) : next_node_7;
				(previous_node <8) : next_node_8;
				(previous_node <9) : next_node_9;
				(previous_node <10) : next_node_10;
				(previous_node <11) : next_node_11;
				(previous_node <12) : next_node_12;
				(previous_node <13) : next_node_13;
				(previous_node <14) : next_node_14;
				(previous_node <15) : next_node_15;
				(previous_node <16) : next_node_16;
				(previous_node <17) : next_node_17;
				(previous_node <18) : next_node_18;
				(previous_node <19) : next_node_19;
				(previous_node <20) : next_node_20;
				(previous_node <21) : next_node_21;
				(previous_node <22) : next_node_22;
				TRUE : parents[1];
			esac;
		next_node_2 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 2) : parents[2];
				(previous_node <23) : next_node_23;
				(previous_node <24) : next_node_24;
				TRUE : parents[2];
			esac;
		next_node_3 := 
			case
				!(active_node = 3) : 3;
				TRUE : parents[3];
			esac;
		next_node_4 := 
			case
				!(active_node = 4) : 4;
				TRUE : parents[4];
			esac;
		next_node_5 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 5) : parents[5];
				(previous_node <28) : next_node_28;
				(previous_node <29) : next_node_29;
				(previous_node <30) : next_node_30;
				(previous_node <31) : next_node_31;
				(previous_node <32) : next_node_32;
				(previous_node <33) : next_node_33;
				(previous_node <34) : next_node_34;
				(previous_node <35) : next_node_35;
				(previous_node <36) : next_node_36;
				(previous_node <37) : next_node_37;
				(previous_node <38) : next_node_38;
				TRUE : parents[5];
			esac;
		next_node_6 := 
			case
				!(active_node = 6) : 6;
				TRUE : parents[6];
			esac;
		next_node_7 := 
			case
				!(active_node = 7) : 7;
				TRUE : parents[7];
			esac;
		next_node_8 := 
			case
				!(active_node = 8) : 8;
				TRUE : parents[8];
			esac;
		next_node_9 := 
			case
				!(active_node = 9) : 9;
				TRUE : parents[9];
			esac;
		next_node_10 := 
			case
				!(active_node = 10) : 10;
				TRUE : parents[10];
			esac;
		next_node_11 := 
			case
				!(active_node = 11) : 11;
				TRUE : parents[11];
			esac;
		next_node_12 := 
			case
				!(active_node = 12) : 12;
				TRUE : parents[12];
			esac;
		next_node_13 := 
			case
				!(active_node = 13) : 13;
				TRUE : parents[13];
			esac;
		next_node_14 := 
			case
				!(active_node = 14) : 14;
				TRUE : parents[14];
			esac;
		next_node_15 := 
			case
				!(active_node = 15) : 15;
				TRUE : parents[15];
			esac;
		next_node_16 := 
			case
				!(active_node = 16) : 16;
				TRUE : parents[16];
			esac;
		next_node_17 := 
			case
				!(active_node = 17) : 17;
				TRUE : parents[17];
			esac;
		next_node_18 := 
			case
				!(active_node = 18) : 18;
				TRUE : parents[18];
			esac;
		next_node_19 := 
			case
				!(active_node = 19) : 19;
				TRUE : parents[19];
			esac;
		next_node_20 := 
			case
				!(active_node = 20) : 20;
				TRUE : parents[20];
			esac;
		next_node_21 := 
			case
				!(active_node = 21) : 21;
				TRUE : parents[21];
			esac;
		next_node_22 := 
			case
				!(active_node = 22) : 22;
				TRUE : parents[22];
			esac;
		next_node_23 := 
			case
				(active_node < 23) : next_node_25;
				TRUE : parents[23];
			esac;
		next_node_24 := 
			case
				!(active_node = 24) : 24;
				TRUE : parents[24];
			esac;
		next_node_25 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 25) : parents[25];
				(previous_node <26) : next_node_26;
				(previous_node <27) : next_node_27;
				TRUE : parents[25];
			esac;
		next_node_26 := 
			case
				!(active_node = 26) : 26;
				TRUE : parents[26];
			esac;
		next_node_27 := 
			case
				!(active_node = 27) : 27;
				TRUE : parents[27];
			esac;
		next_node_28 := 
			case
				(active_node < 28) : next_node_39;
				TRUE : parents[28];
			esac;
		next_node_29 := 
			case
				(active_node < 29) : next_node_42;
				TRUE : parents[29];
			esac;
		next_node_30 := 
			case
				(active_node < 30) : next_node_45;
				TRUE : parents[30];
			esac;
		next_node_31 := 
			case
				(active_node < 31) : next_node_50;
				TRUE : parents[31];
			esac;
		next_node_32 := 
			case
				(active_node < 32) : next_node_53;
				TRUE : parents[32];
			esac;
		next_node_33 := 
			case
				(active_node < 33) : next_node_56;
				TRUE : parents[33];
			esac;
		next_node_34 := 
			case
				(active_node < 34) : next_node_61;
				TRUE : parents[34];
			esac;
		next_node_35 := 
			case
				(active_node < 35) : next_node_66;
				TRUE : parents[35];
			esac;
		next_node_36 := 
			case
				(previous_status = running | previous_status = failure) & (active_node = 36) : parents[36];
				(resume_status_5 = 93) : next_node_93;
				(previous_node <69) : next_node_69;
				(previous_node <70) : next_node_70;
				(previous_node <71) : next_node_71;
				TRUE : parents[36];
			esac;
		next_node_37 := 
			case
				(previous_status = running | previous_status = failure) & (active_node = 37) : parents[37];
				(resume_status_5 = 95) : next_node_95;
				(resume_status_5 = 101) : next_node_95;
				(resume_status_5 = 102) : next_node_95;
				(previous_node <94) : next_node_94;
				(previous_node <95) : next_node_95;
				TRUE : parents[37];
			esac;
		next_node_38 := 
			case
				!(active_node = 38) : 38;
				TRUE : parents[38];
			esac;
		next_node_39 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 39) : parents[39];
				(previous_node <40) : next_node_40;
				(previous_node <41) : next_node_41;
				TRUE : parents[39];
			esac;
		next_node_40 := 
			case
				!(active_node = 40) : 40;
				TRUE : parents[40];
			esac;
		next_node_41 := 
			case
				!(active_node = 41) : 41;
				TRUE : parents[41];
			esac;
		next_node_42 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 42) : parents[42];
				(previous_node <43) : next_node_43;
				(previous_node <44) : next_node_44;
				TRUE : parents[42];
			esac;
		next_node_43 := 
			case
				!(active_node = 43) : 43;
				TRUE : parents[43];
			esac;
		next_node_44 := 
			case
				!(active_node = 44) : 44;
				TRUE : parents[44];
			esac;
		next_node_45 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 45) : parents[45];
				(previous_node <46) : next_node_46;
				(previous_node <47) : next_node_47;
				TRUE : parents[45];
			esac;
		next_node_46 := 
			case
				!(active_node = 46) : 46;
				TRUE : parents[46];
			esac;
		next_node_47 := 
			case
				(previous_status = running | previous_status = failure) & (active_node = 47) : parents[47];
				(resume_status_5 = 49) : next_node_49;
				(previous_node <48) : next_node_48;
				(previous_node <49) : next_node_49;
				TRUE : parents[47];
			esac;
		next_node_48 := 
			case
				!(active_node = 48) : 48;
				TRUE : parents[48];
			esac;
		next_node_49 := 
			case
				!(active_node = 49) : 49;
				TRUE : parents[49];
			esac;
		next_node_50 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 50) : parents[50];
				(previous_node <51) : next_node_51;
				(previous_node <52) : next_node_52;
				TRUE : parents[50];
			esac;
		next_node_51 := 
			case
				!(active_node = 51) : 51;
				TRUE : parents[51];
			esac;
		next_node_52 := 
			case
				!(active_node = 52) : 52;
				TRUE : parents[52];
			esac;
		next_node_53 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 53) : parents[53];
				(previous_node <54) : next_node_54;
				(previous_node <55) : next_node_55;
				TRUE : parents[53];
			esac;
		next_node_54 := 
			case
				!(active_node = 54) : 54;
				TRUE : parents[54];
			esac;
		next_node_55 := 
			case
				!(active_node = 55) : 55;
				TRUE : parents[55];
			esac;
		next_node_56 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 56) : parents[56];
				(previous_node <57) : next_node_57;
				(previous_node <58) : next_node_58;
				TRUE : parents[56];
			esac;
		next_node_57 := 
			case
				!(active_node = 57) : 57;
				TRUE : parents[57];
			esac;
		next_node_58 := 
			case
				(previous_node <59) : next_node_59;
				(previous_node <60) : next_node_60;
				TRUE : parents[58];
			esac;
		next_node_59 := 
			case
				!(active_node = 59) : 59;
				TRUE : parents[59];
			esac;
		next_node_60 := 
			case
				!(active_node = 60) : 60;
				TRUE : parents[60];
			esac;
		next_node_61 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 61) : parents[61];
				(previous_node <62) : next_node_62;
				(previous_node <63) : next_node_63;
				TRUE : parents[61];
			esac;
		next_node_62 := 
			case
				!(active_node = 62) : 62;
				TRUE : parents[62];
			esac;
		next_node_63 := 
			case
				(previous_node <64) : next_node_64;
				(previous_node <65) : next_node_65;
				TRUE : parents[63];
			esac;
		next_node_64 := 
			case
				!(active_node = 64) : 64;
				TRUE : parents[64];
			esac;
		next_node_65 := 
			case
				!(active_node = 65) : 65;
				TRUE : parents[65];
			esac;
		next_node_66 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 66) : parents[66];
				(previous_node <67) : next_node_67;
				(previous_node <68) : next_node_68;
				TRUE : parents[66];
			esac;
		next_node_67 := 
			case
				!(active_node = 67) : 67;
				TRUE : parents[67];
			esac;
		next_node_68 := 
			case
				!(active_node = 68) : 68;
				TRUE : parents[68];
			esac;
		next_node_69 := 
			case
				!(active_node = 69) : 69;
				TRUE : parents[69];
			esac;
		next_node_70 := 
			case
				(previous_node <72) : next_node_72;
				(previous_node <73) : next_node_73;
				(previous_node <74) : next_node_74;
				TRUE : parents[70];
			esac;
		next_node_71 := 
			case
				(active_node < 71) : next_node_93;
				TRUE : parents[71];
			esac;
		next_node_72 := 
			case
				!(active_node = 72) : 72;
				TRUE : parents[72];
			esac;
		next_node_73 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 73) : parents[73];
				(previous_node <75) : next_node_75;
				(previous_node <76) : next_node_76;
				(previous_node <77) : next_node_77;
				TRUE : parents[73];
			esac;
		next_node_74 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 74) : parents[74];
				(previous_node <84) : next_node_84;
				(previous_node <85) : next_node_85;
				(previous_node <86) : next_node_86;
				TRUE : parents[74];
			esac;
		next_node_75 := 
			case
				(active_node < 75) : next_node_78;
				TRUE : parents[75];
			esac;
		next_node_76 := 
			case
				(active_node < 76) : next_node_81;
				TRUE : parents[76];
			esac;
		next_node_77 := 
			case
				!(active_node = 77) : 77;
				TRUE : parents[77];
			esac;
		next_node_78 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 78) : parents[78];
				(previous_node <79) : next_node_79;
				(previous_node <80) : next_node_80;
				TRUE : parents[78];
			esac;
		next_node_79 := 
			case
				!(active_node = 79) : 79;
				TRUE : parents[79];
			esac;
		next_node_80 := 
			case
				!(active_node = 80) : 80;
				TRUE : parents[80];
			esac;
		next_node_81 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 81) : parents[81];
				(previous_node <82) : next_node_82;
				(previous_node <83) : next_node_83;
				TRUE : parents[81];
			esac;
		next_node_82 := 
			case
				!(active_node = 82) : 82;
				TRUE : parents[82];
			esac;
		next_node_83 := 
			case
				!(active_node = 83) : 83;
				TRUE : parents[83];
			esac;
		next_node_84 := 
			case
				(active_node < 84) : next_node_87;
				TRUE : parents[84];
			esac;
		next_node_85 := 
			case
				(active_node < 85) : next_node_90;
				TRUE : parents[85];
			esac;
		next_node_86 := 
			case
				!(active_node = 86) : 86;
				TRUE : parents[86];
			esac;
		next_node_87 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 87) : parents[87];
				(previous_node <88) : next_node_88;
				(previous_node <89) : next_node_89;
				TRUE : parents[87];
			esac;
		next_node_88 := 
			case
				!(active_node = 88) : 88;
				TRUE : parents[88];
			esac;
		next_node_89 := 
			case
				!(active_node = 89) : 89;
				TRUE : parents[89];
			esac;
		next_node_90 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 90) : parents[90];
				(previous_node <91) : next_node_91;
				(previous_node <92) : next_node_92;
				TRUE : parents[90];
			esac;
		next_node_91 := 
			case
				!(active_node = 91) : 91;
				TRUE : parents[91];
			esac;
		next_node_92 := 
			case
				!(active_node = 92) : 92;
				TRUE : parents[92];
			esac;
		next_node_93 := 
			case
				!(active_node = 93) : 93;
				TRUE : parents[93];
			esac;
		next_node_94 := 
			case
				!(active_node = 94) : 94;
				TRUE : parents[94];
			esac;
		next_node_95 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 95) : parents[95];
				(previous_node <96) : next_node_96;
				(previous_node <97) : next_node_97;
				TRUE : parents[95];
			esac;
		next_node_96 := 
			case
				(active_node < 96) : next_node_98;
				TRUE : parents[96];
			esac;
		next_node_97 := 
			case
				!(active_node = 97) : 97;
				TRUE : parents[97];
			esac;
		next_node_98 := 
			case
				(previous_status = running | previous_status = success) & (active_node = 98) : parents[98];
				(previous_node <99) : next_node_99;
				(previous_node <100) : next_node_100;
				TRUE : parents[98];
			esac;
		next_node_99 := 
			case
				!(active_node = 99) : 99;
				TRUE : parents[99];
			esac;
		next_node_100 := 
			case
				(previous_status = running | previous_status = failure) & (active_node = 100) : parents[100];
				(resume_status_5 = 102) : next_node_102;
				(previous_node <101) : next_node_101;
				(previous_node <102) : next_node_102;
				TRUE : parents[100];
			esac;
		next_node_101 := 
			case
				!(active_node = 101) : 101;
				TRUE : parents[101];
			esac;
		next_node_102 := 
			case
				!(active_node = 102) : 102;
				TRUE : parents[102];
			esac;
	VAR
		active_node : -2..max_active_node;
		previous_node : -1..max_active_node;
		previous_status : {running, success, failure, invalid};
		resume_status_5 : {49, 93, 95, 101, 102, 5};
		BlueROV : node_parallel(active_node, 0, previous_status, 5, previous_node, FALSE, TRUE, next_node_0);
		topics2bb : node_parallel(active_node, 1, previous_status, 22, previous_node, FALSE, TRUE, next_node_1);
		dd_tasks : node_selector(active_node, 2, previous_status, 24, previous_node);
		mission_server : node_set_blackboard_variables(active_node, 3, mission_server_SET_status);
		mission_server_SET_status : mission_server_SET_status_module(active_node, 3, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		obstacle_avoidance : node_set_blackboard_variables(active_node, 4, obstacle_avoidance_SET_status);
		obstacle_avoidance_SET_status : obstacle_avoidance_SET_status_module(active_node, 4, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		priorities : node_selector(active_node, 5, previous_status, 38, previous_node);
		battery2bb : node_set_blackboard_variables(active_node, 6, battery2bb_SET_status);
		battery2bb_SET_status : battery2bb_SET_status_module(active_node, 6, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth2bb : node_set_blackboard_variables(active_node, 7, rth2bb_SET_status);
		rth2bb_SET_status : rth2bb_SET_status_module(active_node, 7, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		geofence2bb : node_set_blackboard_variables(active_node, 8, geofence2bb_SET_status);
		geofence2bb_SET_status : geofence2bb_SET_status_module(active_node, 8, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2_am_r_2bb : node_set_blackboard_variables(active_node, 9, lec2_am_r_2bb_SET_status);
		lec2_am_r_2bb_SET_status : lec2_am_r_2bb_SET_status_module(active_node, 9, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2_am_l_2bb : node_set_blackboard_variables(active_node, 10, lec2_am_l_2bb_SET_status);
		lec2_am_l_2bb_SET_status : lec2_am_l_2bb_SET_status_module(active_node, 10, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_lost2bb : node_set_blackboard_variables(active_node, 11, pipe_lost2bb_SET_status);
		pipe_lost2bb_SET_status : pipe_lost2bb_SET_status_module(active_node, 11, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		sensor_failure2bb : node_set_blackboard_variables(active_node, 12, sensor_failure2bb_SET_status);
		sensor_failure2bb_SET_status : sensor_failure2bb_SET_status_module(active_node, 12, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoints_completed2bb : node_set_blackboard_variables(active_node, 13, waypoints_completed2bb_SET_status);
		waypoints_completed2bb_SET_status : waypoints_completed2bb_SET_status_module(active_node, 13, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		mission2bb : node_set_blackboard_variables(active_node, 14, mission2bb_SET_status);
		mission2bb_SET_status : mission2bb_SET_status_module(active_node, 14, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		ddlec2bb : node_set_blackboard_variables(active_node, 15, ddlec2bb_SET_status);
		ddlec2bb_SET_status : ddlec2bb_SET_status_module(active_node, 15, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		fls2bb : node_set_blackboard_variables(active_node, 16, fls2bb_SET_status);
		fls2bb_SET_status : fls2bb_SET_status_module(active_node, 16, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		fls_warning2bb : node_set_blackboard_variables(active_node, 17, fls_warning2bb_SET_status);
		fls_warning2bb_SET_status : fls_warning2bb_SET_status_module(active_node, 17, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_pipe2bb : node_set_blackboard_variables(active_node, 18, hsd_pipe2bb_SET_status);
		hsd_pipe2bb_SET_status : hsd_pipe2bb_SET_status_module(active_node, 18, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_wp2bb : node_set_blackboard_variables(active_node, 19, hsd_wp2bb_SET_status);
		hsd_wp2bb_SET_status : hsd_wp2bb_SET_status_module(active_node, 19, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_rth2bb : node_set_blackboard_variables(active_node, 20, hsd_rth2bb_SET_status);
		hsd_rth2bb_SET_status : hsd_rth2bb_SET_status_module(active_node, 20, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_surface2bb : node_set_blackboard_variables(active_node, 21, hsd_surface2bb_SET_status);
		hsd_surface2bb_SET_status : hsd_surface2bb_SET_status_module(active_node, 21, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rtreach2bb : node_set_blackboard_variables(active_node, 22, rtreach2bb_SET_status);
		rtreach2bb_SET_status : rtreach2bb_SET_status_module(active_node, 22, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		reallocate_check_SIF : decorator_success_is_failure(active_node, 23, previous_status);
		dd_lec_task : node_set_blackboard_variables(active_node, 24, dd_lec_task_SET_status);
		dd_lec_task_SET_status : dd_lec_task_SET_status_module(active_node, 24, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		reallocate_check : node_selector(active_node, 25, previous_status, 27, previous_node);
		is_reallocation_requested : node_check_blackboard_variable_value(active_node, 26, blackboard, 29, is_reallocation_requested_CHECK_dd_xy_axis_degradation);
		is_reallocation_requested_CHECK_dd_xy_axis_degradation : is_reallocation_requested_CHECK_dd_xy_axis_degradation_module(active_node, 26, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		reallocate_task : node_set_blackboard_variables(active_node, 27, reallocate_task_SET_status);
		reallocate_task_SET_status : reallocate_task_SET_status_module(active_node, 27, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		battery_check_SIF : decorator_success_is_failure(active_node, 28, previous_status);
		sensor_failure_selector_SIF : decorator_success_is_failure(active_node, 29, previous_status);
		emergency_stop_check_SIF : decorator_success_is_failure(active_node, 30, previous_status);
		home_reached_selector_SIF : decorator_success_is_failure(active_node, 31, previous_status);
		obstacle_standoff_check_SIF : decorator_success_is_failure(active_node, 32, previous_status);
		rth_selector_SIF : decorator_success_is_failure(active_node, 33, previous_status);
		geofence_selector_SIF : decorator_success_is_failure(active_node, 34, previous_status);
		pipe_lost_selector_SIF : decorator_success_is_failure(active_node, 35, previous_status);
		track_pipe_mission : node_sequence(active_node, 36, previous_status, 71, previous_node);
		waypoint_mission : node_sequence(active_node, 37, previous_status, 95, previous_node);
		loiter_task : node_set_blackboard_variables(active_node, 38, loiter_task_SET_status);
		loiter_task_SET_status : loiter_task_SET_status_module(active_node, 38, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		battery_check : node_selector(active_node, 39, previous_status, 41, previous_node);
		battery_low_fs : node_check_blackboard_variable_value(active_node, 40, blackboard, 1, battery_low_fs_CHECK_battery_low_warning);
		battery_low_fs_CHECK_battery_low_warning : battery_low_fs_CHECK_battery_low_warning_module(active_node, 40, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task : node_set_blackboard_variables(active_node, 41, surface_task_SET_status);
		surface_task_SET_status : surface_task_SET_status_module(active_node, 41, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		sensor_failure_selector : node_selector(active_node, 42, previous_status, 44, previous_node);
		check_sensor_failure : node_check_blackboard_variable_value(active_node, 43, blackboard, 22, check_sensor_failure_CHECK_bb_sensor_failure_warning);
		check_sensor_failure_CHECK_bb_sensor_failure_warning : check_sensor_failure_CHECK_bb_sensor_failure_warning_module(active_node, 43, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task1 : node_set_blackboard_variables(active_node, 44, surface_task1_SET_status);
		surface_task1_SET_status : surface_task1_SET_status_module(active_node, 44, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		emergency_stop_check : node_selector(active_node, 45, previous_status, 47, previous_node);
		emergency_stop_fs : node_check_blackboard_variable_value(active_node, 46, blackboard, 39, emergency_stop_fs_CHECK_emergency_stop_warning);
		emergency_stop_fs_CHECK_emergency_stop_warning : emergency_stop_fs_CHECK_emergency_stop_warning_module(active_node, 46, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		emergency_stop_tasks : node_sequence(active_node, 47, previous_status, 49, previous_node);
		emergency_stop_task : node_set_blackboard_variables(active_node, 48, emergency_stop_task_SET_status);
		emergency_stop_task_SET_status : emergency_stop_task_SET_status_module(active_node, 48, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task2 : node_set_blackboard_variables(active_node, 49, surface_task2_SET_status);
		surface_task2_SET_status : surface_task2_SET_status_module(active_node, 49, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home_reached_selector : node_selector(active_node, 50, previous_status, 52, previous_node);
		check_surface : node_check_blackboard_variable_value(active_node, 51, blackboard, 58, check_surface_CHECK_bb_home_reached);
		check_surface_CHECK_bb_home_reached : check_surface_CHECK_bb_home_reached_module(active_node, 51, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task3 : node_set_blackboard_variables(active_node, 52, surface_task3_SET_status);
		surface_task3_SET_status : surface_task3_SET_status_module(active_node, 52, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		obstacle_standoff_check : node_selector(active_node, 53, previous_status, 55, previous_node);
		obstacle_standoff_fs : node_check_blackboard_variable_value(active_node, 54, blackboard, 33, obstacle_standoff_fs_CHECK_obstacle_standoff_warning);
		obstacle_standoff_fs_CHECK_obstacle_standoff_warning : obstacle_standoff_fs_CHECK_obstacle_standoff_warning_module(active_node, 54, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task4 : node_set_blackboard_variables(active_node, 55, surface_task4_SET_status);
		surface_task4_SET_status : surface_task4_SET_status_module(active_node, 55, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_selector : node_selector(active_node, 56, previous_status, 58, previous_node);
		check_rth : node_check_blackboard_variable_value(active_node, 57, blackboard, 4, check_rth_CHECK_bb_rth_warning);
		check_rth_CHECK_bb_rth_warning : check_rth_CHECK_bb_rth_warning_module(active_node, 57, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_par : node_parallel(active_node, 58, previous_status, 60, previous_node, FALSE, TRUE, next_node_58);
		rth_task : node_set_blackboard_variables(active_node, 59, rth_task_SET_status);
		rth_task_SET_status : rth_task_SET_status_module(active_node, 59, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home2bb : node_set_blackboard_variables(active_node, 60, home2bb_SET_status);
		home2bb_SET_status : home2bb_SET_status_module(active_node, 60, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		geofence_selector : node_selector(active_node, 61, previous_status, 63, previous_node);
		check_geofence : node_check_blackboard_variable_value(active_node, 62, blackboard, 7, check_geofence_CHECK_bb_geofence_warning);
		check_geofence_CHECK_bb_geofence_warning : check_geofence_CHECK_bb_geofence_warning_module(active_node, 62, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_par1 : node_parallel(active_node, 63, previous_status, 65, previous_node, FALSE, TRUE, next_node_63);
		rth_task1 : node_set_blackboard_variables(active_node, 64, rth_task1_SET_status);
		rth_task1_SET_status : rth_task1_SET_status_module(active_node, 64, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home2bb1 : node_set_blackboard_variables(active_node, 65, home2bb1_SET_status);
		home2bb1_SET_status : home2bb1_SET_status_module(active_node, 65, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_lost_selector : node_selector(active_node, 66, previous_status, 68, previous_node);
		check_pipe_post : node_check_blackboard_variable_value(active_node, 67, blackboard, 18, check_pipe_post_CHECK_bb_pipe_lost_warning);
		check_pipe_post_CHECK_bb_pipe_lost_warning : check_pipe_post_CHECK_bb_pipe_lost_warning_module(active_node, 67, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		loiter_task1 : node_set_blackboard_variables(active_node, 68, loiter_task1_SET_status);
		loiter_task1_SET_status : loiter_task1_SET_status_module(active_node, 68, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		is_track_pipe_mission_requested : node_check_blackboard_variable_value(active_node, 69, blackboard, 20, is_track_pipe_mission_requested_CHECK_bb_mission_dot_data);
		is_track_pipe_mission_requested_CHECK_bb_mission_dot_data : is_track_pipe_mission_requested_CHECK_bb_mission_dot_data_module(active_node, 69, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		tracking : node_parallel(active_node, 70, previous_status, 74, previous_node, FALSE, TRUE, next_node_70);
		track_pipe_mission_end : node_sequence(active_node, 71, previous_status, 93, previous_node);
		tracking_task : node_set_blackboard_variables(active_node, 72, tracking_task_SET_status);
		tracking_task_SET_status : tracking_task_SET_status_module(active_node, 72, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_speed_cmd : node_selector(active_node, 73, previous_status, 77, previous_node);
		lec2am_mapping_cmd : node_selector(active_node, 74, previous_status, 86, previous_node);
		lec2am_l_speed_check_SIF : decorator_success_is_failure(active_node, 75, previous_status);
		lec2am_r_speed_check_SIF : decorator_success_is_failure(active_node, 76, previous_status);
		speed_max_task : node_set_blackboard_variables(active_node, 77, speed_max_task_SET_status);
		speed_max_task_SET_status : speed_max_task_SET_status_module(active_node, 77, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_l_speed_check : node_selector(active_node, 78, previous_status, 80, previous_node);
		check_lec2am_ls : node_check_blackboard_variable_value(active_node, 79, blackboard, 14, check_lec2am_ls_CHECK_lec2_am_l_speed_warning);
		check_lec2am_ls_CHECK_lec2_am_l_speed_warning : check_lec2am_ls_CHECK_lec2_am_l_speed_warning_module(active_node, 79, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		speed_min_task : node_set_blackboard_variables(active_node, 80, speed_min_task_SET_status);
		speed_min_task_SET_status : speed_min_task_SET_status_module(active_node, 80, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_r_speed_check : node_selector(active_node, 81, previous_status, 83, previous_node);
		check_lec2am_rs : node_check_blackboard_variable_value(active_node, 82, blackboard, 10, check_lec2am_rs_CHECK_lec2_am_r_speed_warning);
		check_lec2am_rs_CHECK_lec2_am_r_speed_warning : check_lec2am_rs_CHECK_lec2_am_r_speed_warning_module(active_node, 82, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		speed_min_task1 : node_set_blackboard_variables(active_node, 83, speed_min_task1_SET_status);
		speed_min_task1_SET_status : speed_min_task1_SET_status_module(active_node, 83, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_l_mapping_check_SIF : decorator_success_is_failure(active_node, 84, previous_status);
		lec2am_r_mapping_check_SIF : decorator_success_is_failure(active_node, 85, previous_status);
		pipe_mapping_enable_task : node_set_blackboard_variables(active_node, 86, pipe_mapping_enable_task_SET_status);
		pipe_mapping_enable_task_SET_status : pipe_mapping_enable_task_SET_status_module(active_node, 86, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_l_mapping_check : node_selector(active_node, 87, previous_status, 89, previous_node);
		check_lec2am_lp : node_check_blackboard_variable_value(active_node, 88, blackboard, 15, check_lec2am_lp_CHECK_lec2_am_l_pipe_warning);
		check_lec2am_lp_CHECK_lec2_am_l_pipe_warning : check_lec2am_lp_CHECK_lec2_am_l_pipe_warning_module(active_node, 88, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_mapping_disable_task : node_set_blackboard_variables(active_node, 89, pipe_mapping_disable_task_SET_status);
		pipe_mapping_disable_task_SET_status : pipe_mapping_disable_task_SET_status_module(active_node, 89, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2am_r_mapping_check : node_selector(active_node, 90, previous_status, 92, previous_node);
		check_lec2am_rp : node_check_blackboard_variable_value(active_node, 91, blackboard, 11, check_lec2am_rp_CHECK_lec2_am_r_pipe_warning);
		check_lec2am_rp_CHECK_lec2_am_r_pipe_warning : check_lec2am_rp_CHECK_lec2_am_r_pipe_warning_module(active_node, 91, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_mapping_disable_task1 : node_set_blackboard_variables(active_node, 92, pipe_mapping_disable_task1_SET_status);
		pipe_mapping_disable_task1_SET_status : pipe_mapping_disable_task1_SET_status_module(active_node, 92, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		evaluate : node_timer(active_node, 93);
		is_waypoint_requested : node_check_blackboard_variable_value(active_node, 94, blackboard, 20, is_waypoint_requested_CHECK_bb_mission_dot_data);
		is_waypoint_requested_CHECK_bb_mission_dot_data : is_waypoint_requested_CHECK_bb_mission_dot_data_module(active_node, 94, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoint_selector : node_selector(active_node, 95, previous_status, 97, previous_node);
		waypoints_sif_SIF : decorator_success_is_failure(active_node, 96, previous_status);
		waypoint_task : node_set_blackboard_variables(active_node, 97, waypoint_task_SET_status);
		waypoint_task_SET_status : waypoint_task_SET_status_module(active_node, 97, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoints_sif : node_selector(active_node, 98, previous_status, 100, previous_node);
		check_waypoints_completed : node_check_blackboard_variable_value(active_node, 99, blackboard, 25, check_waypoints_completed_CHECK_bb_waypoints_completed_dot_data);
		check_waypoints_completed_CHECK_bb_waypoints_completed_dot_data : check_waypoints_completed_CHECK_bb_waypoints_completed_dot_data_module(active_node, 99, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoint_end : node_sequence(active_node, 100, previous_status, 102, previous_node);
		next_mission : node_set_blackboard_variables(active_node, 101, next_mission_SET_status);
		next_mission_SET_status : next_mission_SET_status_module(active_node, 101, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		loiter_task2 : node_set_blackboard_variables(active_node, 102, loiter_task2_SET_status);
		loiter_task2_SET_status : loiter_task2_SET_status_module(active_node, 102, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		variable_names : define_variables;
		node_names : define_nodes;
		blackboard : blackboard_module(active_node, node_names, variable_names, previous_status);
	ASSIGN
		init(active_node) := -1;
		init(previous_node) := -1;
		init(previous_status) := invalid;
		init(resume_status_5) := 5;
		next(resume_status_5 ) := 
			case
				(resume_status_5= 5) & (previous_node in {49, 93, 95, 101, 102, 5}) & (previous_status = running) : previous_node;
				(previous_node = 5) & (previous_status = success | previous_status = failure) : 5;
				 (previous_node in {49, 93, 95, 101, 102, 5}) & (previous_status = success | previous_status = failure) : 5;
				(previous_node = parents[5]) & (previous_status = failure | previous_status = success) : 5;
				(previous_node = 0) & (previous_status = failure | previous_status = success) : 5;
				TRUE : resume_status_5;
			esac;
		next(previous_node) :=
			case
				(active_node < 0) : -1;
				TRUE : active_node;
			esac;
		next(previous_status) :=
			case
				(active_node < 0) : invalid;
				TRUE : statuses[active_node];
			esac;
		next(active_node) :=
			case
				(active_node = -2) : -2;
				(active_node = -1) : 0;
				TRUE : next_node[active_node];
			esac;
-------------------------------------------------------------------------------------
LTLSPEC G (!(active_node = -2));
--we never enter the error state.

LTLSPEC (active_node = -1) U (active_node = 1);
--this should fail, obvious

LTLSPEC (active_node = -1) U (active_node = 0);
--this should succeed, but only because the root node is parallel, therefore we can't ever skip over it by resuming a run.

-------------------------------------------------------------------------------------

LTLSPEC G( (blackboard.variables[variable_names.battery_low_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)
--pretty sure this is false, because we can set battery, enter surface task, leave (global triggers now), go to -1, unset battery, and never re-enter surface.

LTLSPEC G( (blackboard.variables[variable_names.battery_low_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

LTLSPEC G( ((blackboard.variables[variable_names.battery_low_warning] = 1) & (previous_node = node_names.battery2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.battery_low_warning] = 1) & (previous_node = node_names.battery2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should be true.

-------------------------------------------------------------------------------------

LTLSPEC G( (blackboard.variables[variable_names.bb_sensor_failure_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)
--this one is true, because we can't unset the warning, unlike battery.


LTLSPEC G( (blackboard.variables[variable_names.bb_sensor_failure_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

LTLSPEC G( ((blackboard.variables[variable_names.bb_sensor_failure_warning] = 1) & (previous_node = node_names.sensor_failure2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task1)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.bb_sensor_failure_warning] = 1) & (previous_node = node_names.sensor_failure2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should be true.

-------------------------------------------------------------------------------------

LTLSPEC G( (blackboard.variables[variable_names.emergency_stop_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)
--this one is true, because we can't unset the warning, unlike battery.


LTLSPEC G( (blackboard.variables[variable_names.emergency_stop_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

LTLSPEC G( ((blackboard.variables[variable_names.emergency_stop_warning] = 1) & (previous_node in {node_names.fls_warning2bb, node_names.rtreach2bb, node_names.mission_server}))  -> (((active_node > -1))  U (active_node = node_names.surface_task2)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.emergency_stop_warning] = 1) & (previous_node in {node_names.fls_warning2bb, node_names.rtreach2bb, node_names.mission_server}))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should be true.

-------------------------------------------------------------------------------------

LTLSPEC G( (blackboard.variables[variable_names.bb_home_reached] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)
--this one is true, because we can't unset the warning, unlike battery.


LTLSPEC G( (blackboard.variables[variable_names.bb_home_reached] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

LTLSPEC G( ((blackboard.variables[variable_names.bb_home_reached] = 1) & (previous_node in {node_names.home2bb, node_names.home2bb1}))  -> (((active_node > -1))  U (active_node = node_names.surface_task3)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.bb_home_reached] = 1) & (previous_node in {node_names.home2bb, node_names.home2bb1}))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should is false, unlike the rest. this is because we set bb_home_reached after checking the relevant task.

-------------------------------------------------------------------------------------

LTLSPEC G( (blackboard.variables[variable_names.obstacle_standoff_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)
--this one is true, because we can't unset the warning, unlike battery.


LTLSPEC G( (blackboard.variables[variable_names.obstacle_standoff_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

LTLSPEC G( ((blackboard.variables[variable_names.obstacle_standoff_warning] = 1) & (previous_node = node_names.fls2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task4)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.obstacle_standoff_warning] = 1) & (previous_node = node_names.fls2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should be true.

-------------------------------------------------------------------------------------



CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--should be true. there's always a way to avoid surfacing. (until we introduce some specs that force battery to eventually decrease or something).

CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--this is the same as above, except inverted. it says we will always surface. should be false.

-------------------------------------------------------------------------------------
--this is a set of ctlspecs that i was using to debug an error in the model.
--ignore truth values attached.

--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--does surface task always have to trigger?

--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));

--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));

--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));


--CTLSPEC EG((active_node in {node_names.surface_task4})); --FALSE --this was probably should have been EF
--LTLSPEC G(!(active_node = node_names.surface_task4)); --TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = 1); -- TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = 0); -- TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = -1); -- TRUE

--CTLSPEC EF(active_node = node_names.obstacle_standoff_fs); -- FALSE (5)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_fs)); --TRUE (5)
--so we literally never enter the obstacle_standoff_fs. time to check if we reach the node above it.
--CTLSPEC EF(active_node = node_names.obstacle_standoff_check); --FALSE (6)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_check)); --TRUE (6)

--CTLSPEC EF(active_node = node_names.obstacle_standoff_check_SIF); --FALSE (7)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_check_SIF)); --TRUE (7)
--ok, that's the end of that tree, can't reach that whole area. gonna check if home_reached_selector, the branch before it, can be reached


--CTLSPEC EF(active_node = node_names.home_reached_selector_SIF); --TRUE (8)
--CTLSPEC AG(!(active_node = node_names.home_reached_selector_SIF)); --FALSE (8)
--yup, previous one is reachable.

-------------------------------------------------------------------------------------

MODULE node_parallel(active_node, id, previous_status, last_child, previous_node, synchronized, parallel_policy_all, resumer)
	DEFINE
		status :=
			case
				(id = active_node) & (resumer > id) : invalid;
				(id = active_node) & ((cur_status = failure) | (previous_status = failure)) : failure;
				(id = active_node) & (cur_status = running) & (previous_status = running) : running;
				(id = active_node) & !(parallel_policy_all) : success;
				(id = active_node) & (cur_status = success) & (previous_status = success) : success;
				(id = active_node) : running;
				TRUE : invalid;
			esac;
	VAR
		cur_status : {failure, running, success};
	ASSIGN
		init(cur_status) :=
			case
				(parallel_policy_all) : success;
				TRUE : running;
			esac;
		next(cur_status) :=
			case
				(id = active_node) & ((previous_status = failure) | (cur_status = failure)) : failure;
				(id = active_node) & (parallel_policy_all) & (previous_status = success) : cur_status;
				(id = active_node) & (parallel_policy_all) & (previous_status = running) : running;
				(id = active_node) & !(parallel_policy_all) & (previous_status = success) : success;
				(id = active_node) & !(parallel_policy_all) & (previous_status = running) : cur_status;
				(active_node = -1) & synchronized & (parallel_policy_all) & !(previous_status = running) : success;
				(active_node = -1) & synchronized & !(parallel_policy_all) & !(previous_status = running) : running;
				(active_node = -1) & !(synchronized) & (parallel_policy_all) : success;
				(active_node = -1) & !(synchronized) & !(parallel_policy_all) : running;
				TRUE : cur_status;
			esac;
MODULE node_set_blackboard_variables(active_node, id, status_module)
	DEFINE
		status := status_module.status;
MODULE node_selector(active_node, id, previous_status, last_child, previous_node)
	DEFINE
		status :=
			case
				(id = active_node) & (previous_status = invalid) : invalid;
				(id = active_node) & (previous_status = running) : running;
				(id = active_node) & (previous_status = success) : success;
				(id = active_node) & (last_child = previous_node) : failure;
				(id = active_node) : invalid;
				TRUE : invalid;
			esac;
MODULE decorator_success_is_failure(active_node, id, previous_status)
	DEFINE
		status :=
			case
				(id = active_node) & !(previous_status = success) : previous_status;
				(id = active_node) & (previous_status = success) : failure;
				TRUE : invalid;
			esac;
MODULE node_check_blackboard_variable_value(active_node, id, blackboard, variable, check)
	DEFINE
		status :=
			case
				(id = active_node) & !(blackboard.variable_exists[variable]) : failure;
				(id = active_node) & (blackboard.variable_exists[variable]) & (check.result) : success;
				(id = active_node) & (blackboard.variable_exists[variable]) & !(check.result) : failure;
				TRUE : invalid;
			esac;
MODULE node_sequence(active_node, id, previous_status, last_child, previous_node)
	DEFINE
		status :=
			case
				(id = active_node) & (previous_status = invalid) : invalid;
				(id = active_node) & (previous_status = running) : running;
				(id = active_node) & (previous_status = failure) : failure;
				(id = active_node) & (last_child = previous_node) : success;
				(id = active_node) : invalid;
				TRUE : invalid;
			esac;
MODULE node_timer(active_node, id)
	DEFINE
		status :=
			case
				(id = active_node) : {success, running};
				TRUE : invalid;
			esac;
MODULE define_variables
	DEFINE
		battery := 0;
		battery_low_warning := 1;
		battery_dot_batt_charge_remaining := 2;
		bb_rth := 3;
		bb_rth_warning := 4;
		bb_rth_dot_data := 5;
		bb_geofence := 6;
		bb_geofence_warning := 7;
		bb_geofence_dot_data := 8;
		lec2_am_r := 9;
		lec2_am_r_speed_warning := 10;
		lec2_am_r_pipe_warning := 11;
		lec2_am_r_dot_confs := 12;
		lec2_am_l := 13;
		lec2_am_l_speed_warning := 14;
		lec2_am_l_pipe_warning := 15;
		lec2_am_l_dot_confs := 16;
		bb_pipelost := 17;
		bb_pipe_lost_warning := 18;
		bb_pipelost_dot_data := 19;
		bb_mission_dot_data := 20;
		bb_sensor_failure := 21;
		bb_sensor_failure_warning := 22;
		bb_sensor_failure_dot_data := 23;
		bb_waypoints_completed := 24;
		bb_waypoints_completed_dot_data := 25;
		bb_mission := 26;
		dd_output := 27;
		dd_z_axis_warning := 28;
		dd_xy_axis_degradation := 29;
		dd_output_dot_data := 30;
		total_degradation := 31;
		fls_range := 32;
		obstacle_standoff_warning := 33;
		obstacle_min_standoff := 34;
		fls_range_dot_range := 35;
		obstacle_in_view := 36;
		bb_fls_warning := 37;
		obstacle_in_view_dot_stamp := 38;
		emergency_stop_warning := 39;
		hsd_pipeline_mapping := 40;
		hsd_to_waypoint := 41;
		hsd_to_rth := 42;
		hsd_to_surface := 43;
		rtreach_out := 44;
		rtreach_out_dot_data := 45;
		HSD_out_dot_heading := 46;
		uuv_max_speed := 47;
		mission_file := 48;
		refLat := 49;
		refLon := 50;
		next_mission := 51;
		decision_threshold := 52;
		HSD_out := 53;
		bb_obstacle_warning := 54;
		cm_hsd_input := 55;
		HSD_out_dot_speed := 56;
		HSD_out_dot_depth := 57;
		bb_home_reached := 58;
		bb_home_dist := 59;
		bb_home_dist_dot_data := 60;
		pipe_mapping_enable := 61;
MODULE define_nodes
	DEFINE
		BlueROV := 0;
		topics2bb := 1;
		dd_tasks := 2;
		mission_server := 3;
		obstacle_avoidance := 4;
		priorities := 5;
		battery2bb := 6;
		rth2bb := 7;
		geofence2bb := 8;
		lec2_am_r_2bb := 9;
		lec2_am_l_2bb := 10;
		pipe_lost2bb := 11;
		sensor_failure2bb := 12;
		waypoints_completed2bb := 13;
		mission2bb := 14;
		ddlec2bb := 15;
		fls2bb := 16;
		fls_warning2bb := 17;
		hsd_pipe2bb := 18;
		hsd_wp2bb := 19;
		hsd_rth2bb := 20;
		hsd_surface2bb := 21;
		rtreach2bb := 22;
		reallocate_check_SIF := 23;
		dd_lec_task := 24;
		reallocate_check := 25;
		is_reallocation_requested := 26;
		reallocate_task := 27;
		battery_check_SIF := 28;
		sensor_failure_selector_SIF := 29;
		emergency_stop_check_SIF := 30;
		home_reached_selector_SIF := 31;
		obstacle_standoff_check_SIF := 32;
		rth_selector_SIF := 33;
		geofence_selector_SIF := 34;
		pipe_lost_selector_SIF := 35;
		track_pipe_mission := 36;
		waypoint_mission := 37;
		loiter_task := 38;
		battery_check := 39;
		battery_low_fs := 40;
		surface_task := 41;
		sensor_failure_selector := 42;
		check_sensor_failure := 43;
		surface_task1 := 44;
		emergency_stop_check := 45;
		emergency_stop_fs := 46;
		emergency_stop_tasks := 47;
		emergency_stop_task := 48;
		surface_task2 := 49;
		home_reached_selector := 50;
		check_surface := 51;
		surface_task3 := 52;
		obstacle_standoff_check := 53;
		obstacle_standoff_fs := 54;
		surface_task4 := 55;
		rth_selector := 56;
		check_rth := 57;
		rth_par := 58;
		rth_task := 59;
		home2bb := 60;
		geofence_selector := 61;
		check_geofence := 62;
		rth_par1 := 63;
		rth_task1 := 64;
		home2bb1 := 65;
		pipe_lost_selector := 66;
		check_pipe_post := 67;
		loiter_task1 := 68;
		is_track_pipe_mission_requested := 69;
		tracking := 70;
		track_pipe_mission_end := 71;
		tracking_task := 72;
		lec2am_speed_cmd := 73;
		lec2am_mapping_cmd := 74;
		lec2am_l_speed_check_SIF := 75;
		lec2am_r_speed_check_SIF := 76;
		speed_max_task := 77;
		lec2am_l_speed_check := 78;
		check_lec2am_ls := 79;
		speed_min_task := 80;
		lec2am_r_speed_check := 81;
		check_lec2am_rs := 82;
		speed_min_task1 := 83;
		lec2am_l_mapping_check_SIF := 84;
		lec2am_r_mapping_check_SIF := 85;
		pipe_mapping_enable_task := 86;
		lec2am_l_mapping_check := 87;
		check_lec2am_lp := 88;
		pipe_mapping_disable_task := 89;
		lec2am_r_mapping_check := 90;
		check_lec2am_rp := 91;
		pipe_mapping_disable_task1 := 92;
		evaluate := 93;
		is_waypoint_requested := 94;
		waypoint_selector := 95;
		waypoints_sif_SIF := 96;
		waypoint_task := 97;
		waypoints_sif := 98;
		check_waypoints_completed := 99;
		waypoint_end := 100;
		next_mission := 101;
		loiter_task2 := 102;
--battery : 0
----battery2bb
--battery_low_warning : 1
----battery2bb
--battery_dot_batt_charge_remaining : 2
----battery2bb
--bb_rth : 3
----rth2bb
--bb_rth_warning : 4
----rth2bb
----mission_server
--bb_rth_dot_data : 5
----rth2bb
--bb_geofence : 6
----geofence2bb
--bb_geofence_warning : 7
----geofence2bb
--bb_geofence_dot_data : 8
----geofence2bb
--lec2_am_r : 9
----lec2_am_r_2bb
--lec2_am_r_speed_warning : 10
----lec2_am_r_2bb
--lec2_am_r_pipe_warning : 11
----lec2_am_r_2bb
--lec2_am_r_dot_confs : 12
----lec2_am_r_2bb
--lec2_am_l : 13
----lec2_am_l_2bb
--lec2_am_l_speed_warning : 14
----lec2_am_l_2bb
--lec2_am_l_pipe_warning : 15
----lec2_am_l_2bb
--lec2_am_l_dot_confs : 16
----lec2_am_l_2bb
--bb_pipelost : 17
----pipe_lost2bb
--bb_pipe_lost_warning : 18
----pipe_lost2bb
--bb_pipelost_dot_data : 19
----pipe_lost2bb
--bb_mission_dot_data : 20
----pipe_lost2bb
----mission2bb
----mission_server
--bb_sensor_failure : 21
----sensor_failure2bb
--bb_sensor_failure_warning : 22
----sensor_failure2bb
--bb_sensor_failure_dot_data : 23
----sensor_failure2bb
--bb_waypoints_completed : 24
----waypoints_completed2bb
--bb_waypoints_completed_dot_data : 25
----waypoints_completed2bb
--bb_mission : 26
----mission2bb
--dd_output : 27
----ddlec2bb
--dd_z_axis_warning : 28
----ddlec2bb
--dd_xy_axis_degradation : 29
----ddlec2bb
----reallocate_task
--dd_output_dot_data : 30
----ddlec2bb
----reallocate_task
--total_degradation : 31
----ddlec2bb
----reallocate_task
--fls_range : 32
----fls2bb
--obstacle_standoff_warning : 33
----fls2bb
--obstacle_min_standoff : 34
----fls2bb
----mission_server
--fls_range_dot_range : 35
----fls2bb
--obstacle_in_view : 36
----fls_warning2bb
--bb_fls_warning : 37
----fls_warning2bb
--obstacle_in_view_dot_stamp : 38
----fls_warning2bb
--emergency_stop_warning : 39
----fls_warning2bb
----rtreach2bb
----mission_server
--hsd_pipeline_mapping : 40
----hsd_pipe2bb
--hsd_to_waypoint : 41
----hsd_wp2bb
--hsd_to_rth : 42
----hsd_rth2bb
--hsd_to_surface : 43
----hsd_surface2bb
--rtreach_out : 44
----rtreach2bb
--rtreach_out_dot_data : 45
----rtreach2bb
--HSD_out_dot_heading : 46
----reallocate_task
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----tracking_task
----speed_min_task
----speed_min_task1
----speed_max_task
----loiter_task2
----waypoint_task
----loiter_task
--uuv_max_speed : 47
----mission_server
----speed_max_task
--mission_file : 48
----mission_server
--refLat : 49
----mission_server
--refLon : 50
----mission_server
--next_mission : 51
----mission_server
----next_mission
--decision_threshold : 52
----mission_server
--HSD_out : 53
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----tracking_task
----speed_min_task
----speed_min_task1
----speed_max_task
----loiter_task2
----waypoint_task
----loiter_task
--bb_obstacle_warning : 54
----obstacle_avoidance
--cm_hsd_input : 55
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----tracking_task
----loiter_task2
----waypoint_task
----loiter_task
--HSD_out_dot_speed : 56
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----tracking_task
----speed_min_task
----speed_min_task1
----speed_max_task
----loiter_task2
----waypoint_task
----loiter_task
--HSD_out_dot_depth : 57
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----tracking_task
----speed_min_task
----speed_min_task1
----speed_max_task
----loiter_task2
----waypoint_task
----loiter_task
--bb_home_reached : 58
----home2bb
----home2bb1
--bb_home_dist : 59
----home2bb
----home2bb1
--bb_home_dist_dot_data : 60
----home2bb
----home2bb1
--pipe_mapping_enable : 61
----pipe_mapping_disable_task
----pipe_mapping_disable_task1
----pipe_mapping_enable_task
MODULE blackboard_module(active_node, node_names, variable_names, previous_status)
	DEFINE
		variables := [battery, battery_low_warning, battery_dot_batt_charge_remaining, bb_rth, bb_rth_warning, bb_rth_dot_data, bb_geofence, bb_geofence_warning, bb_geofence_dot_data, lec2_am_r, lec2_am_r_speed_warning, lec2_am_r_pipe_warning, lec2_am_r_dot_confs, lec2_am_l, lec2_am_l_speed_warning, lec2_am_l_pipe_warning, lec2_am_l_dot_confs, bb_pipelost, bb_pipe_lost_warning, bb_pipelost_dot_data, bb_mission_dot_data, bb_sensor_failure, bb_sensor_failure_warning, bb_sensor_failure_dot_data, bb_waypoints_completed, bb_waypoints_completed_dot_data, bb_mission, dd_output, dd_z_axis_warning, dd_xy_axis_degradation, dd_output_dot_data, total_degradation, fls_range, obstacle_standoff_warning, obstacle_min_standoff, fls_range_dot_range, obstacle_in_view, bb_fls_warning, obstacle_in_view_dot_stamp, emergency_stop_warning, hsd_pipeline_mapping, hsd_to_waypoint, hsd_to_rth, hsd_to_surface, rtreach_out, rtreach_out_dot_data, HSD_out_dot_heading, uuv_max_speed, mission_file, refLat, refLon, next_mission, decision_threshold, HSD_out, bb_obstacle_warning, cm_hsd_input, HSD_out_dot_speed, HSD_out_dot_depth, bb_home_reached, bb_home_dist, bb_home_dist_dot_data, pipe_mapping_enable];
		variable_exists := [battery_exists, battery_low_warning_exists, battery_dot_batt_charge_remaining_exists, bb_rth_exists, bb_rth_warning_exists, bb_rth_dot_data_exists, bb_geofence_exists, bb_geofence_warning_exists, bb_geofence_dot_data_exists, lec2_am_r_exists, lec2_am_r_speed_warning_exists, lec2_am_r_pipe_warning_exists, lec2_am_r_dot_confs_exists, lec2_am_l_exists, lec2_am_l_speed_warning_exists, lec2_am_l_pipe_warning_exists, lec2_am_l_dot_confs_exists, bb_pipelost_exists, bb_pipe_lost_warning_exists, bb_pipelost_dot_data_exists, bb_mission_dot_data_exists,  bb_sensor_failure_exists, bb_sensor_failure_warning_exists, bb_sensor_failure_dot_data_exists, bb_waypoints_completed_exists, bb_waypoints_completed_dot_data_exists, bb_mission_exists, dd_output_exists, dd_z_axis_warning_exists, dd_xy_axis_degradation_exists, dd_output_dot_data_exists, total_degradation_exists, fls_range_exists, obstacle_standoff_warning_exists, obstacle_min_standoff_exists, fls_range_dot_range_exists, obstacle_in_view_exists, bb_fls_warning_exists, obstacle_in_view_dot_stamp_exists, emergency_stop_warning_exists, hsd_pipeline_mapping_exists, hsd_to_waypoint_exists, hsd_to_rth_exists, hsd_to_surface_exists, rtreach_out_exists, rtreach_out_dot_data_exists, HSD_out_dot_heading_exists, uuv_max_speed_exists, mission_file_exists, refLat_exists, refLon_exists, next_mission_exists, decision_threshold_exists, HSD_out_exists, bb_obstacle_warning_exists, cm_hsd_input_exists, HSD_out_dot_speed_exists, HSD_out_dot_depth_exists, bb_home_reached_exists, bb_home_dist_exists, bb_home_dist_dot_data_exists, pipe_mapping_enable_exists];
		battery_exists := TRUE;
		battery_low_warning_exists := TRUE;
		battery_dot_batt_charge_remaining_exists := TRUE;
		bb_rth_exists := TRUE;
		bb_rth_warning_exists := TRUE;
		bb_rth_dot_data_exists := TRUE;
		bb_geofence_exists := TRUE;
		bb_geofence_warning_exists := TRUE;
		bb_geofence_dot_data_exists := TRUE;
		lec2_am_r_exists := TRUE;
		lec2_am_r_speed_warning_exists := TRUE;
		lec2_am_r_pipe_warning_exists := TRUE;
		lec2_am_r_dot_confs_exists := TRUE;
		lec2_am_l_exists := TRUE;
		lec2_am_l_speed_warning_exists := TRUE;
		lec2_am_l_pipe_warning_exists := TRUE;
		lec2_am_l_dot_confs_exists := TRUE;
		bb_pipelost_exists := TRUE;
		bb_pipe_lost_warning_exists := TRUE;
		bb_pipelost_dot_data_exists := TRUE;
		bb_mission_dot_data_exists := TRUE;
		bb_pipe_lost_dot_data_exists := TRUE;
		bb_sensor_failure_exists := TRUE;
		bb_sensor_failure_warning_exists := TRUE;
		bb_sensor_failure_dot_data_exists := TRUE;
		bb_waypoints_completed_exists := TRUE;
		bb_waypoints_completed_dot_data_exists := TRUE;
		bb_mission_exists := TRUE;
		dd_output_exists := TRUE;
		dd_z_axis_warning_exists := TRUE;
		dd_xy_axis_degradation_exists := TRUE;
		dd_output_dot_data_exists := TRUE;
		total_degradation_exists := TRUE;
		fls_range_exists := TRUE;
		obstacle_standoff_warning_exists := TRUE;
		obstacle_min_standoff_exists := TRUE;
		fls_range_dot_range_exists := TRUE;
		obstacle_in_view_exists := TRUE;
		bb_fls_warning_exists := TRUE;
		obstacle_in_view_dot_stamp_exists := TRUE;
		emergency_stop_warning_exists := TRUE;
		hsd_pipeline_mapping_exists := TRUE;
		hsd_to_waypoint_exists := TRUE;
		hsd_to_rth_exists := TRUE;
		hsd_to_surface_exists := TRUE;
		rtreach_out_exists := TRUE;
		rtreach_out_dot_data_exists := TRUE;
		HSD_out_dot_heading_exists := TRUE;
		uuv_max_speed_exists := TRUE;
		mission_file_exists := TRUE;
		refLat_exists := TRUE;
		refLon_exists := TRUE;
		next_mission_exists := TRUE;
		decision_threshold_exists := TRUE;
		HSD_out_exists := TRUE;
		bb_obstacle_warning_exists := TRUE;
		cm_hsd_input_exists := TRUE;
		HSD_out_dot_speed_exists := TRUE;
		HSD_out_dot_depth_exists := TRUE;
		bb_home_reached_exists := TRUE;
		bb_home_dist_exists := TRUE;
		bb_home_dist_dot_data_exists := TRUE;
		pipe_mapping_enable_exists := TRUE;
		--
		--
		--
		task_mission_server_mission_len := 3;--must be >=1
		task_mission_server_mission_type_list := [mission_type_0, mission_type_1, mission_type_1];--list of missions here.
		task_mission_server_mission_distance_list := [mission_distance_0, mission_distance_1, mission_distance_2];--list of min distances here. between 0 and 2 for each value
		mission_type_path_following := 0;
		mission_type_waypoint_following := 1;
		mission_type_e_stop := 2;
		mission_type_pipe_following := 3;
		mission_type_unknown := 4;
		--
		total_degradation_threshold := 0;
		--
		heading_default := 0;
		heading_surface := 1;
		heading_rth := 2;
		heading_loiter := 3;--this value explicitly listed as 30 in loiter tasks, unlike the other ones which i have no idea what they are.
		heading_pipeline_mapping := 4;
		heading_waypoint := 5;
		--
		home_reached_threshold := 1;
		name_default := 0;
		name_surface_task := 1;
		name_rth_task := 2;
		name_loiter_task := 3;
		name_tracking_task := 4;
		name_waypoint_task := 5;
		--
		depth_default := 0;
		depth_surface_task := 1;
		depth_rth_task := 2;
		depth_pipeline_mapping := 3;
		depth_waypoint :=4;
		--
		battery_low_warning :=
			case
				battery_dot_batt_charge_remaining = 0 : 1;
				TRUE : 0;
			esac;
		
		lec2_am_r_speed_warning :=
			case
				(lec2_am_r_dot_confs = 1) | (lec2_am_r_dot_confs = 3) : 1;
				TRUE : 0;
			esac;
		lec2_am_r_pipe_warning :=
			case
				(lec2_am_r_dot_confs = 2) | (lec2_am_r_dot_confs = 3) : 1;
				TRUE : 0;
			esac;
		lec2_am_l_speed_warning :=
			case
				(lec2_am_l_dot_confs = 1) | (lec2_am_l_dot_confs = 3) : 1;
				TRUE : 0;
			esac;
		lec2_am_l_pipe_warning :=
			case
				(lec2_am_l_dot_confs = 2) | (lec2_am_l_dot_confs = 3) : 1;
				TRUE : 0;
			esac;
		battery := 0;--fake variable
		bb_rth := 0;--fake variable
		bb_geofence := 0;--fake variable
		lec2_am_r := 0;
		lec2_am_l := 0;
		bb_pipelost := 0;--fake variable
		bb_sensor_failure := 0;--fake variable
		bb_waypoints_completed := 0;--fake variable
		bb_mission := 0;--fake variable
		dd_output := 0;--fake variable
		fls_range := 0;--fake variable
		obstacle_in_view := 0;--abstraced away
		rtreach_out := 0;--fake variable
		mission_file := 0;--not actually used
		HSD_out := 0;--fake variable
		bb_home_dist := 0;--fake variable
		decision_threshold := 0; --not actually used
		hsd_pipeline_mapping := 0;--unknown
		hsd_to_waypoint := 0;--unknown
		hsd_to_rth := 0;--unknown
		hsd_to_surface := 0;--unknown
		uuv_min_speed := 0;--does not change (frozen var it?)
		uuv_max_speed := 1;--does not change (frozen var it?)
		refLat := 0;--does not change (frozen var it?)
		refLon := 0;--does not change (frozen var it?)
	FROZENVAR
		--mission_type_0 : {mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown};
		--mission_type_1 : {mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown};
		--mission_type_2 : {mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown};
		mission_type_0 : {0, 1, 2, 3, 4};
		mission_type_1 : {0, 1, 2, 3, 4};
		mission_type_2 : {0, 1, 2, 3, 4};
		mission_distance_0 : {0, 1, 2};
		mission_distance_1 : {0, 1, 2};
		mission_distance_2 : {0, 1, 2};
		
	VAR
		task_mission_server_mission_idx : 0..task_mission_server_mission_len;
		--battery : 0..1;
		--battery_low_warning : 0..1;
		battery_dot_batt_charge_remaining : 0..1;
		--bb_rth : 0..1;
		bb_rth_warning : 0..1;
		bb_rth_dot_data : 0..1;
		--bb_geofence : 0..1;
		bb_geofence_warning : 0..1;
		bb_geofence_dot_data : 0..1;
		--lec2_am_r : 0..1;
		--lec2_am_r_speed_warning : 0..1;
		--lec2_am_r_pipe_warning : 0..1;
		lec2_am_r_dot_confs : 0..3;
		--lec2_am_l : 0..1;
		--lec2_am_l_speed_warning : 0..1;
		--lec2_am_l_pipe_warning : 0..1;
		lec2_am_l_dot_confs : 0..3;
		--bb_pipelost : 0..1;
		bb_pipe_lost_warning : 0..1;
		bb_pipelost_dot_data : 0..1;
		--bb_mission_dot_data : {mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown};
		bb_mission_dot_data : {0, 1, 2, 3, 4}; 
		bb_pipe_lost_dot_data : 0..1;
		--bb_sensor_failure : 0..1;
		bb_sensor_failure_warning : 0..1;
		bb_sensor_failure_dot_data : 0..1;
		--bb_waypoints_completed : 0..1;
		bb_waypoints_completed_dot_data : 0..1;
		--bb_mission : 0..1;
		--dd_output : 0..1;
		dd_z_axis_warning : 0..1;
		dd_xy_axis_degradation : 0..1;
		dd_output_dot_data : 0..2;
		total_degradation : 0..1;
		--fls_range : 0..1;
		obstacle_standoff_warning : 0..1;
		obstacle_min_standoff : 0..2;
		fls_range_dot_range : 0..3;
		--obstacle_in_view : 0..1;
		bb_fls_warning : 0..1;
		obstacle_in_view_dot_stamp : 0..1;
		emergency_stop_warning : 0..1;
		--hsd_pipeline_mapping : 0..1;
		--hsd_to_waypoint : 0..1;
		--hsd_to_rth : 0..1;
		--hsd_to_surface : 0..1; --these should maybe be used in the HSD_out variables
		--rtreach_out : 0..1;
		--HSD_out_dot_heading : {heading_default, heading_surface, heading_rth, heading_loiter, heading_pipeline_mapping, heading_waypoint};
		HSD_out_dot_heading : {0, 1, 2, 3, 4, 5};
		rtreach_out_dot_data : 0..1;
		--uuv_max_speed : 0..1;
		--mission_file : 0..1;
		--refLat : 0..1;
		--refLon : 0..1;
		next_mission : 0..1;
		--decision_threshold : 0..1;
		--HSD_out : 0..1;
		bb_obstacle_warning : 0..1;
		--cm_hsd_input : {name_default, name_surface_task, name_rth_task, name_loiter_task, name_tracking_task, name_waypoint_task};
		cm_hsd_input : {0, 1, 2, 3, 4, 5};
		--HSD_out_dot_speed : {uuv_min_speed, uuv_max_speed};
		HSD_out_dot_speed : {0, 1};
		--HSD_out_dot_depth : {depth_default, depth_surface_task, depth_rth_task, depth_pipeline_mapping, depth_waypoint};
		HSD_out_dot_depth : {0, 1, 2, 3, 4};
		bb_home_reached : 0..1;
		--bb_home_dist : 0..1;
		bb_home_dist_dot_data : 0..1;
		pipe_mapping_enable : 0..1;
		
	ASSIGN
		---
		init(task_mission_server_mission_idx) := 0;
		next(task_mission_server_mission_idx) :=
			case
				(active_node = node_names.mission_server) & (next_mission = 1) : min(task_mission_server_mission_idx + 1, task_mission_server_mission_len);
				TRUE : task_mission_server_mission_idx;
			esac;
		---
		init(battery_dot_batt_charge_remaining) := 0;
		next(battery_dot_batt_charge_remaining) := 
			case
				(active_node in {node_names.battery2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : battery_dot_batt_charge_remaining;
			esac;
		init(bb_rth_warning) := 0;
		next(bb_rth_warning) := 
			case
				(bb_rth_warning = 1) : 1; -- can't be unset.
				(active_node = node_names.rth2bb) & (next(previous_status) = success) : next(bb_rth_dot_data);
				(active_node = node_names.mission_server) & (next_mission = 1) & (next(task_mission_server_mission_idx) = task_mission_server_mission_len)  : 1;
				TRUE : bb_rth_warning;
			esac;
		init(bb_rth_dot_data) := 0;
		next(bb_rth_dot_data) := 
			case
				(active_node in {node_names.rth2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_rth_dot_data;
			esac;
		init(bb_geofence_warning) := 0;
		next(bb_geofence_warning) := 
			case
				(bb_geofence_warning = 1) : 1;
				(active_node in {node_names.geofence2bb}) & (next(previous_status) = success) : next(bb_geofence_dot_data);
				TRUE : bb_geofence_warning;
			esac;
		init(bb_geofence_dot_data) := 0;
		next(bb_geofence_dot_data) := 
			case
				(active_node in {node_names.geofence2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_geofence_dot_data;
			esac;
		-- init(lec2_am_r) := 0;
		-- next(lec2_am_r) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_r_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_r;
		-- 	esac;
		-- init(lec2_am_r_speed_warning) := 0;
		-- next(lec2_am_r_speed_warning) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_r_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_r_speed_warning;
		-- 	esac;
		-- init(lec2_am_r_pipe_warning) := 0;
		-- next(lec2_am_r_pipe_warning) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_r_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_r_pipe_warning;
		-- 	esac;
		init(lec2_am_r_dot_confs) := 0; -- 0 means no warning, 1 means speed, 2 means pipe, 3 means both
		next(lec2_am_r_dot_confs) := 
			case
				(active_node in {node_names.lec2_am_r_2bb}) & (next(previous_status) = success) : {0, 1, 2, 3};
				TRUE : lec2_am_r_dot_confs;
			esac;
		-- init(lec2_am_l) := 0;
		-- next(lec2_am_l) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_l_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_l;
		-- 	esac;
		-- init(lec2_am_l_speed_warning) := 0;
		-- next(lec2_am_l_speed_warning) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_l_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_l_speed_warning;
		-- 	esac;
		-- init(lec2_am_l_pipe_warning) := 0;
		-- next(lec2_am_l_pipe_warning) := 
		-- 	case
		-- 		(active_node in {node_names.lec2_am_l_2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : lec2_am_l_pipe_warning;
		-- 	esac;
		init(lec2_am_l_dot_confs) := 0; -- 0 means no warning, 1 means speed, 2 means pipe, 3 means both
		next(lec2_am_l_dot_confs) := 
			case
				(active_node in {node_names.lec2_am_l_2bb}) & (next(previous_status) = success) : {0, 1, 2, 3};
				TRUE : lec2_am_l_dot_confs;
			esac;
		init(bb_pipe_lost_warning) := 0;
		next(bb_pipe_lost_warning) := 
			case
				(bb_pipe_lost_warning = 1) : 1;
				(active_node in {node_names.pipe_lost2bb}) & (next(previous_status) = success) & (bb_mission_dot_data = mission_type_pipe_following) : next(bb_pipe_lost_dot_data);
				TRUE : bb_pipe_lost_warning;
			esac;
		init(bb_pipelost_dot_data) := 0;
		next(bb_pipelost_dot_data) := 
			case
				(active_node in {node_names.pipe_lost2bb}) & (next(previous_status) = success) & (bb_mission_dot_data = mission_type_pipe_following) : {0, 1};
				TRUE : bb_pipelost_dot_data;
			esac;
		init(bb_mission_dot_data) := task_mission_server_mission_type_list[0];
		next(bb_mission_dot_data) := 
			case
				(active_node in {node_names.mission2bb}) & (next(previous_status) = success) : {mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown};--this seems wildly incorrect, but for some reason this is how the tree is setup. it makes negative sense to me.
				(active_node in {node_names.mission_server}) & (next_mission = 1) & (next(task_mission_server_mission_idx) < task_mission_server_mission_len) : task_mission_server_mission_type_list[next(task_mission_server_mission_idx)];
				TRUE : bb_mission_dot_data;
			esac;
		init(bb_pipe_lost_dot_data) := 0;
		next(bb_pipe_lost_dot_data) := 
			case
				(active_node in {node_names.pipe_lost2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_pipe_lost_dot_data;
			esac;
		init(bb_sensor_failure_warning) := 0;
		next(bb_sensor_failure_warning) := 
			case
				(bb_sensor_failure_warning = 1) : 1;
				(active_node in {node_names.sensor_failure2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_sensor_failure_warning;
			esac;
		init(bb_sensor_failure_dot_data) := 0;
		next(bb_sensor_failure_dot_data) := 
			case
				(active_node in {node_names.sensor_failure2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_sensor_failure_dot_data;
			esac;
		init(bb_waypoints_completed_dot_data) := 0;
		next(bb_waypoints_completed_dot_data) := 
			case
				(active_node in {node_names.waypoints_completed2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_waypoints_completed_dot_data;
			esac;
		init(dd_z_axis_warning) := 0;
		next(dd_z_axis_warning) := 
			case
				(active_node in {node_names.ddlec2bb}) & (total_degradation <= total_degradation_threshold) & (next(dd_output_dot_data) = 1) & (next(previous_status) = success) : 1;
				(active_node in {node_names.ddlec2bb}) & ((total_degradation > total_degradation_threshold) | (next(dd_output_dot_data) = 0)) & (next(previous_status) = success) : 0;
				TRUE : dd_z_axis_warning;
			esac;
		init(dd_xy_axis_degradation) := 0;
		next(dd_xy_axis_degradation) := 
			case
				(active_node in {node_names.ddlec2bb}) & (total_degradation <= total_degradation_threshold) & (next(dd_output_dot_data) = 2) & (next(previous_status) = success) : 1;
				(active_node in {node_names.ddlec2bb}) & ((total_degradation > total_degradation_threshold) | (next(dd_output_dot_data) = 0)) & (next(previous_status) = success) : 0;
				TRUE : dd_xy_axis_degradation;
			esac;
		init(dd_output_dot_data) := 0; --0 means nothing, 1 means z, 2 means xy
		next(dd_output_dot_data) := 
			case
				(active_node in {node_names.ddlec2bb, node_names.reallocate_task}) & (next(previous_status) = success) : {0, 1, 2};
				TRUE : dd_output_dot_data;
			esac;
		init(total_degradation) := 0;
		next(total_degradation) := 
			case
				(active_node in {node_names.reallocate_task}) & (dd_xy_axis_degradation = 1) : 1;
				TRUE : total_degradation;
			esac;
		init(obstacle_standoff_warning) := 0;
		next(obstacle_standoff_warning) := 
			case
				(active_node in {node_names.fls2bb}) & (0 < fls_range_dot_range) & (fls_range_dot_range <= obstacle_min_standoff) & (next(previous_status) = success) : 1;--the 0 represents 0.5
				TRUE : obstacle_standoff_warning;
			esac;
		init(obstacle_min_standoff) :=
			case
				(task_mission_server_mission_type_list[0] = mission_type_unknown) : 1;
				TRUE : task_mission_server_mission_distance_list[0];
			esac;
		next(obstacle_min_standoff) := 
			case
				(active_node in {node_names.mission_server}) & (next_mission = 1) & (next(task_mission_server_mission_idx) < task_mission_server_mission_len) : task_mission_server_mission_distance_list[next(task_mission_server_mission_idx)];
				TRUE : obstacle_min_standoff;
			esac;
		init(fls_range_dot_range) := 0;
		next(fls_range_dot_range) := 
			case
				(active_node in {node_names.fls2bb}) & (next(previous_status) = success) : {0, 1, 2, 3};
				TRUE : fls_range_dot_range;
			esac;
		init(bb_fls_warning) := 0;
		next(bb_fls_warning) := 
			case
				(bb_fls_warning = 1) : 1;
				(active_node in {node_names.fls_warning2bb}) & (next(obstacle_in_view_dot_stamp) = 1) & (next(previous_status) = success) : 1;
				TRUE : bb_fls_warning;
			esac;
		init(obstacle_in_view_dot_stamp) := 0;
		next(obstacle_in_view_dot_stamp) := 
			case
				(active_node in {node_names.fls_warning2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : obstacle_in_view_dot_stamp;
			esac;
		init(emergency_stop_warning) :=
			case
				(task_mission_server_mission_type_list[0] = mission_type_e_stop) : 1;
				TRUE : 0;
			esac;
		next(emergency_stop_warning) := 
			case
				(emergency_stop_warning = 1) : 1;
				(active_node in {node_names.fls_warning2bb}) & (next(obstacle_in_view_dot_stamp) = 1) & (next(previous_status) = success) : 1;
				(active_node in {node_names.rtreach2bb}) & (rtreach_out_dot_data < 1) & (next(previous_status) = success) : 1;
				(active_node in {node_names.mission_server}) & (next_mission = 1) & (next(task_mission_server_mission_idx) < task_mission_server_mission_len) & (task_mission_server_mission_type_list[next(task_mission_server_mission_idx)] = mission_type_e_stop) : 1;
				TRUE : emergency_stop_warning;
			esac;
		-- init(hsd_pipeline_mapping) := 0;
		-- next(hsd_pipeline_mapping) := 
		-- 	case
		-- 		(active_node in {node_names.hsd_pipe2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : hsd_pipeline_mapping;
		-- 	esac;
		-- init(hsd_to_waypoint) := 0;
		-- next(hsd_to_waypoint) := 
		-- 	case
		-- 		(active_node in {node_names.hsd_wp2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : hsd_to_waypoint;
		-- 	esac;
		-- init(hsd_to_rth) := 0;
		-- next(hsd_to_rth) := 
		-- 	case
		-- 		(active_node in {node_names.hsd_rth2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : hsd_to_rth;
		-- 	esac;
		-- init(hsd_to_surface) := 0;
		-- next(hsd_to_surface) := 
		-- 	case
		-- 		(active_node in {node_names.hsd_surface2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : hsd_to_surface;
		-- 	esac;
		-- init(rtreach_out) := 0;
		-- next(rtreach_out) := 
		-- 	case
		-- 		(active_node in {node_names.rtreach2bb}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : rtreach_out;
		-- 	esac;
		init(rtreach_out_dot_data) := 1;
		next(rtreach_out_dot_data) := 
			case
				(active_node in {node_names.rtreach2bb}) & (next(previous_status) = success) : {0, 1};
				TRUE : rtreach_out_dot_data;
			esac;
		init(HSD_out_dot_heading) := heading_default;
		next(HSD_out_dot_heading) := 
			case
				--(active_node in {node_names.reallocate_task, node_names.obstacle_avoidance, node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4, node_names.rth_task, node_names.rth_task1, node_names.loiter_task1, node_names.tracking_task, node_names.speed_min_task, node_names.speed_min_task1, node_names.speed_max_task, node_names.loiter_task2, node_names.waypoint_task, node_names.loiter_task}) & (next(previous_status) = success) : {0, 1};
				(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}) : heading_surface;
				(active_node in {node_names.rth_task, node_names.rth_task1}) : heading_rth;
				(active_node in {node_names.loiter_task1,node_names.loiter_task2, node_names.loiter_task}) : heading_loiter;
				(active_node in {node_names.tracking_task}) : heading_pipeline_mapping;
				(active_node in {node_names.waypoint_task}) : heading_waypoint;
				TRUE : HSD_out_dot_heading;
			esac;
		-- init(uuv_max_speed) := 1;--default value, can be changed by passing stuff in
		-- next(uuv_max_speed) := 
		-- 	case
		-- 		(active_node in {node_names.speed_max_task}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : uuv_max_speed;
		-- 	esac;
		-- init(mission_file) := 0;
		-- next(mission_file) := 
		-- 	case
		-- 		(active_node in {node_names.mission_server}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : mission_file;
		-- 	esac;
		-- init(refLat) := 0;
		-- next(refLat) := 
		-- 	case
		-- 		(active_node in {node_names.mission_server}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : refLat;
		-- 	esac;
		-- init(refLon) := 0;
		-- next(refLon) := 
		-- 	case
		-- 		(active_node in {node_names.mission_server}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : refLon;
		-- 	esac;
		init(next_mission) := 0;
		next(next_mission) := 
			case
				(active_node in {node_names.mission_server}) : 0;
				(active_node in {node_names.next_mission}) : 1;
				TRUE : next_mission;
			esac;
		-- init(decision_threshold) :=
		-- 	case
		-- 		(task_mission_server_mission_type_list[0] = mission_type_unknown) : ?;--NOT DONE. Fill in a default value here
		-- 		TRUE : ?; --NOT DONE. figure out how this should actually be set
		-- 	esac;
				
		-- next(decision_threshold) := --NOT DONE
		-- 	case
		-- 		(active_node in {node_names.mission_server}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : decision_threshold;
		-- 	esac;
		-- init(HSD_out) := 0;
		-- next(HSD_out) := 
		-- 	case
		-- 		(active_node in {node_names.obstacle_avoidance, node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4, node_names.rth_task, node_names.rth_task1, node_names.loiter_task1, node_names.tracking_task, node_names.speed_min_task, node_names.speed_min_task1, node_names.speed_max_task, node_names.loiter_task2, node_names.waypoint_task, node_names.loiter_task}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : HSD_out;
		-- 	esac;
		init(bb_obstacle_warning) := 0;
		next(bb_obstacle_warning) := 
			case
				(active_node in {node_names.obstacle_avoidance}) : {0, 1};
				TRUE : bb_obstacle_warning;
			esac;
		init(cm_hsd_input) := name_default;
		next(cm_hsd_input) := 
			case
				--(active_node in {node_names.obstacle_avoidance, node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4, node_names.rth_task, node_names.rth_task1, node_names.loiter_task1, node_names.tracking_task, node_names.loiter_task2, node_names.waypoint_task, node_names.loiter_task}) & (next(previous_status) = success) : {0, 1};
				(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}) : name_surface_task;
				(active_node in {node_names.rth_task, node_names.rth_task1}) : name_rth_task;
				(active_node in {node_names.loiter_task1, node_names.loiter_task2, node_names.loiter_task}) : name_loiter_task;
				(active_node in {node_names.tracking_task}) : name_tracking_task;
				(active_node in {node_names.waypoint_task}) : name_waypoint_task;
				TRUE : cm_hsd_input;
			esac;
		init(HSD_out_dot_speed) := uuv_max_speed;
		next(HSD_out_dot_speed) := 
			case
				--(active_node in {node_names.obstacle_avoidance, node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4, node_names.rth_task, node_names.rth_task1, node_names.loiter_task1, node_names.tracking_task, node_names.speed_min_task, node_names.speed_min_task1, node_names.speed_max_task, node_names.loiter_task2, node_names.waypoint_task, node_names.loiter_task}) & (next(previous_status) = success) : {0, 1};
				(active_node in {node_names.speed_min_task, node_names.speed_min_task1}) : uuv_min_speed;--the min speed
				(active_node in {node_names.speed_max_task}) : uuv_max_speed;--the max speed
				TRUE : HSD_out_dot_speed;
			esac;
		init(HSD_out_dot_depth) := depth_default;
		next(HSD_out_dot_depth) := 
			case
				--(active_node in {node_names.obstacle_avoidance, node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4, node_names.rth_task, node_names.rth_task1, node_names.loiter_task1, node_names.tracking_task, node_names.speed_min_task, node_names.speed_min_task1, node_names.speed_max_task, node_names.loiter_task2, node_names.waypoint_task, node_names.loiter_task}) & (next(previous_status) = success) : {0, 1};
				(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}) : depth_surface_task;
				(active_node in {node_names.rth_task, node_names.rth_task1}) : depth_rth_task;
				(active_node in {node_names.loiter_task1, node_names.loiter_task2,node_names.loiter_task, node_names.tracking_task}) : depth_pipeline_mapping;
				(active_node in {node_names.waypoint_task}) : depth_waypoint;
				TRUE : HSD_out_dot_depth;
			esac;
		init(bb_home_reached) := 0;
		next(bb_home_reached) := 
			case
				(active_node in {node_names.home2bb, node_names.home2bb1}) & (next(bb_home_dist_dot_data) < home_reached_threshold) & (next(previous_status) = success) : 1;
				TRUE : bb_home_reached;
			esac;
		-- init(bb_home_dist) := 0;
		-- next(bb_home_dist) := 
		-- 	case
		-- 		(active_node in {node_names.home2bb, node_names.home2bb1}) & (next(previous_status) = success) : {0, 1};
		-- 		TRUE : bb_home_dist;
		-- 	esac;
		init(bb_home_dist_dot_data) := 0;
		next(bb_home_dist_dot_data) := 
			case
				(active_node in {node_names.home2bb, node_names.home2bb1}) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_home_dist_dot_data;
			esac;
		init(pipe_mapping_enable) := 1;
		next(pipe_mapping_enable) := 
			case
				(active_node in {node_names.pipe_mapping_enable_task}) : 1;
				(active_node in {node_names.pipe_mapping_disable_task, node_names.pipe_mapping_disable_task1}) : 0;
				TRUE : pipe_mapping_enable;
			esac;
MODULE battery2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rth2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE geofence2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE lec2_am_r_2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE lec2_am_l_2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE pipe_lost2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE sensor_failure2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE waypoints_completed2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE mission2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE ddlec2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE fls2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE fls_warning2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_pipe2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_wp2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_rth2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_surface2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rtreach2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE reallocate_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE dd_lec_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE mission_server_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE obstacle_avoidance_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE emergency_stop_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : success;
				TRUE : invalid;
			esac;
MODULE surface_task2_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task3_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task4_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE rth_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE home2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rth_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE home2bb1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE loiter_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE tracking_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_min_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_min_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_max_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_disable_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_disable_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_enable_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE next_mission_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : success;
				TRUE : invalid;
			esac;
MODULE loiter_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE waypoint_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE loiter_task2_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE is_reallocation_requested_CHECK_dd_xy_axis_degradation_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.dd_xy_axis_degradation] = 0);
MODULE battery_low_fs_CHECK_battery_low_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.battery_low_warning] = 0);
MODULE check_sensor_failure_CHECK_bb_sensor_failure_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_sensor_failure_warning] = 0);
MODULE emergency_stop_fs_CHECK_emergency_stop_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.emergency_stop_warning] = 0);
MODULE check_surface_CHECK_bb_home_reached_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_home_reached] = 0);
MODULE obstacle_standoff_fs_CHECK_obstacle_standoff_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.obstacle_standoff_warning] = 0);
MODULE check_rth_CHECK_bb_rth_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_rth_warning] = 0);
MODULE check_geofence_CHECK_bb_geofence_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_geofence_warning] = 0);
MODULE check_pipe_post_CHECK_bb_pipe_lost_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_pipe_lost_warning] = 0);
MODULE is_track_pipe_mission_requested_CHECK_bb_mission_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_mission_dot_data] = 1);
MODULE is_waypoint_requested_CHECK_bb_mission_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_mission_dot_data] = 2);
MODULE check_lec2am_ls_CHECK_lec2_am_l_speed_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_l_speed_warning] = 0);
MODULE check_lec2am_rs_CHECK_lec2_am_r_speed_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_r_speed_warning] = 0);
MODULE check_lec2am_lp_CHECK_lec2_am_l_pipe_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_l_pipe_warning] = 0);
MODULE check_lec2am_rp_CHECK_lec2_am_r_pipe_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_r_pipe_warning] = 0);
MODULE check_waypoints_completed_CHECK_bb_waypoints_completed_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_waypoints_completed_dot_data] = 0);

