

system BlueROV;  //system name

//-----------------------------------
//basic types 
//-----------------------------------

type string;
type bool;
type integer;
type float;
type float32;
type float64;
type time;


//-----------------------------------
//message types
//-----------------------------------

message Bool std_msgs
	bool value;
end

message Float32 std_msgs
	float value;
end

message String std_msgs
	string value;
end

message PixhawkHW vandy_bluerov
	float64 thrusters_power;
	float64 batt_capacity_remaining;
	float64 batt_voltage_remaining;
	float64 batt_charge_remaining;
	float32[] rpm;
end

message AssuranceMonitorConfidence ng_msgs
	float32 confidence_level;
	float32[] values;
end

message HSDCommand ng_msgs
	float64 heading;
	float64 speed;
	float64 depth;
end


message LEC1OutputAssuredStamped ng_msgs
    AssuranceMonitorConfidence[] confs;
    HSDCommand cmd;
    float64 current_heading;
end

message Float32MultiArray std_msgs
    float32[] data;
end

message PoseWithCovariance geometry_msgs
    float64[36] covariance;
end

message TwistWithCovariance geometry_msgs
    float64[36] covariance;
end

message Odometry nav_msgs
    string child_frame_id;
    PoseWithCovariance pose;
    TwistWithCovariance twist;
end

message Range sensor_msgs
    integer radiation_type;
    float32 field_of_view;
    float32 min_range;
    float32 max_range;
    float32 range;
end

message Time std_msgs
    integer sec;
    integer nsec;
end

message Header std_msgs
    integer seq;
    Time stamp;
    string frame_id;
end

//-----------------------------------
//topics
//-----------------------------------
topic PixhawkHW pixhawk_hw /iver0/pixhawk_hw;
topic Bool bb_geofence /iver0/bb_geofence;
topic Bool bb_pipelost /iver0/bb_pipe_lost;
topic Float32 bb_home_dist /iver0/bb_home_dist;
topic LEC1OutputAssuredStamped lec2_left_am /lec2_am/left/p_value;
topic LEC1OutputAssuredStamped lec2_right_am /lec2_am/right/p_value; 
topic String bb_mission /iver0/bb_mission;
topic Bool bb_rth /iver0/bb_rth;
topic Bool bb_sensor_failure /iver0/sensor_failure_rpm;
topic Bool bb_waypoints_completed /iver0/waypoints_completed;
topic HSDCommand hsd_pipeline_mapping /iver0/hsd_pipeline_mapping;
topic HSDCommand hsd_to_surface /iver0/hsd_to_surface;
topic HSDCommand hsd_to_rth /iver0/hsd_to_rth;
topic HSDCommand hsd_to_waypoint /iver0/hsd_to_waypoint;
topic HSDCommand hsd_to_waypoint_rrt /iver0/hsd_to_waypoint_rrt;
topic HSDCommand hsd_obstacle_avoidance /iver0/hsd_obstacle_avoidance;
topic HSDCommand hsd_command /iver0/hsd_command;
topic String cm_hsd_input /iver0/cm_hsd_input;
topic Float32MultiArray degradation_detector_am /iver0/degradation_detector_am/p_value;
topic Float32MultiArray lec_input /iver0/thruster_cmd_logging;
topic Bool next_wp /iver0/next_wp;
topic Odometry odom /iver0/pose_gt_noisy_ned;
topic Range fls_range /iver0/fls_echosunder;

topic LEC1OutputAssuredStamped  lec_dd_am               /lec_dd_am/p_value;
topic Float32MultiArray         degradation_detector    /iver0/degradation_detector;
topic Header                    obstacle_in_view        /iver0/obstacle_in_view;
topic Float32                   rtreach_result          /reachability_result;
topic Float32                   rtreach_unsafe_value    /unsafe_grid_value;
topic Float32                   rtreach_index           /unsafe_hyperrectangle_index;

//-----------------------------------
//Blackboard variables
//-----------------------------------

//model_as indicates that the variable is being modeled in behaverify
//model_as is formated as model_as(DOMAIN, initial_value), where domain can be [min_int, max_int], bool, or {enums}

var PixhawkHW				battery, model_as([0, 1], 1); //while battery is a topic variable with many fields, in modeling we only care about battery.batt_charge_remaining. for modeling, it is being treated as an integer. 
var bool 				battery_low_warning = False, model_as(bool, False);
var Bool 				bb_fls_warning =  False, model_as(bool, False); 
var Bool 				bb_geofence = False, model_as(bool, False);
var bool 				bb_geofence_warning = False, model_as(bool, False);
var Float32 				bb_home_dist = 1000, model_as({10, 100}, 10); //for clarity, we are modeling the bb_home_dist as beihng either close, or far
var bool 				bb_home_reached =False, model_as(bool, False);
var String 				bb_mission = "", model_as({'unknown', 'loitering', 'pipe_following', 'waypoint_following', 'path_following', 'collision_avoidance', 'assurance', 'terminal', 'e_stop'}, 'unknown'); //mission can be any of these types
var bool 				bb_obstacle_warning = False, model_as(bool, False);
var Bool 				bb_pipelost = False, model_as(bool, False);
var bool 				bb_pipe_lost_warning = False, model_as(bool, False);
var Bool 				bb_pipe_mapping_enable = False, model_as(bool, False);
var Bool 				bb_rth = False, model_as(bool, False);
var bool 				bb_rth_warning = False, model_as(bool, False);
var Bool 				bb_sensor_failure = False, model_as(bool, False);
var Bool 				bb_sensor_failure_warning = False, model_as(bool, False);
var Bool 				bb_waypoints_completed = False, model_as(bool, False);
var String 				cm_hsd_input, model_as({'cm_surface_task', 'cm_rth_task', 'cm_loiter_task', 'cm_obstacle_avoidance_task', 'cm_tracking_task', 'cm_waypoint_task'}, 'cm_surface_task'); //cm_hsd_input is a variable that informs the ros nodes what task set the information.
//var String 				cm_hsd_input;
var string 				ddlec_am_path; //this is not being modeled.
var Float32MultiArray 			dd_output, model_as({'safe', 'xy_warn', 'z_warn'}, 'safe'); //these 3 enumerations represent the possible paths in the node
var bool 				dd_xy_axis_degradation = False, model_as(bool, False);
var bool 				dd_z_axis_warning = False, model_as(bool, False);
var float 				decision_threshold; // not being modeled
var bool 				emergency_stop_warning = False, model_as(bool, False);
var bool 				event_reallocate_button = False; // node being modeled. this appears to be unused???????
var Range 				fls_range, model_as({'danger_zone', 'safe'}, 'safe'); // represents if we are in the clear or in danger. note: not considering junk_values.
var HSDCommand 				hsd_pipeline_mapping; // these variables are basically not being used in the current model.
var HSDCommand 				hsd_to_surface;
var HSDCommand 				hsd_to_rth;
var HSDCommand 				hsd_to_waypoint;
var HSDCommand 				hsd_to_waypoint_rrt;
var HSDCommand 				HSD_out, model_as({'uuv_min_speed', 'uuv_max_speed'}, 'uuv_min_speed'); //HSD_out contains far more information (specifically, heading and depth). however, heading is handled as an enum, and redundant given cm_hsd_input, and depth is basically a constant.
var LEC1OutputAssuredStamped 		lec_dd_am, model_as(bool, False);
var bool 				lec_dd_am_warning = False, model_as(bool, False);
var LEC1OutputAssuredStamped 		lec2_am_l, model_as({'safe', 'speed', 'pipe', 'speed_pipe'}, 'safe');
var bool 				lec2_am_l_speed_warning = False, model_as(bool, False);
var bool 				lec2_am_l_pipe_warning = False, model_as(bool, False);
var LEC1OutputAssuredStamped 		lec2_am_r, model_as({'safe', 'speed', 'pipe', 'speed_pipe'}, 'safe');
var bool 				lec2_am_r_speed_warning = False, model_as(bool, False);
var bool 				lec2_am_r_pipe_warning = False, model_as(bool, False);
var Float32MultiArray 			lec_input; // not modeled
var string 				mission_file = mission_file; //not modeled 
var bool 				next_mission, model_as(bool, False);
var Bool 				pipe_mapping_enable, model_as(bool, False);
var float 				obstacle_min_standoff; //not modeled
var Header 				obstacle_in_view, model_as(bool, False);
var bool 				obstacle_standoff_warning = False, model_as(bool, False);
var Odometry 				odom; // not modeled
var float 				refLat = 38.971203; //not modeled
var float 				refLon = -76.398464; // not modeled
var bool 				rtreach_fence_warning = False; //not modeled....possibly unused?
var Float32             		rtreach_index; //not modeled. redundant in model given rtreach_result
var bool 		 		rtreach_long_term_warning = False, model_as(bool, False);
var bool 				rtreach_obstacle_warning = False; // not modeled.....possibly unused?
var Float32             		rtreach_result, model_as({'safe', 'short', 'long', 'short_long'}, 'safe');
var Float32             		rtreach_unsafe_value; // not modeled....possibly unused?
var bool 				rtreach_warning = False, model_as(bool, False);
var float 				total_degradation=0; // not modeled
var float 				uuv_max_speed; //not modeled. not sure why this is in here but min speed isn't.
//----------------------------------
//MODELING VARIABLES ONLY
//----------------------------------
//these are variables that are not used in code generation. just in the modeling side.
var bool				max_mission = 4, model_as({4}, 4);
var bool				mission_idx = 0, model_as([0, 4], 0);
//----------------------------------
//Arguments
//----------------------------------
arg float failsafe_battery_low_threshold = 0.1;
arg bool failsafe_rth_enable =True;
arg float pipe_estimation_good_log_val = 5.0;
arg float speed_good_log_val  = 2.5;
arg float total_degradation_threshold=0.0;
arg float home_reached_threshold =15;
arg integer num_classes=22;
arg float uuv_max_speed = 0.9;
arg float uuv_min_speed = 0.4;
arg string mission_file = "mission_04.yaml";
arg integer ann_input_len=13;
arg bool enable_fault_detection = True;
arg string decision_source="snapshot_am";
arg bool enable_obstacle_avoidance=True;
arg bool enable_emergency_stop=True;
arg integer fls_in_view_window=20;
arg integer fls_in_view_limit=10;
arg string ddlec_am_path="jupyter/admin_BlueROV/FDIR_ALC/SLModel";
arg string ddlec_am_params="{'user_choice':'override_threshold','am_s_threshold':0.5, 'am_threshold':0.5}";
arg integer rtreach_window_size = 25;
arg float rtreach_window_threshold = 0.75;
//-----------------------------------
//Blackboard nodes
//-----------------------------------


input hsd_pipe2bb hsd_pipeline_mapping -> hsd_pipeline_mapping
    comment  "This node captures HSD input from pipeline tracking node"
end

input hsd_surface2bb hsd_to_surface -> hsd_to_surface
    comment  "This node captures HSD input from surface node"
end

input hsd_rth2bb hsd_to_rth -> hsd_to_rth
    comment  "This node captures HSD input from rth node"
end

input hsd_wp2bb hsd_to_waypoint -> hsd_to_waypoint
    comment  "This node captures HSD input from waypoint node"
end

input hsd_wp_rrt2bb hsd_to_waypoint_rrt -> hsd_to_waypoint_rrt
    comment  "This node captures HSD input from waypoint node"
end


input fls2bb fls_range -> fls_range
    vars obstacle_standoff_warning, obstacle_min_standoff;
    comment  "This node captures the FLS ranges"
    set(obstacle_standoff_warning, (equal, fls_range, 'danger_zone')) 
end


input fls_warning2bb obstacle_in_view -> obstacle_in_view
    vars bb_fls_warning;
    arg integer fls_in_view_window = fls_in_view_window;
    arg integer fls_in_view_limit = fls_in_view_limit;
    comment  "This node captures the FLS obstacle in view information"
    set(bb_fls_warning, (or, bb_fls_warning, obstacle_in_view))
    set(emergency_stop_warning, (or, emergency_stop_warning, obstacle_in_view))
end


input battery2bb pixhawk_hw -> battery 
    vars battery_low_warning;
    arg float failsafe_battery_low_threshold = failsafe_battery_low_threshold;
    comment  "This node captures the state of the battery"
    set(battery_low_warning, (less_than_or_equal, battery, 0))
end

input ddlecam2bb lec_dd_am -> lec_dd_am
    vars lec_dd_am_warning;
    comment  "This node captures the state of the lec dd assurance monitor"
    set(lec_dd_am_warning, lec_dd_am)
end

input rth2bb bb_rth -> bb_rth
    vars bb_rth_warning;
    arg bool failsafe_rth_enable = failsafe_rth_enable;
    comment  "This node captures if the uuv is commanded to return to home"
    set(bb_rth_warning, (or, bb_rth_warning, bb_rth))
end 

input geofence2bb bb_geofence -> bb_geofence
    vars bb_geofence_warning;
    comment  "This node captures if the uuv is within  the geofence"
    set(bb_geofence_warning, (or, bb_geofence_warning, bb_geofence))
end

input lec2_am_l_2bb  lec2_left_am -> lec2_am_l
    vars lec2_am_l_speed_warning, lec2_am_l_pipe_warning;
    arg float pipe_estimation_good_log_val = pipe_estimation_good_log_val;
    arg float speed_good_log_val  = speed_good_log_val;
    comment  "This node captures the output of the lec2 assurance monitor left"
    set(lec2_am_l_speed_warning, (or, (equal, lec2_am_l, 'speed'), (equal, lec2_am_l, 'speed_pipe')))
    set(lec2_am_l_pipe_warning, (or, (equal, lec2_am_l, 'pipe'), (equal, lec2_am_l, 'speed_pipe')))
end

input lec2_am_r_2bb lec2_right_am -> lec2_am_r
    vars lec2_am_r_speed_warning, lec2_am_r_pipe_warning;
    arg float pipe_estimation_good_log_val = pipe_estimation_good_log_val ;
    arg float speed_good_log_val = speed_good_log_val;
    comment  "This node captures the output of the lec2 assurance monitor right"
    set(lec2_am_r_speed_warning, (or, (equal, lec2_am_r, 'speed'), (equal, lec2_am_r, 'speed_pipe')))
    set(lec2_am_r_pipe_warning, (or, (equal, lec2_am_r, 'pipe'), (equal, lec2_am_r, 'speed_pipe')))
end


input pipe_lost2bb bb_pipelost -> bb_pipelost
    vars bb_pipe_lost_warning;
    comment  "This node captures if the pipe is not in visibility of UUV"
    set(bb_pipe_lost_warning, (and, bb_pipelost, (equal, bb_mission, 'pipe_following')))
end


input sensor_failure2bb  bb_sensor_failure -> bb_sensor_failure
    vars bb_sensor_failure_warning;
    comment  "This node captures sensor failure"
    set(bb_sensor_failure_warning, (or, bb_sensor_failure_warning, bb_sensor_failure))
end

input waypoints_completed2bb  bb_waypoints_completed -> bb_waypoints_completed
    comment "This node captures if the waypoints are completed"
end 

input home2bb bb_home_dist -> bb_home_dist
    vars bb_home_reached;
    arg float home_reached_threshold = home_reached_threshold;
    comment "This node captures if the uuv is home"
    set(bb_home_reached, (or, bb_home_reached, (less_than, bb_home_dist, 15)))
end

input mission2bb bb_mission -> bb_mission
//    arg bool enable_waypoint_following = False;
    comment  "This node captures the current mission"
end

input ddlec2bb degradation_detector -> dd_output 
    vars dd_z_axis_warning, dd_xy_axis_degradation;
    arg float total_degradation_threshold= total_degradation_threshold;
    arg integer num_classes = num_classes;
    arg bool enable_fault_detection = enable_fault_detection;
    arg string decision_source = decision_source;
    comment  "This node captures the output of the DD LEC"
    set(dd_z_axis_warning, (or, (equal, dd_output, 'z_warn'), (and, dd_z_axis_warning, (not, (equal, dd_output, 'safe')))))
    set(dd_xy_axis_degradation, (or, (equal, dd_output, 'xy_warn'), (and, dd_xy_axis_degradation, (not, (equal, dd_output, 'safe')))))
end   

//input rtreach2bb rtreach -> rtreach_out
//    var bool emergency_stop_warning = False;
//    arg bool enable_emergency_stop = enable_emergency_stop;
//    comment "This node captures the rtreachabiliy decision over safety"
//end

input rtreach_index2bb rtreach_index-> rtreach_index
    comment "This node captures the rtreachability unsafe hyperrectangle index scaled to 0.0 to 1.0 range"
end


input rtreach2bb rtreach_result -> rtreach_result
    vars emergency_stop_warning, rtreach_warning, rtreach_long_term_warning;
    arg bool enable_emergency_stop = enable_emergency_stop;
    arg integer rtreach_window_size = 25;
    arg float rtreach_window_threshold = 0.75;
    comment "This node captures the rtreachabiliy decision result over safety"
    set(rtreach_long_term_warning, (or, (equal, rtreach_result, 'long'), (equal, rtreach_result, 'short_long')))
    set(rtreach_warning, (or, (equal, rtreach_result, 'short'), (equal, rtreach_result, 'short_long')))
end


input rtreach_unsafe_value2bb rtreach_unsafe_value -> rtreach_unsafe_value
    vars rtreach_fence_warning, rtreach_obstacle_warning;
    comment "This node captures the rtreachabiliy decision value over safety"
end


//-----------------------------------
//checkers for blackboard variables
//-----------------------------------

//check is_reallocation_requested 
//        event_reallocate_button==False;

check emergency_stop_fs
        emergency_stop_warning==False;

check obstacle_standoff_fs
        obstacle_standoff_warning==False;

check is_reallocation_requested 
        dd_xy_axis_degradation==False;

check check_dd_am 
        lec_dd_am_warning == False;


check check_lec2am_ls 
        lec2_am_l_speed_warning == False;


check check_lec2am_rs 
        lec2_am_r_speed_warning == False;


check check_lec2am_lp 
        lec2_am_l_pipe_warning == False;


check check_lec2am_rp 
        lec2_am_r_pipe_warning == False;


check check_geofence 
        bb_geofence_warning == False;


check check_rth 
        bb_rth_warning == False;


check check_surface 
        bb_home_reached ==False;


check check_pipe_post 
        bb_pipe_lost_warning == False;


check check_waypoints_completed 
        bb_waypoints_completed == False;


check check_sensor_failure 
        bb_sensor_failure_warning == False;


check battery_low_fs 
        battery_low_warning == False;


check is_track_pipe_mission_requested 
        bb_mission  == "pipe_following";

check is_waypoint_requested 
        bb_mission  == "waypoint_following";

check is_snr_requested 
        bb_mission  == "fdr";

check is_loiter_requested 
        bb_mission  == "loitering";

check dd_z_axis
        dd_z_axis_warning == False;

check dd_xy_axis
        dd_xy_axis_degradation == False;

check rtreach_check
    rtreach_warning==False;

//this check is not in the tree
check rtreach_fence_check
    rtreach_fence_warning == False;

check rtreach_obstacle_check    
    rtreach_obstacle_warning == False;    

check rtreach_long_term_check
    rtreach_long_term_warning == False;

//-----------------------------------
//standard behavioral nodes
//-----------------------------------

success success_node;
failure failure_node;
running running_node;
running idle;
//running reallocate_task;
//running  dd_lec_task; 

//-----------------------------------
//custom behavioral nodes
//-----------------------------------

task emergency_stop_task
     return success
end

task surface_task
    in hsd_to_surface hsd_to_surface_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    //set(cm_hsd_input, 'cm_surface_task')
    return running
end     

task  rth_task 
    in  hsd_to_rth hsd_to_rth_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    //set(cm_hsd_input, 'cm_rth_task')
    return running
end

task  loiter_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input  cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    //set(cm_hsd_input, 'cm_loiter_task')
    return running
end    


task obstacle_avoidance
    in hsd_obstacle_avoidance hsd_obstacle_avoidance_, hsd_pipeline_mapping  hsd_pipeline_mapping_, hsd_to_waypoint hsd_waypoint_, hsd_to_waypoint_rrt hsd_waypoint_rrt_;
    out hsd_command hsd_pub;
    vars HSD_out, bb_obstacle_warning, cm_hsd_input;
    arg bool enable_obstacle_avoidance = enable_obstacle_avoidance;
    set(bb_obstacle_warning, (any, True, False))
    //set(cm_hsd_input, try(bb_obstacle_warning, 'cm_obstacle_avoidance_task'), cm_hsd_input)
    return running
end     


task mission_server
    out bb_mission bb_mission;
    vars uuv_max_speed, mission_file, refLat, refLon;
    //var bool next_mission = False;
    arg float uuv_max_speed = uuv_max_speed;
    arg string mission_file = mission_file;
    set(mission_idx, try(next_mission, (min, max_mission, (addition, mission_idx, 1))), mission_idx)
    set(bb_rth_warning, try(next_mission, (equal, mission_idx, max_mission)), bb_rth_warning)
    set(next_mission, False)
    return running
end

task next_mission
    in bb_mission bb_mission;
    out next_wp next_wp_;
    vars next_mission;
    set(next_mission, True)
    return success
end  

task  speed_max_task 
    vars HSD_out;
    arg float uuv_max_speed = uuv_max_speed;
    set(HSD_out, 'uuv_max_speed')
    return running
end    

task  speed_min_task 
    vars HSD_out;
    arg float uuv_min_speed=uuv_min_speed;
    set(HSD_out, 'uuv_min_speed')
    return running
end

task  pipe_mapping_enable_task 
    vars pipe_mapping_enable;
    set(pipe_mapping_enable, True)
    return success
end    

task  pipe_mapping_disable_task 
    vars pipe_mapping_enable;
    set(pipe_mapping_enable, False)
    return running
end

task  tracking_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    //set(cm_hsd_input, 'cm_tracking_task')
    return running
end    

task  waypoint_task 
    in hsd_to_waypoint hsd_waypoint_, bb_waypoints_completed hsd_waypoint_completed_;
	out cm_hsd_input cm_hsd_input_, next_wp next_wp_;
    vars HSD_out, cm_hsd_input;
    //set(cm_hsd_input, 'cm_waypoint_task')
    return running
end   


task  reallocate_task 
    vars total_degradation;
    //set(total_degradation, (any, total_degradation, (min, (addition, total_degradation, 1), 6)))
    return running
end   

task dd_lec_task
    in lec_input lec_input_;
    out degradation_detector degradation_detector_, degradation_detector_am degradation_detector_am_;        
    arg integer num_classes= num_classes;
    arg integer ann_input_len= ann_input_len;
    arg string ddlec_am_path= ddlec_am_path;
    arg string ddlec_am_params= ddlec_am_params;
    return running
end

//-----------------------------------
//tree definition
//-----------------------------------

tree(updatetime=1000,timeout=15)
par BlueROV {
    par topics2bb {
		mon battery2bb, rth2bb, geofence2bb
        mon lec2_am_r_2bb, lec2_am_l_2bb, pipe_lost2bb
		mon sensor_failure2bb, waypoints_completed2bb
        mon mission2bb, ddlec2bb
        mon fls2bb, fls_warning2bb
        mon hsd_pipe2bb, hsd_wp2bb, hsd_rth2bb, hsd_surface2bb
        mon rtreach2bb, rtreach_unsafe_value2bb, rtreach_index2bb

	}
    sel dd_tasks {
        do reallocate_check {
			if is_reallocation_requested
			then {
				exec reallocate_task
			}
		}
        exec dd_lec_task
	}
    exec mission_server
    exec obstacle_avoidance
    sel priorities {
		do battery_check {
			if battery_low_fs 
			then {
				exec surface_task
			}
		}
        do sensor_failure_selector {
			if check_sensor_failure
			then {
				exec surface_task
			}
		}

        do emergency_stop_check{
            if emergency_stop_fs
            then{
                seq emergency_stop_tasks {
                    exec emergency_stop_task
                    exec surface_task
                }
            }
        }

		do home_reached_selector  {
			if check_surface  
			then {
				exec surface_task 
			}
		}

        do obstacle_standoff_check{
            if obstacle_standoff_fs
            then{
                exec surface_task
            }
        }

		do rth_selector  {
			if check_rth  
			then {
				par rth_par {
					exec rth_task  
					mon home2bb
				}
			}
		}
		do geofence_selector  {
			if check_geofence  
			then {
				par rth_par {
					exec rth_task  
					mon home2bb
				} 
			}
		}
		do pipe_lost_selector  {
			if check_pipe_post  
			then {
				exec loiter_task
			}
		}
        seq track_pipe_mission  {
			chk is_track_pipe_mission_requested
	        par tracking  {
                exec tracking_task  
                sel lec2am_speed_cmd {
                    do lec2am_l_speed_check {
                        if check_lec2am_ls
                        then {
                            exec speed_min_task 
                        }
                    } 
                    do lec2am_r_speed_check  {
                        if check_lec2am_rs  
                        then {
                            exec speed_min_task
                        }
                    }
                    exec speed_max_task 
                }
                sel lec2am_mapping_cmd {
                    do lec2am_l_mapping_check  {
                        if check_lec2am_lp  
                        then {
                            exec pipe_mapping_disable_task
                        }
                    }
                    do lec2am_r_mapping_check  {
                        if check_lec2am_rp  
                        then {
                            exec pipe_mapping_disable_task
                        }
                    }
                    exec pipe_mapping_enable_task
                }
            }
            seq track_pipe_mission_end {
                timer evaluate(0.5)
            }
        }
        seq waypoint_mission  {
            chk is_waypoint_requested
            sel waypoint_selector {
                do waypoints_sif {
                    if check_waypoints_completed
                    then {
                        seq waypoint_end {
                            exec next_mission
                            exec  loiter_task
                        } 
                    }
                }
            exec waypoint_task
            } 
		}
        exec loiter_task
    }
}

//-------done------------------