

system BlueROV;  //system name

//-----------------------------------
//basic types 
//-----------------------------------

type string;
type bool;
type integer;
type float;
type float32;
type float64;
type time;


//-----------------------------------
//message types
//-----------------------------------

message Bool std_msgs
	bool value;
end

message Float32 std_msgs
	float value;
end

message String std_msgs
	string value;
end

message PixhawkHW vandy_bluerov
	float64 thrusters_power;
	float64 batt_capacity_remaining;
	float64 batt_voltage_remaining;
	float64 batt_charge_remaining;
	float32[] rpm;
end

message AssuranceMonitorConfidence ng_msgs
	float32 confidence_level;
	float32[] values;
end

message HSDCommand ng_msgs
	float64 heading;
	float64 speed;
	float64 depth;
end


message LEC1OutputAssuredStamped ng_msgs
    AssuranceMonitorConfidence[] confs;
    HSDCommand cmd;
    float64 current_heading;
end

message Float32MultiArray std_msgs
    float32[] data;
end

message PoseWithCovariance geometry_msgs
    float64[36] covariance;
end

message TwistWithCovariance geometry_msgs
    float64[36] covariance;
end

message Odometry nav_msgs
    string child_frame_id;
    PoseWithCovariance pose;
    TwistWithCovariance twist;
end

message Range sensor_msgs
    integer radiation_type;
    float32 field_of_view;
    float32 min_range;
    float32 max_range;
    float32 range;
end

message Time std_msgs
    integer sec;
    integer nsec;
end

message Header std_msgs
    integer seq;
    Time stamp;
    string frame_id;
end

//-----------------------------------
//topics
//-----------------------------------
topic PixhawkHW pixhawk_hw /iver0/pixhawk_hw;
topic Bool bb_geofence /iver0/bb_geofence;
topic Bool bb_pipelost /iver0/bb_pipe_lost;
topic Float32 bb_home_dist /iver0/bb_home_dist;
topic LEC1OutputAssuredStamped lec2_left_am /lec2_am/left/p_value;
topic LEC1OutputAssuredStamped lec2_right_am /lec2_am/right/p_value; 
topic String bb_mission /iver0/bb_mission;
topic Bool bb_rth /iver0/bb_rth;
topic Bool bb_sensor_failure /iver0/sensor_failure_rpm;
topic Bool bb_waypoints_completed /iver0/waypoints_completed;
topic HSDCommand hsd_pipeline_mapping /iver0/hsd_pipeline_mapping;
topic HSDCommand hsd_to_surface /iver0/hsd_to_surface;
topic HSDCommand hsd_to_rth /iver0/hsd_to_rth;
topic HSDCommand hsd_to_waypoint /iver0/hsd_to_waypoint;
topic HSDCommand hsd_to_waypoint_rrt /iver0/hsd_to_waypoint_rrt;
topic HSDCommand hsd_obstacle_avoidance /iver0/hsd_obstacle_avoidance;
topic HSDCommand hsd_command /iver0/hsd_command;
topic String cm_hsd_input /iver0/cm_hsd_input;
topic Float32MultiArray degradation_detector_am /iver0/degradation_detector_am/p_value;
topic Float32MultiArray lec_input /iver0/thruster_cmd_logging;
topic Bool next_wp /iver0/next_wp;
topic Odometry odom /iver0/pose_gt_noisy_ned;
topic Range fls_range /iver0/fls_echosunder;

topic LEC1OutputAssuredStamped  lec_dd_am               /lec_dd_am/p_value;
topic Float32MultiArray         degradation_detector    /iver0/degradation_detector;
topic Header                    obstacle_in_view        /iver0/obstacle_in_view;
topic Float32                   rtreach_result          /reachability_result;
topic Float32                   rtreach_unsafe_value    /unsafe_grid_value;
topic Float32                   rtreach_index           /unsafe_hyperrectangle_index;

//-----------------------------------
//Blackboard variables
//-----------------------------------

//model_as indicates that the variable is being modeled in behaverify
//model_as is formated as model_as(DOMAIN) or model_as(DOMAIN, initial_value), where domain can be [min_int, max_int], bool, or {enums}
//

var PixhawkHW				battery, model_as([0, 1], 1); //while battery is a topic variable with many fields, in modeling we only care about battery.batt_charge_remaining. for modeling, it is being treated as an integer.
var bool 				battery_low_warning = False, model_as(bool, False);
var Bool 				bb_fls_warning =  False, model_as(bool, False); 
var Bool 				bb_geofence = False, model_as(bool, False);
var bool 				bb_geofence_warning = False, model_as(bool, False);
var Float32 				bb_home_dist = 1000, model_as({10, 100}, 10); //for clarity, we are modeling the bb_home_dist as beihng either close, or far
var bool 				bb_home_reached =False, model_as(bool, False);
//var String 				bb_mission = "", model_as({'unknown', 'loitering', 'pipe_following', 'waypoint_following', 'path_following', 'collision_avoidance', 'assurance', 'terminal', 'e_stop'}); //mission can be any of these types
//--------------------------------
//while in THEORY, bb_mission can be any of the types listed above, in practice, the only place that sets bb_mission is mission_server
//and mission_server will only set to these values.
var String 				bb_mission = "", model_as({'waypoint_following', 'e_stop', 'pipe_following'}, 'waypoint_following'); //mission can be any of these types
var bool 				bb_obstacle_warning = False, model_as(bool, False);
var Bool 				bb_pipelost = False, model_as(bool, False);
var bool 				bb_pipe_lost_warning = False, model_as(bool, False);
var Bool 				bb_pipe_mapping_enable = False, model_as(bool, False);
var Bool 				bb_rth = False, model_as(bool, False);
var bool 				bb_rth_warning = False, model_as(bool, False);
var Bool 				bb_sensor_failure = False, model_as(bool, False);
var Bool 				bb_sensor_failure_warning = False, model_as(bool, False);
var Bool 				bb_waypoints_completed = False, model_as(bool, False);
var String 				cm_hsd_input, model_as({'cm_surface_task', 'cm_rth_task', 'cm_loiter_task', 'cm_obstacle_avoidance_task', 'cm_tracking_task', 'cm_waypoint_task'}); //cm_hsd_input is a variable that informs the ros nodes what task set the information.
var string 				ddlec_am_path; //this is not being modeled.
var bool 				dd_xy_axis_degradation = False, model_as(bool, False);
var bool 				dd_z_axis_warning = False, model_as(bool, False);
var float 				decision_threshold; // not being modeled
var bool 				emergency_stop_warning = False, model_as(bool, False);
var bool 				event_reallocate_button = False; // node being modeled. this appears to be unused???????
var Range 				fls_range, model_as({'danger_zone', 'safe'}, 'safe'); // represents if we are in the clear or in danger. note: not considering junk_values.
// var HSDCommand 				hsd_pipeline_mapping; // these variables are basically not being used in the current model.
// var HSDCommand 				hsd_to_surface;
// var HSDCommand 				hsd_to_rth;
// var HSDCommand 				hsd_to_waypoint;
// var HSDCommand 				hsd_to_waypoint_rrt;
var HSDCommand 				HSD_out, model_as({'uuv_min_speed', 'uuv_max_speed'}); //HSD_out contains far more information (specifically, heading and depth). however, heading is handled as an enum, and redundant given cm_hsd_input, and depth is basically a constant.
var LEC1OutputAssuredStamped 		lec_dd_am, model_as(bool, False);
var bool 				lec_dd_am_warning = False, model_as(bool, False);
var LEC1OutputAssuredStamped 		lec2_am_l, model_as({'safe', 'speed', 'pipe', 'speed_pipe'});
var bool 				lec2_am_l_speed_warning = False, model_as(bool, False);
var bool 				lec2_am_l_pipe_warning = False, model_as(bool, False);
var LEC1OutputAssuredStamped 		lec2_am_r, model_as({'safe', 'speed', 'pipe', 'speed_pipe'});
var bool 				lec2_am_r_speed_warning = False, model_as(bool, False);
var bool 				lec2_am_r_pipe_warning = False, model_as(bool, False);
var Float32MultiArray 			lec_input; // not modeled
var string 				mission_file = mission_file; //not modeled 
var bool 				next_mission, model_as(bool, False);
var Bool 				pipe_mapping_enable, model_as(bool, False);
var float 				obstacle_min_standoff; //not modeled
var Header 				obstacle_in_view, model_as(bool, False);
var bool 				obstacle_standoff_warning = False, model_as(bool, False);
var Odometry 				odom; // not modeled
var float 				refLat = 38.971203; //not modeled
var float 				refLon = -76.398464; // not modeled
var bool 				rtreach_fence_warning = False; //not modeled....possibly unused?
var Float32             		rtreach_index; //not modeled. redundant in model given rtreach_result
var bool 		 		rtreach_long_term_warning = False, model_as(bool, False);
var bool 				rtreach_obstacle_warning = False; // not modeled.....possibly unused?
var Float32             		rtreach_result, model_as({'safe', 'short', 'long', 'short_long'});
var Float32             		rtreach_unsafe_value; // not modeled....possibly unused?
var bool 				rtreach_warning = False, model_as(bool, False);
var float 				total_degradation=0; // not modeled
var float 				uuv_max_speed; //not modeled. not sure why this is in here but min speed isn't.
//----------------------------------
//MODELING VARIABLES ONLY
//----------------------------------
//these are variables that are not used in code generation. just in the modeling side.
var bool				finished_missions, model_as(bool, False);
var Float32MultiArray 			dd_output, model_as({'safe', 'xy_warn', 'z_warn'}); //these 3 enumerations represent the possible paths in the node
var bool				BLUEROV_SURFACED, model_as(bool, False);
//----------------------------------
//Arguments
//----------------------------------
arg float failsafe_battery_low_threshold = 0.1;
arg bool failsafe_rth_enable =True;
arg float pipe_estimation_good_log_val = 5.0;
arg float speed_good_log_val  = 2.5;
arg float total_degradation_threshold=0.0;
arg float home_reached_threshold =15;
arg integer num_classes=22;
arg float uuv_max_speed = 0.9;
arg float uuv_min_speed = 0.4;
arg string mission_file = "mission_04.yaml";
arg integer ann_input_len=13;
arg bool enable_fault_detection = True;
arg string decision_source="snapshot_am";
arg bool enable_obstacle_avoidance=True;
arg bool enable_emergency_stop=True;
arg integer fls_in_view_window=20;
arg integer fls_in_view_limit=10;
arg string ddlec_am_path="jupyter/admin_BlueROV/FDIR_ALC/SLModel";
arg string ddlec_am_params="{'user_choice':'override_threshold','am_s_threshold':0.5, 'am_threshold':0.5}";
arg integer rtreach_window_size = 25;
arg float rtreach_window_threshold = 0.75;
//-----------------------------------
//Blackboard nodes
//-----------------------------------

//input nodes are assumed to work in the following way (model_ignore means the node is not modeled)
//1. if input IS NOT received, the node returns running and NOTHING updates.
//2. if input IS received, the following hapeens:
//2.1 the node returns running,
//2.2 the topic is copied into the BBVar (unless the topic has been marked model_ignore_topic),
//2.3 all set() commands are executed in order


// input hsd_pipe2bb hsd_pipeline_mapping -> hsd_pipeline_mapping
//     comment  "This node captures HSD input from pipeline tracking node"
// end

// input hsd_surface2bb hsd_to_surface -> hsd_to_surface
//     comment  "This node captures HSD input from surface node"
// end

// input hsd_rth2bb hsd_to_rth -> hsd_to_rth
//     comment  "This node captures HSD input from rth node"
// end

// input hsd_wp2bb hsd_to_waypoint -> hsd_to_waypoint
//     comment  "This node captures HSD input from waypoint node"
// end

// input hsd_wp_rrt2bb hsd_to_waypoint_rrt -> hsd_to_waypoint_rrt
//     comment  "This node captures HSD input from waypoint node"
// end

//regardless, there would be nothing to add modeling wise here anyways
//to enable greater detail with respect to modeling them, simply model the HSD variables


input fls2bb fls_range -> fls_range
    vars obstacle_standoff_warning, obstacle_min_standoff;
    comment  "This node captures the FLS ranges"
    set(obstacle_standoff_warning, (equal, fls_range, 'danger_zone')) //rather than using integer or floats, we've abstraced fls_range to either be safe or danger
end


input fls_warning2bb obstacle_in_view -> obstacle_in_view
    vars bb_fls_warning;
    arg integer fls_in_view_window = fls_in_view_window;
    arg integer fls_in_view_limit = fls_in_view_limit;
    comment  "This node captures the FLS obstacle in view information"
    set(bb_fls_warning, (or, bb_fls_warning, obstacle_in_view))
    set(emergency_stop_warning, (or, emergency_stop_warning, obstacle_in_view)) //emergency stop warning cannot be turned off. at least, not here.
end


input battery2bb pixhawk_hw -> battery 
    vars battery_low_warning;
    arg float failsafe_battery_low_threshold = failsafe_battery_low_threshold;
    comment  "This node captures the state of the battery"
    set(battery_low_warning, (less_than_or_equal, battery, 0)) // 0 is the low battery threshold. to better conserve state, we've limited battery to [0, 1].
end

input ddlecam2bb lec_dd_am -> lec_dd_am
    vars lec_dd_am_warning;
    comment  "This node captures the state of the lec dd assurance monitor"
    set(lec_dd_am_warning, lec_dd_am)  //yeah this one is very copy paste.
end

input rth2bb bb_rth -> bb_rth
    vars bb_rth_warning;
    arg bool failsafe_rth_enable = failsafe_rth_enable;
    comment  "This node captures if the uuv is commanded to return to home"
    set(bb_rth_warning, (or, bb_rth_warning, bb_rth)) // can't unset the need to go home.
end 

input geofence2bb bb_geofence -> bb_geofence
    vars bb_geofence_warning;
    comment  "This node captures if the uuv is within  the geofence"
    set(bb_geofence_warning, (or, bb_geofence_warning, bb_geofence)) //can't unset the geofence.
end

input lec2_am_l_2bb  lec2_left_am -> lec2_am_l
    vars lec2_am_l_speed_warning, lec2_am_l_pipe_warning;
    arg float pipe_estimation_good_log_val = pipe_estimation_good_log_val;
    arg float speed_good_log_val  = speed_good_log_val;
    comment  "This node captures the output of the lec2 assurance monitor left"
    set(lec2_am_l_speed_warning, (or, (equal, lec2_am_l, 'speed'), (equal, lec2_am_l, 'speed_pipe'))) //set the speed warning. basically there are 3 paths the code can take, which are represented by 'safe', 'speed', and 'speed_pipe'.
    set(lec2_am_l_pipe_warning, (or, (equal, lec2_am_l, 'pipe'), (equal, lec2_am_l, 'speed_pipe'))) // set the pipe warning.
end

input lec2_am_r_2bb lec2_right_am -> lec2_am_r
    vars lec2_am_r_speed_warning, lec2_am_r_pipe_warning;
    arg float pipe_estimation_good_log_val = pipe_estimation_good_log_val ;
    arg float speed_good_log_val = speed_good_log_val;
    comment  "This node captures the output of the lec2 assurance monitor right"
    set(lec2_am_r_speed_warning, (or, (equal, lec2_am_r, 'speed'), (equal, lec2_am_r, 'speed_pipe'))) //as above..
    set(lec2_am_r_pipe_warning, (or, (equal, lec2_am_r, 'pipe'), (equal, lec2_am_r, 'speed_pipe')))
end


input pipe_lost2bb bb_pipelost -> bb_pipelost
    vars bb_pipe_lost_warning;
    comment  "This node captures if the pipe is not in visibility of UUV"
    set(bb_pipe_lost_warning, (and, bb_pipelost, (equal, bb_mission, 'pipe_following'))) //we only set this if we're in the pipe_following mission
    //WARNING: the enum 'pipe_following' DOES NOT MATCH what is in the file. this is because this was declared using the enumeration types found in mission_server.
end


input sensor_failure2bb  bb_sensor_failure -> bb_sensor_failure
    vars bb_sensor_failure_warning;
    comment  "This node captures sensor failure"
    set(bb_sensor_failure_warning, (or, bb_sensor_failure_warning, bb_sensor_failure)) //can't unset sensor failure.
end

input waypoints_completed2bb  bb_waypoints_completed -> bb_waypoints_completed
    comment "This node captures if the waypoints are completed"
end 

input home2bb bb_home_dist -> bb_home_dist
    vars bb_home_reached;
    arg float home_reached_threshold = home_reached_threshold;
    comment "This node captures if the uuv is home"
    set(bb_home_reached, (or, bb_home_reached, (less_than, bb_home_dist, 15))) // 15 is home_reached_threshold. Could look into using constants.
end

// input mission2bb bb_mission -> bb_mission
// //    arg bool enable_waypoint_following = False;
//     comment  "This node captures the current mission"
//     model_ignore_topic
//     model_ignore
// end

// input ddlec2bb degradation_detector -> dd_output 
//     vars dd_z_axis_warning, dd_xy_axis_degradation;
//     arg float total_degradation_threshold= total_degradation_threshold;
//     arg integer num_classes = num_classes;
//     arg bool enable_fault_detection = enable_fault_detection;
//     arg string decision_source = decision_source;
//     comment  "This node captures the output of the DD LEC"
//     set(dd_z_axis_warning, (or, (equal, dd_output, 'z_warn'), (and, dd_z_axis_warning, (not, (equal, dd_output, 'safe'))))) //so these are slightly more complicated. there are multiple paths the code can take. these are represented by 'safe', 'xy_warn', and 'z_warn'. It is not possible to set both xy and z at the same time. However, if xy is set, it is possible for z to remain set, and vice versa. they are only unset if SAFE occurs.
//     set(dd_xy_axis_degradation, (or, (equal, dd_output, 'xy_warn'), (and, dd_xy_axis_degradation, (not, (equal, dd_output, 'safe')))))
// end  


//input rtreach2bb rtreach -> rtreach_out
//    var bool emergency_stop_warning = False;
//    arg bool enable_emergency_stop = enable_emergency_stop;
//    comment "This node captures the rtreachabiliy decision over safety"
//end

input rtreach_index2bb rtreach_index-> rtreach_index
    comment "This node captures the rtreachability unsafe hyperrectangle index scaled to 0.0 to 1.0 range"
end
//pretty sure this isn't used.

input rtreach2bb rtreach_result -> rtreach_result
    vars emergency_stop_warning, rtreach_warning, rtreach_long_term_warning;
    arg bool enable_emergency_stop = enable_emergency_stop;
    arg integer rtreach_window_size = 25;
    arg float rtreach_window_threshold = 0.75;
    comment "This node captures the rtreachabiliy decision result over safety"
    set(rtreach_long_term_warning, (or, (equal, rtreach_result, 'long'), (equal, rtreach_result, 'short_long')))
    set(rtreach_warning, (or, (equal, rtreach_result, 'short'), (equal, rtreach_result, 'short_long')))
end


input rtreach_unsafe_value2bb rtreach_unsafe_value -> rtreach_unsafe_value
    vars rtreach_fence_warning, rtreach_obstacle_warning;
    comment "This node captures the rtreachabiliy decision value over safety"
end
//pretty sure this isn't used. 

//-----------------------------------
//checkers for blackboard variables
//-----------------------------------

// no additional changes needed for checks. 

//check is_reallocation_requested 
//        event_reallocate_button==False;

check emergency_stop_fs
        emergency_stop_warning==False;

check obstacle_standoff_fs
        obstacle_standoff_warning == True; //changed by serene for new obstacle avoidance logic

check is_reallocation_requested 
        dd_xy_axis_degradation==False;

check check_dd_am 
        lec_dd_am_warning == False;


check check_lec2am_ls 
        lec2_am_l_speed_warning == True; // changed by serene for new sequence logic


check check_lec2am_rs 
        lec2_am_r_speed_warning == True; // changed by serene for new sequence logic.


check check_lec2am_lp 
        lec2_am_l_pipe_warning == False;


check check_lec2am_rp 
        lec2_am_r_pipe_warning == False;


check check_geofence 
        bb_geofence_warning == True; // changed by serene for new sequence logic


check check_rth 
        bb_rth_warning == True; // changed by serene for new sequence logic


check check_surface 
        bb_home_reached == True; // changed by serene for new sequence logic


check check_pipe_lost 
        bb_pipe_lost_warning == False;


check check_waypoints_completed 
        bb_waypoints_completed == True; //changed by serene for new sequence logic


check check_sensor_failure 
        bb_sensor_failure_warning == True; //changed by serene for new sequence logic


check battery_low_fs 
        battery_low_warning == True; //changed by serene for new sequence logic


check is_track_pipe_mission_requested 
        bb_mission  == "pipe_following";

check is_waypoint_requested 
        bb_mission  == "waypoint_following";

check is_snr_requested 
        bb_mission  == "fdr";

check is_loiter_requested 
        bb_mission  == "loitering";

check dd_z_axis
        dd_z_axis_warning == False;

check dd_xy_axis
        dd_xy_axis_degradation == False;

check rtreach_check
    rtreach_warning==False;

//this check is not in the tree
check rtreach_fence_check
    rtreach_fence_warning == False;

check rtreach_obstacle_check    
    rtreach_obstacle_warning == False;    

check rtreach_long_term_check
    rtreach_long_term_warning == False;

check obstacle_avoidance_required
	bb_obstacle_warning == True;

//-----------------------------------
//standard behavioral nodes
//-----------------------------------

success success_node;
failure failure_node;
running running_node;
running idle;
//running reallocate_task;
//running  dd_lec_task; 

//-----------------------------------
//custom behavioral nodes
//-----------------------------------

//Task nodes are assumed to work in the following way
//all set commands are executed, in order
//the node returns the STATUS value.
//note: modeling does not care which variables are declared in the task node
//modeling is ONLY interested in set() statements.

task emergency_stop_task
     return success
     //nothing set in this. in terms of blackboard at least.
end

task surface_task
    in hsd_to_surface hsd_to_surface_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    set(cm_hsd_input, 'cm_surface_task')
    set(BLUEROV_SURFACED, True)
    return running
    //set the cm_hsd_input, and then return running.
end     

task  rth_task 
    in  hsd_to_rth hsd_to_rth_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    set(cm_hsd_input, 'cm_rth_task')
    return running
end

task  loiter_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input  cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    set(cm_hsd_input, 'cm_loiter_task')
    return running
end    


task obstacle_avoidance
    in hsd_obstacle_avoidance hsd_obstacle_avoidance_; //, hsd_pipeline_mapping  hsd_pipeline_mapping_, hsd_to_waypoint hsd_waypoint_, hsd_to_waypoint_rrt hsd_waypoint_rrt_;
    //out hsd_command hsd_pub;
    vars HSD_out, bb_obstacle_warning, cm_hsd_input;
    arg bool enable_obstacle_avoidance = enable_obstacle_avoidance;
    set(bb_obstacle_warning, (any, True, False))
    set(cm_hsd_input, try(bb_obstacle_warning, 'cm_obstacle_avoidance_task'), cm_hsd_input) //couldn't think of a better way to set this. if bb_obstacle_warning, set to obstacle avoidance. else, don't change.
    return running
end     


task mission_server
    //out bb_mission bb_mission; //bb_mission doesn't publish anything. that's a blackboard variable now.
    vars uuv_max_speed, mission_file, refLat, refLon;
    arg float uuv_max_speed = uuv_max_speed;
    arg string mission_file = mission_file;
    set(finished_missions, try((and, next_mission, finished_missions), (any, True, False)), finished_missions)
    set(bb_rth_warning, try(next_mission, finished_missions), bb_rth_warning)
    set(bb_mission, try((and, next_mission, (not, finished_missions)), (any, 'waypoint_following', 'e_stop', 'pipe_following')), bb_mission)
    set(emergency_stop_warning, try((and, (and, next_mission, (not, finished_missions)), (equal, 'e_stop', bb_mission)), True), emergency_stop_warning)
    set(next_mission, False)
    return running
end

task next_mission
    //in bb_mission bb_mission;
    out next_wp next_wp_;
    vars next_mission;
    set(next_mission, True)
    return success
end  

task  speed_max_task 
    vars HSD_out;
    arg float uuv_max_speed = uuv_max_speed;
    set(HSD_out, 'uuv_max_speed')
    return success
end    

task  speed_min_task 
    vars HSD_out;
    arg float uuv_min_speed=uuv_min_speed;
    set(HSD_out, 'uuv_min_speed')
    return success
end

task  pipe_mapping_enable_task 
    vars pipe_mapping_enable;
    set(pipe_mapping_enable, True)
    return success
end    

task  pipe_mapping_disable_task 
    vars pipe_mapping_enable;
    set(pipe_mapping_enable, False)
    return running
end

task  tracking_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input cm_hsd_input_;
    vars HSD_out, cm_hsd_input;
    set(cm_hsd_input, 'cm_tracking_task')
    return success
end    


//since this node occurs after waypoints_completed2bb and hsd_wp2bb,
//it could remove
//bb_waypoints_completed (info should be stored by w/e waypoints_completed2bb dumped info into)
//hsd_to_way
task  waypoint_task 
    in hsd_to_waypoint hsd_waypoint_, bb_waypoints_completed hsd_waypoint_completed_;
	out cm_hsd_input cm_hsd_input_, next_wp next_wp_;
    vars HSD_out, cm_hsd_input;
    set(cm_hsd_input, 'cm_waypoint_task')
    return success
end   


task  reallocate_task 
    vars total_degradation;
    //set(total_degradation, (any, total_degradation, (min, (addition, total_degradation, 1), 6)))
    return running
end   

task dd_lec_task
    in lec_input lec_input_;
    out degradation_detector degradation_detector_, degradation_detector_am degradation_detector_am_;
    vars dd_z_axis_warning, dd_xy_axis_degradation;
    arg float total_degradation_threshold= total_degradation_threshold;
    //arg integer num_classes = num_classes;
    arg bool enable_fault_detection = enable_fault_detection;
    arg string decision_source = decision_source;
    //the above arguments were copied over by serene
    arg integer num_classes= num_classes;
    arg integer ann_input_len= ann_input_len;
    arg string ddlec_am_path= ddlec_am_path;
    arg string ddlec_am_params= ddlec_am_params;
    set(dd_output, (any, 'safe', 'z_warn', 'xy_warn'))
    set(dd_z_axis_warning, (or, (equal, dd_output, 'z_warn'), (and, dd_z_axis_warning, (not, (equal, dd_output, 'safe'))))) //so these are slightly more complicated. there are multiple paths the code can take. these are represented by 'safe', 'xy_warn', and 'z_warn'. It is not possible to set both xy and z at the same time. However, if xy is set, it is possible for z to remain set, and vice versa. they are only unset if SAFE occurs.
    set(dd_xy_axis_degradation, (or, (equal, dd_output, 'xy_warn'), (and, dd_xy_axis_degradation, (not, (equal, dd_output, 'safe')))))
    //return running
    return failure
end

task publish_HSD_command
	out hsd_command hsd_pub;
    	vars HSD_out;
	return running
end

//-----------------------------------
//tree definition
//-----------------------------------

tree(updatetime=1000,timeout=15)
par BlueROV {
    	par topics2bb {
    		mon battery2bb, rth2bb, geofence2bb
        	mon lec2_am_r_2bb, lec2_am_l_2bb, pipe_lost2bb
		mon sensor_failure2bb
		mon waypoints_completed2bb //assuming this is computed in ros nodes. if it's not, then it should be removed, and tghe tree restructured.
        	// mon mission2bb  //mission2bb is not actually doing anything.
		// mon ddlec2bb //ddlec2bb should be a processing task directly inside dd_lec_task, or vice versa
        	mon fls2bb, fls_warning2bb
 	       	//mon hsd_pipe2bb, hsd_wp2bb, hsd_rth2bb, hsd_surface2bb //this information is being directly subscribed to in the tasks.
        	mon rtreach2bb, rtreach_unsafe_value2bb, rtreach_index2bb
		mon home2bb //this added here by serene. it appears that bb_home_dist is handled in ros nodes.
	}
	// there are 3 ways i can think of to more cleanly handle dd_tasks situation
	// 1. combine dd_lec_task and ddlec2bb into dd_lec_task, that's the first option here. in this case, remove ddlec2bb as a monitor node above.
	// 2. combine dd_lec_task and ddlec2bb into ddlec2bb. that's the comended out section after dd_tasks. in this case, enable ddlec2bb as a monitor node (note: would have to change the topic being listend to)
	// 3. keep both, but reorder them so dd_lec_task occurs before ddlec2bb, and change it so that it's using a blackboard variable instead of publishing (idk why this option would be used).
    	sel dd_tasks {
    		exec dd_lec_task // NEEDS TO RETURN FAILURE. by returning failure, the dd_tasks will then always run reallocate check.
		//alternative, more efficient solution: nix is_reallocation_requested. have this return based on if reallocation is requested.
		//i.e-> if this sets xy_axis_degradation to true, then just return Failure, otherwise, return Success.
		//combine with ddlec2bb
        	do reallocate_check {
			if is_reallocation_requested
			then {
				exec reallocate_task
			}
		}
        	//exec dd_lec_task //moved to before reallocate check. should reduce latency
	}
	// ok, new plan. dd_lec_task was, for all purposes, a monitor node as far as i can tell. could do the below if we re-enable ddlec2bb above, and put the dd_lec_task code into that. ask about this.
        // do reallocate_check {
	// 	if is_reallocation_requested
	// 	then {
	// 		exec reallocate_task
	// 	}
	// }
	//this segement added by serene
	//if a mission ends, then we trigger the next mission. very simple logic.
	seq mission_end {
		sel confirm_mission_ended {
			//this will check for the relevant misison type, and if information about it ending has been received.
			//this list can be expanded as new missions are added.
			//if both checks in a sequence return success, the sequence will return success, and sel confirm_misison_ended will know a mission ended. it will return success
			//then, mission_end will trigger next_mission.
			seq waypoint_mission_end {
        			chk is_waypoint_requested
                    		chk check_waypoints_completed //return success if it completed
			}
			seq pipe_tracking_misison_end {
				chk is_track_pipe_mission_requested
				exec failure_node //placeholder for some check that this mission actually ended. success means it ended.
			}
		}
		exec next_mission //return success
		//NOTE next mission appears to have some code that is specific to waypoint. specifically, it calls next_wp__pub.publish, which seems waypoint specific
		//if this were to be used more generally, that might need to be reworked, but i'm not quite sure what that does.
	}
    	exec mission_server //everything that is used by this comes after it. we should be able to remove all topic publishing. 
    	exec obstacle_avoidance //reworked. does not publish. only detects if obstacle avoidance is happening and sets appropriate heading.
    	sel priorities {
    		//per the conversation in slack, since emergency_stop_task overwrites everything else, this is the most important task and should be handled first.
		//even before obstacle_avoidance.
        	do emergency_stop_check{
        		if emergency_stop_fs
           		then{
                		seq emergency_stop_tasks {
                    			exec emergency_stop_task
                    			exec surface_task
                		}
            		}
        	}
    		chk obstacle_avoidance_required //a new check which checks bb_obstacle_warning
		//^returns success if obstacles need to be avoided. returns failure otherwise, allowing remaining selectors to take place.
		//
		//the surface tasks have been consolidated. if any of the failsafes are triggered, we surface.
		//arguably we should merge the emergency stop check into this, and remove surface task from there.
		//merged into above
		// do battery_check {
		// 	if battery_low_fs 
		// 	then {
		// 		exec surface_task
		// 	}
		// }
        	// do sensor_failure_selector {
		// 	if check_sensor_failure
		// 	then {
		// 		exec surface_task
		// 	}
		// }
		//moved to top.
        	// do emergency_stop_check{
        	// 	if emergency_stop_fs
        	//    	then{
        	//         	seq emergency_stop_tasks {
        	//             		exec emergency_stop_task
        	//             		exec surface_task
        	//         	}
        	//     	}
        	// }
		//this segment recombined with rth
		// do home_reached_selector  {
		// 	if check_surface  
		// 	then {
		// 		exec surface_task 
		// 	}
		// }
		// merged into above.
        	// do obstacle_standoff_check{
        	// 	if obstacle_standoff_fs
        	// 	then{
        	//         	exec surface_task
        	//     	}
        	// }
		//this segment simplified into one thing. logic explained below
		// do rth_selector  {
		// 	if check_rth  
		// 	then {
		// 		par rth_par {
		// 			exec rth_task  
		// 			mon home2bb
		// 		}
		// 	}
		// }
		// do geofence_selector  {
		// 	if check_geofence  
		// 	then {
		// 		par rth_par {
		// 			exec rth_task  
		// 			mon home2bb
		// 		} 
		// 	}
		// }
		//this will first check if we are supposed to be trying to return home.
		//if we are, it will check if we have reached home.
		//if we have, we will surface.
		//if we haven't, we will keep heading home.
		seq rth {
			//if either of these checks succeeds, we continue.
			//if they both fail, we return failure, rth ends.
			sel rth_needed {
				chk check_rth
		    		chk check_geofence
			}
			//we've already confirmed that we arne't home. if we were home, we would have surfaced.
			exec rth_task //return running. or success. w/e. just not failure.
		}
		do pipe_lost_selector  {
			if check_pipe_lost  
			then {
				exec loiter_task
			}
		}
        	seq track_pipe_mission  {
			chk is_track_pipe_mission_requested
                	exec tracking_task //return success
			sel lec2am_speed_cmd {
				//the lec2am_speed_cmd is guaranteed to return success
				seq speed_min {
					//if either speed_warning is enabled, then the speed_warning selector returns success, and we execute speed_min_task
					//if both speed_warningsn fail, speed_warning selector returns failure and we execute speed_max_task
					sel speed_warning {
						chk check_lec2am_ls
						chk check_lec2am_rs
					}
					exec speed_min_task //returns success
				}
                    		exec speed_max_task //returns success
                	}
			//nothing using pipe_mapping_enable. so don't run this code.
                	// sel lec2am_mapping_cmd {
			// 	seq tracking_off {
			// 		sel pipe_warning {
			// 			chk check_lec2am_lp
			// 			chk check_lec2am_rp
			// 		}
                        //     		exec pipe_mapping_disable_task
			// 	}
                    	// 	exec pipe_mapping_enable_task
                	// }
        	}
		//track_pipe_mission re-written above to consolidate various checks.
        	// seq track_pipe_mission  {
		// 	chk is_track_pipe_mission_requested
	        // 	par tracking  {
                // 		exec tracking_task  
                // 		sel lec2am_speed_cmd {
                //     			do lec2am_l_speed_check {
                //         			if check_lec2am_ls
                //         			then {
                //             				exec speed_min_task 
                //         			}
                //     			}
                //     			do lec2am_r_speed_check  {
                //         			if check_lec2am_rs  
                //         			then {
                //             				exec speed_min_task
                //         			}
                //     			}
                //     			exec speed_max_task 
                // 		}	
                // 		sel lec2am_mapping_cmd {
                //     			do lec2am_l_mapping_check  {
                //         			if check_lec2am_lp  
                //         			then {
                //             				exec pipe_mapping_disable_task
                //         			}
                //     			}
                //     			do lec2am_r_mapping_check  {
                //         			if check_lec2am_rp  
                //         			then {
                //             				exec pipe_mapping_disable_task
                //         			}
                //     			}
                //     			exec pipe_mapping_enable_task
                // 		}
		// 	}
            	// 	seq track_pipe_mission_end {
                // 		timer evaluate(0.5)
            	// 	}
        	// }
        	seq waypoint_mission  {
			//because we checked if mission completed earlier, we know that mission is not complete here. we can just execute.
        		chk is_waypoint_requested
            		exec waypoint_task //should be changed to return success. so as to prevent memory problems with sequence nodes.
			//really unfortunate that old py_trees lacked the ability to declare sequence nodes without memory.
		}
        	// seq waypoint_mission  {
        	// 	chk is_waypoint_requested
            	// 	sel waypoint_selector {
            	// 		do waypoints_sif {
                //     			if check_waypoints_completed
                //     			then {
                //         			seq waypoint_end {
                //             				exec next_mission
                //             				exec  loiter_task
                //        				} 
                //     			}
                // 		}
            	// 		exec waypoint_task
            	// 	} 
		// }
		seq failsafe_surface {
			sel failsafe_triggered {
				chk battery_low_fs
				chk check_sensor_failure
				chk obstacle_standoff_fs
				//if any of the above 3 checks return success, failsafe_triggered returns success and we execute surface task
				//finally, even if all 3 return failure, it is possible for us to still surface
				//specifically, if we are supposed to be returning to home, and have reached home, then we surface.
				seq rth_surface {
					//first we check if return to home is needed. return to home is needed if either of these checks return success
					sel rth_needed {
						chk check_rth
		    				chk check_geofence
					}
					//if at least one check returned success, then we check if we've reached home
					chk check_surface
				}
			}
			exec surface_task
		}
        	exec loiter_task
    	}
    	exec publish_HSD_command //new task to publish what command we're doing.
}

//-------done------------------
tick_prerequisite { (not, BLUEROV_SURFACED) } end_tick_prerequisite

specifications {
	// ---------------------------------------------------------------------------------------------------------------
	// -- --1. Do No Harm
	// -- --2. Preserve UUV
	// -- --3. Complete Missions
	// ---------------------------------------------------------------------------------------------------------------

	// -- --1. Do No Harm
	// -- --To ensure no harm is done, we will prioritize avoiding obstacles. Thus we either engage in obstacle avoidance or halt (or are halted) if obstacles are present.
	
	INVARSPEC {(implies, bb_fls_warning 1, (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_surface_task'))) } end_INVARSPEC
	// -- TRUE
	// -- --This specification confirms that if the FLS warning is set to true, then one of the following is true
	// -- --1. We have already surfaced and are done
	// -- --2. We executed the emergecny_stop_task and the command sent to the blueROV is surface

	INVARSPEC { (implies, (and, (not, bb_fls_warning 1), (not, (equal, bb_mission 1, 'e_stop')), bb_obstacle_warning 1), (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_obstacle_avoidance_task'))) } end_INVARSPEC
	// -- TRUE
	// -- --This specification confirms that if the FLS warning is NOT set to true and we are not executing an e_stop mission, then one of the following is true
	// -- --1. We have already surfaced and are done
	// -- --2. The commmand sent to the blueROV is obstacle avoidance

	// -- --between these two specifications we have handled avoiding obstacles. if we cannot go around the obstacle (FLS warning true), then we attempt to stop. If we can go around and are not stopping for some other reason, then we do so.



	// -- --2. Preserve UUV
	// -- --Preservation of the UUV consists of two factors. The first is not crashing into things. Fortunately, this is handled by objective [1. Do No Harm]. Therefore, we are now only interested in the second aspect: ensuring that we surface if a failsafe is set and that the UUV is not lost underwater.


	INVARSPEC { (implies, (and, (not, bb_obstacle_warning 1), (or, emergency_stop_warning 2, battery_low_warning 1, bb_sensor_failure_warning 1, obstacle_standoff_warning 1)), (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_surface_task'))) } end_INVARSPEC
	// -- TRUE
	// -- --This specification confirms that if we're not doing basic obstacle avoidance, then any failsafe being triggered (emergency_stop_warning, battery_low_warning, sensor_failure_warning, obstacle_standoff_warning) mean one of the following are true
	// -- --1. We have already surfaced and are done
	// -- --2. The command sent to the blueROV is surface


	INVARSPEC { (implies, (and, (not, bb_obstacle_warning 1), (and, (or, bb_rth_warning 2, bb_geofence 1), bb_home_reached 1)), (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_surface_task'))) } end_INVARSPEC
	// -- TRUE
	// -- --This specification confirms that if we're not doing basic obstacle avoidance, then if we were returning home and have reached home, one of the following are true
	// -- --1. We have already surfaced and are done
	// -- --2. The command sent to the blueROV is surface


	INVARSPEC { (implies, (and, (not, bb_obstacle_warning 1), (and, (or, bb_rth_warning 2, bb_geofence 1), (not, (equal, cm_hsd_input -1, 'cm_surface_task')))), (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_rth_task'))) } end_INVARSPEC
	// -- TRUE
	// -- --This specification confirms that if we're not doing basic obstacle avoidance and we are not issuing the surface command, then if either geofence_warning or rth_warning have been set, one of the following are true
	// -- --1. We have already surfaced and are done
	// -- --2. The command sent to the blueROV is rth (return to home)

	// -- --Between these three specifications, we have confirmed that if we're not doing obstacle avoidance then failsafes will cause us to surface, reaching home will cause us to surface, and exceeding the geofence or getting an RTH from some other source will cause us to attempt to return to home (and if we reach home we will surface by the 2nd specification).
	// -- --This confirms that the UUV will attempt to preserve itself if it is not prioritizing [1. Do No Harm].



	// -- --3. Complete Missions
	// -- --Finally, if we possible, we would like to focus on completing missions. The two mission types are pipe_tracking and waypoint_following


	INVARSPEC { (implies, (not, (or, (equal, cm_hsd_input -1, 'cm_surface_task'), (equal, cm_hsd_input -1, 'cm_rth_task'), (equal, cm_hsd_input -1, 'cm_obstacle_avoidance_task'))), (or, BLUEROV_SURFACED 0, (equal, cm_hsd_input -1, 'cm_loiter_task'), (equal, cm_hsd_input -1, 'cm_tracking_task'), (equal, cm_hsd_input -1, 'cm_waypoint_task'))) } end_INVARSPEC
	// --TRUE
	// -- --This specification confirms that if we are not busy with surfacing, returning to home, or avoiding obstacles, then one of the following is true
	// -- --1. We have already surfaced and are done
	// -- --2. The command sent is mission related.
	// -- --While this specification is true, it's also trivially true....because the full domain for cm_hsd_input is {cm_surface_task, cm_rth_task, cm_obstacle_avoidance_task} UNION {cm_loiter_task, cm_tracking_task, cm_waypoint_task}...so by excluding the first half in the assertion, the implication is trivially true. In fact, we can even remove var_BLUEROV_SURFACED.
	INVARSPEC { (implies, (not, (or, (equal, cm_hsd_input -1, 'cm_surface_task'), (equal, cm_hsd_input -1, 'cm_rth_task'), (equal, cm_hsd_input -1, 'cm_obstacle_avoidance_task'))), (or, (equal, cm_hsd_input -1, 'cm_loiter_task'), (equal, cm_hsd_input -1, 'cm_tracking_task'), (equal, cm_hsd_input -1, 'cm_waypoint_task'))) } end_INVARSPEC
	// --TRUE
	// -- --The specification still holds. Let us move to more interesting mission statements.


	INVARSPEC { (implies, (not, (or, (equal, cm_hsd_input -1, 'cm_surface_task'), (equal, cm_hsd_input -1, 'cm_rth_task'), (equal, cm_hsd_input -1, 'cm_obstacle_avoidance_task'))), (or, BLUEROV_SURFACED 0, (and, (equal, bb_mission 1, 'pipe_following'), bb_pipe_lost_warning 1, (equal, cm_hsd_input -1, 'cm_loiter_task')), (and, (equal, bb_mission 1, 'pipe_following'), (not, bb_pipe_lost_warning 1), (equal, cm_hsd_input -1, 'cm_tracking_task')), (and, (equal, bb_mission 1, 'waypoint_following'), (equal, cm_hsd_input -1, 'cm_waypoint_task')))) } end_INVARSPEC
	// --TRUE
	// -- --This specification confirms that if we are not busy with surfacing, returning to home, or avoiding obstacles, then one of the following is true
	// -- --1. We have already surfaced and are done
	// -- --2. Our mission is follow a pipe and we have lost the pipe, so we are loitering until it reappears
	// -- --3. Our mission is follow a pipe and we have not lost the pipe, so we are following the pipe
	// -- --4. Our mission is go to a waypoint and we are going to a waypoint


	// -- --Thus, if we are not busy with [1. Do No Harm] or [2. Preserve UUV], we will be doing out best to [3. Complete Missions].


	// ------------------------------------------------------------------------------------------------------------------
	// -- --Misc Tree makes sense checks

	// -- --Speed min and speed_max are mutually exclusive
	INVARSPEC { (implies, (active, speed_min_task), (not, (active, speed_max_task))) } end_INVARSPEC // --TRUE
	INVARSPEC { (implies, (active, speed_max_task), (not, (active, speed_min_task))) } end_INVARSPEC // --TRUE

	// -- --The last loiter task is included, but can never be reached.
	INVARSPEC { (not, (active, loiter_task_1)) } end_INVARSPEC // --TRUE

	// -- --If we have not surfaced, then one of the tasks is selected by the priorities selected, or we're doing obstacle avoidance
	INVARSPEC { (implies, (not, BLUEROV_SURFACED 0), (or, (equal, (count, (active, surface_task), (active, surface_task_1), (active, rth_task), (active, loiter_task), (active, tracking_task), (active, waypoint_task)), 1), (equal, cm_hsd_input -1, 'cm_obstacle_avoidance_task'))) } end_INVARSPEC
	// --TRUE

	INVARSPEC { (not, next_mission -1) } end_INVARSPEC
	// --TRUE
	// -- --We should always be reading the next available mission as soon as possible

} end_specifications