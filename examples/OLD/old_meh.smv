MODULE main
	DEFINE
		children_BlueROV := [1, 2, 3];
		children_priorities := [4, 8];
		children_battery_check := [6, 7];
		children_waypoint_mission := [9, 17];
		children_assurance_monitor_functions := [10, 11];
		children_am_speed_cmd := [12, 16];
		children_am_speed_check := [14, 15];
		--statuses : [BlueROV.status, am_task.status, battery_management_task.status, priorities.status, battery_check_SIF.status, battery_check.status, battery_low_fs.status, surface_task.status, waypoint_mission.status, assurance_monitor_functions.status, ]
	VAR
		statuses : array 0..17 of {success, failure, running, invalid};
		active_node : -1..17;
		BlueROV : node_parallel_synchronised(statuses, 0, -1, children_BlueROV, 3, TRUE);
		am_task : node_set_blackboard_variables(statuses, 1, 0);
		am_task_SET_am_warning : am_task_SET_am_warning_module(active_node,1, blackboard, other_info);
		am_task_SET_status : am_task_SET_status_module(active_node,1, blackboard, other_info);
		battery_management_task : node_set_blackboard_variables(statuses, 2, 0);
		battery_management_task_SET_battery_level : battery_management_task_SET_battery_level_module(active_node,2, blackboard, other_info);
		battery_management_task_SET_battery_low_warning : battery_management_task_SET_battery_low_warning_module(active_node,2, blackboard, other_info);
		battery_management_task_SET_status : battery_management_task_SET_status_module(active_node,2, blackboard, other_info);
		priorities : node_selector(statuses, 3, 0, children_priorities, 2);
		battery_check_SIF : decorator_success_is_failure(statuses, 4, 3, 5);
		battery_check : node_selector(statuses, 5, 4, children_battery_check, 2);
		battery_low_fs : node_check_blackboard_variable_value(statuses, 6, 5, blackboard, 2, battery_low_fs_CHECK_battery_low_warning);
		battery_low_fs_CHECK_battery_low_warning : battery_low_fs_CHECK_battery_low_warning_module(active_node, 6, blackboard, other_info);
		surface_task : node_set_blackboard_variables(statuses, 7, 5);
		surface_task_SET_HSD_out_dot_heading : surface_task_SET_HSD_out_dot_heading_module(active_node,7, blackboard, other_info);
		surface_task_SET_HSD_out_dot_speed : surface_task_SET_HSD_out_dot_speed_module(active_node,7, blackboard, other_info);
		surface_task_SET_HSD_out_dot_depth : surface_task_SET_HSD_out_dot_depth_module(active_node,7, blackboard, other_info);
		surface_task_SET_status : surface_task_SET_status_module(active_node,7, blackboard, other_info);
		waypoint_mission : node_sequence(statuses, 8, 3, children_waypoint_mission, 2);
		assurance_monitor_functions : node_parallel_synchronised(statuses, 9, 8, children_assurance_monitor_functions, 2, TRUE);
		waypoint_task : node_set_blackboard_variables(statuses, 10, 9);
		waypoint_task_SET_p_mission_len : waypoint_task_SET_p_mission_len_module(active_node,10, blackboard, other_info);
		waypoint_task_SET_waypoints_completed : waypoint_task_SET_waypoints_completed_module(active_node,10, blackboard, other_info);
		waypoint_task_SET_HSD_out_dot_heading : waypoint_task_SET_HSD_out_dot_heading_module(active_node,10, blackboard, other_info);
		waypoint_task_SET_HSD_out_dot_speed : waypoint_task_SET_HSD_out_dot_speed_module(active_node,10, blackboard, other_info);
		waypoint_task_SET_HSD_out_dot_depth : waypoint_task_SET_HSD_out_dot_depth_module(active_node,10, blackboard, other_info);
		waypoint_task_SET_status : waypoint_task_SET_status_module(active_node,10, blackboard, other_info);
		am_speed_cmd : node_selector(statuses, 11, 9, children_am_speed_cmd, 2);
		am_speed_check_SIF : decorator_success_is_failure(statuses, 12, 11, 13);
		am_speed_check : node_selector(statuses, 13, 12, children_am_speed_check, 2);
		check_am : node_check_blackboard_variable_value(statuses, 14, 13, blackboard, 0, check_am_CHECK_am_warning);
		check_am_CHECK_am_warning : check_am_CHECK_am_warning_module(active_node, 14, blackboard, other_info);
		speed_min_task : node_set_blackboard_variables(statuses, 15, 13);
		speed_min_task_SET_HSD_out_dot_heading : speed_min_task_SET_HSD_out_dot_heading_module(active_node,15, blackboard, other_info);
		speed_min_task_SET_HSD_out_dot_speed : speed_min_task_SET_HSD_out_dot_speed_module(active_node,15, blackboard, other_info);
		speed_min_task_SET_HSD_out_dot_depth : speed_min_task_SET_HSD_out_dot_depth_module(active_node,15, blackboard, other_info);
		speed_min_task_SET_status : speed_min_task_SET_status_module(active_node,15, blackboard, other_info);
		speed_max_task : node_set_blackboard_variables(statuses, 16, 11);
		speed_max_task_SET_HSD_out_dot_heading : speed_max_task_SET_HSD_out_dot_heading_module(active_node,16, blackboard, other_info);
		speed_max_task_SET_HSD_out_dot_speed : speed_max_task_SET_HSD_out_dot_speed_module(active_node,16, blackboard, other_info);
		speed_max_task_SET_HSD_out_dot_depth : speed_max_task_SET_HSD_out_dot_depth_module(active_node,16, blackboard, other_info);
		speed_max_task_SET_status : speed_max_task_SET_status_module(active_node,16, blackboard, other_info);
		loiter_task : node_set_blackboard_variables(statuses, 17, 8);
		loiter_task_SET_HSD_out_dot_heading : loiter_task_SET_HSD_out_dot_heading_module(active_node,17, blackboard, other_info);
		loiter_task_SET_HSD_out_dot_speed : loiter_task_SET_HSD_out_dot_speed_module(active_node,17, blackboard, other_info);
		loiter_task_SET_HSD_out_dot_depth : loiter_task_SET_HSD_out_dot_depth_module(active_node,17, blackboard, other_info);
		loiter_task_SET_status : loiter_task_SET_status_module(active_node,17, blackboard, other_info);
		blackboard : blackboard_module;
		other_info : other_info_module;
	INVAR
		statuses[0] = BlueROV.status;
	INVAR
		active_node = BlueROV.active_node;
	INVAR
		statuses[1] = am_task.status;
	INVAR
		active_node = am_task.active_node;
	INVAR
		statuses[2] = battery_management_task.status;
	INVAR
		active_node = battery_management_task.active_node;
	INVAR
		statuses[3] = priorities.status;
	INVAR
		active_node = priorities.active_node;
	INVAR
		statuses[4] = battery_check_SIF.status;
	INVAR
		active_node = battery_check_SIF.active_node;
	INVAR
		statuses[5] = battery_check.status;
	INVAR
		active_node = battery_check.active_node;
	INVAR
		statuses[6] = battery_low_fs.status;
	INVAR
		active_node = battery_low_fs.active_node;
	INVAR
		statuses[7] = surface_task.status;
	INVAR
		active_node = surface_task.active_node;
	INVAR
		statuses[8] = waypoint_mission.status;
	INVAR
		active_node = waypoint_mission.active_node;
	INVAR
		statuses[9] = assurance_monitor_functions.status;
	INVAR
		active_node = assurance_monitor_functions.active_node;
	INVAR
		statuses[10] = waypoint_task.status;
	INVAR
		active_node = waypoint_task.active_node;
	INVAR
		statuses[11] = am_speed_cmd.status;
	INVAR
		active_node = am_speed_cmd.active_node;
	INVAR
		statuses[12] = am_speed_check_SIF.status;
	INVAR
		active_node = am_speed_check_SIF.active_node;
	INVAR
		statuses[13] = am_speed_check.status;
	INVAR
		active_node = am_speed_check.active_node;
	INVAR
		statuses[14] = check_am.status;
	INVAR
		active_node = check_am.active_node;
	INVAR
		statuses[15] = speed_min_task.status;
	INVAR
		active_node = speed_min_task.active_node;
	INVAR
		statuses[16] = speed_max_task.status;
	INVAR
		active_node = speed_max_task.active_node;
	INVAR
		statuses[17] = loiter_task.status;
	INVAR
		active_node = loiter_task.active_node;
	INVAR
		blackboard.variable_exists[blackboard.am_warning] = am_task_SET_am_warning.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.am_warning] = am_task_SET_am_warning.am_warning;
	INVAR
		am_task.status = am_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.battery_level] = battery_management_task_SET_battery_level.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.battery_level] = battery_management_task_SET_battery_level.battery_level;
	INVAR
		blackboard.variable_exists[blackboard.battery_low_warning] = battery_management_task_SET_battery_low_warning.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.battery_low_warning] = battery_management_task_SET_battery_low_warning.battery_low_warning;
	INVAR
		battery_management_task.status = battery_management_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_heading] = surface_task_SET_HSD_out_dot_heading.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_heading] = surface_task_SET_HSD_out_dot_heading.HSD_out_dot_heading;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_speed] = surface_task_SET_HSD_out_dot_speed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_speed] = surface_task_SET_HSD_out_dot_speed.HSD_out_dot_speed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_depth] = surface_task_SET_HSD_out_dot_depth.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_depth] = surface_task_SET_HSD_out_dot_depth.HSD_out_dot_depth;
	INVAR
		surface_task.status = surface_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.p_mission_len] = waypoint_task_SET_p_mission_len.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.p_mission_len] = waypoint_task_SET_p_mission_len.p_mission_len;
	INVAR
		blackboard.variable_exists[blackboard.waypoints_completed] = waypoint_task_SET_waypoints_completed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.waypoints_completed] = waypoint_task_SET_waypoints_completed.waypoints_completed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_heading] = waypoint_task_SET_HSD_out_dot_heading.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_heading] = waypoint_task_SET_HSD_out_dot_heading.HSD_out_dot_heading;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_speed] = waypoint_task_SET_HSD_out_dot_speed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_speed] = waypoint_task_SET_HSD_out_dot_speed.HSD_out_dot_speed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_depth] = waypoint_task_SET_HSD_out_dot_depth.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_depth] = waypoint_task_SET_HSD_out_dot_depth.HSD_out_dot_depth;
	INVAR
		waypoint_task.status = waypoint_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_heading] = speed_min_task_SET_HSD_out_dot_heading.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_heading] = speed_min_task_SET_HSD_out_dot_heading.HSD_out_dot_heading;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_speed] = speed_min_task_SET_HSD_out_dot_speed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_speed] = speed_min_task_SET_HSD_out_dot_speed.HSD_out_dot_speed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_depth] = speed_min_task_SET_HSD_out_dot_depth.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_depth] = speed_min_task_SET_HSD_out_dot_depth.HSD_out_dot_depth;
	INVAR
		speed_min_task.status = speed_min_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_heading] = speed_max_task_SET_HSD_out_dot_heading.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_heading] = speed_max_task_SET_HSD_out_dot_heading.HSD_out_dot_heading;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_speed] = speed_max_task_SET_HSD_out_dot_speed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_speed] = speed_max_task_SET_HSD_out_dot_speed.HSD_out_dot_speed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_depth] = speed_max_task_SET_HSD_out_dot_depth.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_depth] = speed_max_task_SET_HSD_out_dot_depth.HSD_out_dot_depth;
	INVAR
		speed_max_task.status = speed_max_task_SET_status.status;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_heading] = loiter_task_SET_HSD_out_dot_heading.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_heading] = loiter_task_SET_HSD_out_dot_heading.HSD_out_dot_heading;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_speed] = loiter_task_SET_HSD_out_dot_speed.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_speed] = loiter_task_SET_HSD_out_dot_speed.HSD_out_dot_speed;
	INVAR
		blackboard.variable_exists[blackboard.HSD_out_dot_depth] = loiter_task_SET_HSD_out_dot_depth.blackboard_var_exists;
	INVAR
		blackboard.variable[blackboard.HSD_out_dot_depth] = loiter_task_SET_HSD_out_dot_depth.HSD_out_dot_depth;
	INVAR
		loiter_task.status = loiter_task_SET_status.status;
	ASSIGN
		init(active_node) := -1;
		next(active_node) :=
			case
				(-1 = active_node) : 0;
				TRUE : -1..17;
			esac;
		next(statuses[0]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[0] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[0] = running) : statuses[0];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[1]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[1] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[1] = running) : statuses[1];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[2]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[2] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[2] = running) : statuses[2];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[3]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[3] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[3] = running) : statuses[3];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[4]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[4] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[4] = running) : statuses[4];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[5]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[5] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[5] = running) : statuses[5];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[6]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[6] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[6] = running) : statuses[6];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[7]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[7] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[7] = running) : statuses[7];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[8]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[8] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[8] = running) : statuses[8];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[9]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[9] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[9] = running) : statuses[9];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[10]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[10] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[10] = running) : statuses[10];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[11]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[11] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[11] = running) : statuses[11];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[12]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[12] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[12] = running) : statuses[12];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[13]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[13] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[13] = running) : statuses[13];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[14]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[14] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[14] = running) : statuses[14];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[15]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[15] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[15] = running) : statuses[15];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[16]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[16] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[16] = running) : statuses[16];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(statuses[17]) :=
			case
				(-1 = active_node) & (statuses[0] = running) & (statuses[17] = running) : invalid;
				(-1 = active_node) & (statuses[0] = running) & !(statuses[17] = running) : statuses[17];
				(-1 = active_node) & !(statuses[0] = running) : invalid;
				TRUE : {success, failure, running, invalid};
			esac;
		next(blackboard.variable[0]) := 
			case
				(active_node in {1}) : 0..1;
				TRUE : blackboard.variable[0];
			esac;
		next(blackboard.variable_exists[0]) := 
			case
				(active_node in {1}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[0];
			esac;
		next(blackboard.variable[1]) := 
			case
				(active_node in {2}) : 0..1;
				TRUE : blackboard.variable[1];
			esac;
		next(blackboard.variable_exists[1]) := 
			case
				(active_node in {2}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[1];
			esac;
		next(blackboard.variable[2]) := 
			case
				(active_node in {2}) : 0..1;
				TRUE : blackboard.variable[2];
			esac;
		next(blackboard.variable_exists[2]) := 
			case
				(active_node in {2}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[2];
			esac;
		next(blackboard.variable[3]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : 0..1;
				TRUE : blackboard.variable[3];
			esac;
		next(blackboard.variable_exists[3]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[3];
			esac;
		next(blackboard.variable[4]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : 0..1;
				TRUE : blackboard.variable[4];
			esac;
		next(blackboard.variable_exists[4]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[4];
			esac;
		next(blackboard.variable[5]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : 0..1;
				TRUE : blackboard.variable[5];
			esac;
		next(blackboard.variable_exists[5]) := 
			case
				(active_node in {7, 10, 15, 16, 17}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[5];
			esac;
		next(blackboard.variable[6]) := 
			case
				(active_node in {10}) : 0..1;
				TRUE : blackboard.variable[6];
			esac;
		next(blackboard.variable_exists[6]) := 
			case
				(active_node in {10}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[6];
			esac;
		next(blackboard.variable[7]) := 
			case
				(active_node in {10}) : 0..1;
				TRUE : blackboard.variable[7];
			esac;
		next(blackboard.variable_exists[7]) := 
			case
				(active_node in {10}) : {FALSE, TRUE};
				TRUE : blackboard.variable_exists[7];
			esac;
--LTLSPEC NAME Obvious1 := G(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> F(active_node = 7));
LTLSPEC G(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> F(active_node = 7));
--no counterexample should be found, proving nothing. lol.



--LTLSPEC NAME ObviousCE := G(blackboard.variable[2] = 1);
--LTLSPEC G(blackboard.variable[2] = 1);
--uh....idk tbh. this one is obviously just false


--LTLSPEC NAME CE1 := G(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> G(!(active_node = 7)));
LTLSPEC G(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> G(!(active_node = 7)));
--a counter example should be found, proving that if low warning state occurs, eventually active_node=7, meaning we triggered surface_task. takes 80 steps for this to occur though.




--LTLSPEC NAME CE2 := G!((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE));
--LTLSPEC G!((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE));
--a counter example should be found, proving that the low warning state can occur. takes until step 74 for this to happen though. lmao. oh god.


--INVARSPEC NAME Invar1 := (blackboard.variable[1] < 1  & blackboard.variable_exists[1])  <-> (blackboard.variable[2] = 1 & blackboard.variable_exists[2]);
INVARSPEC (blackboard.variable[1] < 1 & blackboard.variable_exists[1])  <-> (blackboard.variable[2] = 1 & blackboard.variable_exists[2]);



--CTLSPEC NAME CTL1 := AG(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> AF(active_node = 7));
--CTLSPEC AG(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> AF(active_node = 7));

--the above is actually just straight forward trying to prove that if we hit low battery, we eventually hit active_node=7 (surface task)



--CTLSPEC NAME CTL2 := EG(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> AF(!(active_node = 7)));
--CTLSPEC EG(((blackboard.variable[2] = 1) & (blackboard.variable_exists[2] = TRUE)) -> AF(!(active_node = 7)));

--the above is a counterexample attempt. there exists a

MODULE node_parallel_synchronised(statuses, id, parent, children, num_children, parallel_policy_all)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
		num_running : 0..num_children;
		num_success : 0..num_children;
		num_failure : 0..num_children;
		cur_child : 0..num_children;
	ASSIGN
		init(status) := invalid;
		init(cur_child) := 0;
		init(num_running) := 0;
		init(num_success) := 0;
		init(num_failure) := 0;
		next(num_running) :=
			case
				(id = active_node) & (statuses[children[cur_child]] = running) : num_running+1;
				(id = active_node) & !(statuses[children[cur_child]] = running) : num_running;
				(active_node = -1) : 0;
				TRUE : num_running;
			esac;
		next(num_success) :=
			case
				(id = active_node) & (statuses[children[cur_child]] = success) : num_success+1;
				(id = active_node) & !(statuses[children[cur_child]] = success) : num_success;
				(active_node = -1) : 0;
				TRUE : num_success;
			esac;
		next(num_failure) :=
			case
				(id = active_node) & (statuses[children[cur_child]] = failure) : num_failure+1;
				(id = active_node) & !(statuses[children[cur_child]] = failure) : num_failure;
				(active_node = -1) : 0;
				TRUE : num_failure;
			esac;
		next(status) :=
			case
				(id = active_node) & (cur_child + 1 < num_children) : invalid;
				(id = active_node) & ((statuses[children[cur_child]] = invalid) | ((num_success + num_failure + num_running + 1) < num_children))  : invalid;
				(id = active_node) & ((num_failure > 0) | (statuses[children[cur_child]] = failure)) : failure;
				(id = active_node) & ((num_running = 0) & (statuses[children[cur_child]] = success)) : success;
				(id = active_node) & (parallel_policy_all) : failure;
				(id = active_node) & ((num_success > 0) | (statuses[children[cur_child]] = success)) : success;
				(id = active_node) : running;
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) & (statuses[children[cur_child]] = invalid) : children[cur_child];
				(id = active_node) & (cur_child + 1 = num_children) : parent;
				(id = active_node) & (cur_child + 1 < num_children) & (statuses[children[cur_child + 1]] = invalid) : children[cur_child+1];
				(id = active_node) & (cur_child + 1 < num_children) & !(statuses[children[cur_child + 1]] = invalid) : active_node;
				TRUE : -1..17;
			esac;
		next(cur_child) :=
			case
				(id = active_node) & (statuses[children[cur_child]] = invalid) : cur_child;
				(id = active_node) & (cur_child + 1 < num_children) : cur_child + 1;
				(id = active_node) & (cur_child + 1 = num_children) : cur_child;
				(active_node = -1) & !(statuses[0] = running) : 0;
				TRUE : cur_child;
			esac;
MODULE node_set_blackboard_variables(statuses, id, parent)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(id = active_node) : {failure, running, success};
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) : parent;
				TRUE : -1..17;
			esac;

MODULE node_selector(statuses, id, parent, children, num_children)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
		cur_child : 0..num_children;
	ASSIGN
		init(status) := invalid;
		init(cur_child) := 0;
		next(status) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : invalid;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = success) : success;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = failure) : invalid;
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = failure) : failure;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : running;
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : children[cur_child];
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = success) : parent;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = failure) : children[cur_child+1];
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = failure) : parent;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : parent;
				TRUE : -1..17;
			esac;
		next(cur_child) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : cur_child;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = success) : cur_child;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = failure) : cur_child+1;
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = failure) : cur_child;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : cur_child;
				(active_node = -1) & !(statuses[0] = running) : 0;
				TRUE : cur_child;
			esac;
MODULE decorator_success_is_failure(statuses, id, parent, child)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(id = active_node) & !(statuses[child] = success) : statuses[child];
				(id = active_node) & (statuses[child] = success) : failure;
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) & (statuses[child] = invalid) : child;
				(id = active_node) & !(statuses[child] = invalid) : parent;
				TRUE : -1..17;
			esac;

MODULE node_check_blackboard_variable_value(statuses, id, parent, blackboard, variable, check)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
	ASSIGN
		init(status) := invalid;
		next(status) :=
			case
				(id = active_node) & !(blackboard.variable_exists[variable]) : failure;
				(id = active_node) & (blackboard.variable_exists[variable]) & (check.result) : success;
				(id = active_node) & (blackboard.variable_exists[variable]) & !(check.result) : failure;
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) : parent;
				TRUE : -1..17;
			esac;

MODULE node_sequence(statuses, id, parent, children, num_children)
	VAR
		status : {success, failure, running, invalid};
		active_node : -1..17;
		cur_child : 0..num_children;
	ASSIGN
		init(status) := invalid;
		init(cur_child) := 0;
		next(status) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : invalid;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = failure) : failure;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = success) : invalid;
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = success) : success;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : running;
				(active_node = -1) & (statuses[0] = running) & (status = running)  : invalid;
				(active_node = -1) & !(statuses[0] = running) : invalid;
				TRUE : status;
			esac;
		next(active_node) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : children[cur_child];
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = failure) : parent;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = success) : children[cur_child+1];
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = success) : parent;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : parent;
				TRUE : -1..17;
			esac;
		next(cur_child) :=
			case
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = invalid) : cur_child;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = failure) : cur_child;
				(id = active_node) & (cur_child+1 < num_children) & (statuses[children[cur_child]] = success) : cur_child+1;
				(id = active_node) & (cur_child+1 = num_children) & (statuses[children[cur_child]] = success) : cur_child;
				(id = active_node) & (cur_child < num_children) & (statuses[children[cur_child]] = running) : cur_child;
				(active_node = -1) & !(statuses[0] = running) : 0;
				TRUE : cur_child;
			esac;
MODULE blackboard_module
	DEFINE
		am_warning := 0;
		battery_level := 1;
		battery_low_warning := 2;
		HSD_out_dot_heading := 3;
		HSD_out_dot_speed := 4;
		HSD_out_dot_depth := 5;
		p_mission_len := 6;
		waypoints_completed := 7;
	VAR
		variable : array 0..7 of 0..1;
		variable_exists : array 0..7 of boolean;
	ASSIGN
		init(variable_exists[0]) := FALSE;
		init(variable_exists[1]) := FALSE;
		init(variable_exists[2]) := FALSE;
		init(variable_exists[3]) := FALSE;
		init(variable_exists[4]) := FALSE;
		init(variable_exists[5]) := FALSE;
		init(variable_exists[6]) := FALSE;
		init(variable_exists[7]) := FALSE;

--am_warning : 0
----am_task
--battery_level : 1
----battery_management_task
--battery_low_warning : 2
----battery_management_task
--HSD_out_dot_heading : 3
----surface_task
----waypoint_task
----speed_min_task
----speed_max_task
----loiter_task
--HSD_out_dot_speed : 4
----surface_task
----waypoint_task
----speed_min_task
----speed_max_task
----loiter_task
--HSD_out_dot_depth : 5
----surface_task
----waypoint_task
----speed_min_task
----speed_max_task
----loiter_task
--p_mission_len : 6
----waypoint_task
--waypoints_completed : 7
----waypoint_task
MODULE other_info_module
	VAR
		battery_level : 0..1;
	ASSIGN
		init(battery_level) := 0..1;
		next(battery_level) := 0..1;
MODULE am_task_SET_am_warning_module(active_node, node_id, blackboard, other_info)
	VAR
		am_warning : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(am_warning) :=
			case
				(active_node = node_id) : 0..1;--allow it to be either state.
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
		
MODULE am_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;

MODULE battery_management_task_SET_battery_level_module(active_node, node_id, blackboard, other_info)
	VAR
		battery_level : 0..1;
		blackboard_var_exists : boolean;
		actual_var : 0..1;
	INVAR
		other_info.battery_level = actual_var;
	ASSIGN
		init(actual_var) := 1;
		next(actual_var) :=
			case
				(active_node = node_id) & (actual_var > 0) : actual_var - 1;
				TRUE : actual_var;
			esac;
		next(battery_level) :=
			case
				(active_node = node_id) : (actual_var);
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;


MODULE battery_management_task_SET_battery_low_warning_module(active_node, node_id, blackboard, other_info)
	VAR
		battery_low_warning : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(battery_low_warning) :=
			case
				(active_node = node_id) & (other_info.battery_level < 1) : 1;
				(active_node = node_id) & (other_info.battery_level >= 1) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;

MODULE battery_management_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;


MODULE battery_low_fs_CHECK_battery_low_warning_module(active_node, node_id, blackboard, other_info)
	VAR
       		result : boolean;
	INVAR
		result = (blackboard.variable[blackboard.battery_low_warning] = 0);

MODULE surface_task_SET_HSD_out_dot_heading_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_heading : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_heading) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE surface_task_SET_HSD_out_dot_speed_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_speed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_speed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE surface_task_SET_HSD_out_dot_depth_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_depth : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_depth) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;

MODULE surface_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;
MODULE waypoint_task_SET_p_mission_len_module(active_node, node_id, blackboard, other_info)
	VAR
		p_mission_len : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(p_mission_len) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE waypoint_task_SET_waypoints_completed_module(active_node, node_id, blackboard, other_info)
	VAR
		waypoints_completed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(waypoints_completed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE waypoint_task_SET_HSD_out_dot_heading_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_heading : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_heading) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE waypoint_task_SET_HSD_out_dot_speed_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_speed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_speed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE waypoint_task_SET_HSD_out_dot_depth_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_depth : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_depth) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE waypoint_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;

MODULE check_am_CHECK_am_warning_module(active_node, node_id, blackboard, other_info)
	VAR
       		result : boolean;
	INVAR
		result = (blackboard.variable[0] = 0);

MODULE speed_min_task_SET_HSD_out_dot_heading_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_heading : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_heading) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_min_task_SET_HSD_out_dot_speed_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_speed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_speed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_min_task_SET_HSD_out_dot_depth_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_depth : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_depth) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_min_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;

MODULE speed_max_task_SET_HSD_out_dot_heading_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_heading : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_heading) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_max_task_SET_HSD_out_dot_speed_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_speed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_speed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_max_task_SET_HSD_out_dot_depth_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_depth : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_depth) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE speed_max_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;
MODULE loiter_task_SET_HSD_out_dot_heading_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_heading : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_heading) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE loiter_task_SET_HSD_out_dot_speed_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_speed : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_speed) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE loiter_task_SET_HSD_out_dot_depth_module(active_node, node_id, blackboard, other_info)
	VAR
		HSD_out_dot_depth : 0..1;
		blackboard_var_exists : boolean;
	ASSIGN
		next(HSD_out_dot_depth) :=
			case
				(active_node = node_id) : 0;
				TRUE : 0..1;
			esac;
		next(blackboard_var_exists) :=
			case
				(active_node = node_id) : TRUE;
				TRUE : {FALSE, TRUE};
			esac;
MODULE loiter_task_SET_status_module(active_node, node_id, blackboard, other_info)
	VAR
		status : {failure, running, success, invalid};
	ASSIGN
		next(status) :=
			case
				(active_node = node_id) : success;
				(active_node = -1) & !(status = running) : invalid;
				TRUE : {failure, running, success, invalid};
			esac;
