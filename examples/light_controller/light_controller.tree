#comment#

Hello! This is the Light Controller Example. The premise is there is a tunnel with an East entrance and a West entrance. The tunnel is only wide enough for one car, but cars need to be able to in on both sides. Therefore, a Light Signal is used to tell cars when it is safe to enter.

Some notes:
Indentation is optional, but suggested (for clarity).
After any closing bracket (}), you can type end_X where X is how the bracket was opened. This is optional, but can help improve readability in some cases.
Spacing is suggested, but frequently optional. thus result{0} and result { 0 } are both acceptable. Spacing between words is required.
New lines are always optional, but suggested.

Code:
At various points, you will need to specify values. In these cases, we utilize code statements, which generally look as follows
CONSTANT | VARIABLE | (func, val1, val2, ... valk)
each val can be another code statement, so nesting is possible. You may always include more parantheses.

Finally, each section with no indentation is required (except tick prequisite), but can be left empty.

E.G., your file must have constants {} as the first section, but leaving it empty is fine.

#end_comment#



constants {
	#comment# constants are used to synchronize values in a .tree file. #end_comment#
	
	max_counter = 4

	#comment# if you have more than one constant, we suggest putting them on separate lines.
	example1 = 1
	example2 = 2
	#end_comment#
	#comment# however, the following is also acceptable
	example1 = 1 example2 = 2
	#end_comment#
} end_constants

variables {
	#comment# Variables have several options
	variable {
		bl | env | local
		my_var_name
		VAR | FROZENVAR | DEFINE
		[min_val, max_val] | {int1, int2, ... intK} | {'enum1', 'enum2', ... 'enumK'} | BOOLEAN
		assign {
			case {some_condition} result{some_result}
			case {some_other_condition} result{some_other_result}
			result { default_result}
		}
	}
	bl :: means the variable is a blackboard variable. It represents shared memory all nodes can access.
	env :: means the variable is an environment variable. Nodes can sometimes access environment variables. Environment variables can be updated in between ticks.
	local :: means the variable is specific to each instance of a node that uses it.
	VAR :: variable has state, can change between ticks.
	FROZENVAR :: variable has state, cannot change between ticks.
	DEFINE :: variable is a macro that is replaced with the condition it represents
	The assign will determine the initial value. You must have a default result. case-result pairs are optional
	#end_comment#

	#comment# variables are initialized in order. If var B depends on var A, then A must be declared first #end_comment#
	variable {
		bl fairness_counter VAR [0, 'max_counter'] #comment# max_counter is a constant equal to 4 #end_comment#
		assign {
			result {0}
		}
	}
	variable {
		bl direction VAR {'east_to_west', 'west_to_east'}
		assign {
			result {'east_to_west'}
		}
	}
	variable {
		env tunnel_state VAR {'empty', 'east_to_west', 'west_to_east'}
		assign {
			result {'empty'}
		}
	}
	variable {
		env east_cars VAR BOOLEAN
		assign {
			result {True, False}
		}
	}
	variable {
		env west_cars VAR BOOLEAN
		assign {
			result {True, False}
		}
	}
	variable {
		env west_and_east_cars DEFINE BOOLEAN
		assign {
			result {(and, west_cars, east_cars)}
		}
	}
	variable {
		env west_light VAR BOOLEAN
		assign {
			result {False}
		}
	}
	variable {
		env east_light VAR BOOLEAN
		assign {
			result {False}
		}
	}
} end_variables

#comment#
In general, if we want to update a variable, we use a variable statement, which looks as follows:

variable_statement {
	var_name
	assign {
		case {some_condition} result {some_result}
		case {some_condition} result {some_other_result, some_other_result2}
		result {default_result1, default_result2, default_result3}
	}
}

You must have a default result, but the case-result pairs are optional. If you specify multiple results, you comma seperate them, and this indicates nondeterminism.
#end_comment#


environment_update {
	#comment# environment updates are used to update environment variables in between ticks. The updates will take place in the order they are presented #end_comment#
	variable_statement {
		tunnel_state
		assign {
			case {west_light}
			result {'empty', 'west_to_east'}
			case {east_light}
			result {'empty', 'east_to_west'}
			result {'empty', tunnel_state}
		}
	}
	variable_statement {
		west_cars
		assign {
			case {west_light}
			result {True, False}
			result {True, west_cars}
		}
	}
	variable_statement {
		east_cars
		assign {
			case {east_light}
			result {True, False}
			result {True, east_cars}
		}
	}
} end_environment_update


#comment# We are now done with the variable section. Welcome to the node section #end_comment#

checks {
	#comment# checks are used to check values of blackboard variables #end_comment#
	check {
		check_fairness #comment# the name of the check #end_comment#
		read_variables {fairness_counter} #comment# what variables are read by this node (used for python generation). if multiple, space seperate them (no comma) #end_comment#
		condition { (less_than, fairness_counter, 'max_counter')} #comment# a condition #end_comment#
	}
} end_checks

environment_checks {
	#comment# environment checks are used to check values of blackboard variables or environment variables #end_comment#
	check_environment {
		check_west_and_east_cars
		read_variables {} #comment# this still only specifies BLACKBOARD variables. #end_comment#
		condition {west_and_east_cars}
	}
	check_environment {
		check_west_cars
		read_variables {}
		condition {west_cars}
	}
	check_environment {
		check_east_cars
		read_variables {}
		condition {east_cars}
	}
	check_environment {
		check_safety
		read_variables {direction}
		condition {(or, (equal, tunnel_state, 'empty'), (equal, direction, tunnel_state))}
	}
} end_environment_checks

actions {
	#comment# action nodes actually do stuff #end_comment#
	action {
		swap_direction #comment# name of the node #end_comment#
		local_variables {} #comment# the local variables the node uses #end_comment#
		read_variables {} #comment# the blackboard variables that are read by this node #end_comment#
		write_variables {direction fairness_counter} #comment# the blackboard variables that are written to #end_comment#
		initial_values {} #comment# initial values for local variables #end_comment#
		update {
			#comment# the update segments consists of variable statements and a return statement. The return statement doesn't need to be last.
			You must have a return statement, but that is the only requirement.
			If you are reading/writing environment variables, you need special syntax, which you will see later.
			Variable updates occur in order.
			#end_comment#
			variable_statement {
				direction
				assign {
					case {(equal, direction, 'west_to_east')}
					result {'east_to_west'}
					result {'west_to_east'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				#comment# we could have cases in here too. but, the results MUST be deterministic #end_comment#
				result { success}
			}
		}
	}
	action {
		set_west
		local_variables {}
		read_variables {}
		write_variables {direction fairness_counter}
		initial_values {}
		update {
			variable_statement {
				direction
				assign {
					result {'west_to_east'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
	action {
		set_east
		local_variables {}
		read_variables {}
		write_variables {direction fairness_counter}
		initial_values {}
		update {
			variable_statement {
				direction
				assign {
					result {'east_to_west'}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {0}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
	action {
		#comment# this action writes to the environment, therefore, we will need the write environment block in the update block #end_comment#
		send_light_signal
		local_variables {}
		read_variables {direction}
		write_variables {fairness_counter}
		initial_values {}
		update {
			write_environment {
				light_signal_func #comment# the name of this update #end_comment#
				#comment# each of these variable statements must update an environment variable.
				These updates take place in order, but occur at the end of the tick (before updates between ticks occur).
				This represents the fact that doing stuff in the environment takes time, while the tree should be isntant.
				If an update SHOULD be instant, it can be marked as such
				#end_comment#
				variable_statement {
					#comment#instant#end_comment#
					#comment# if we uncommented the above, this would take place instantly #end_comment#
					west_light
					assign {
						case {(equal, direction, 'west_to_east')}
						result {True}
						result {False}
					}
				}
				variable_statement {
					east_light
					assign {
						case {(equal, direction, 'east_to_west')}
						result {True}
						result {False}
					}
				}
			}
			variable_statement {
				fairness_counter
				assign {
					result {(min, 'max_counter', (addition, fairness_counter, 1))}
				}
			}
			return_statement {
				result { success}
			}
		}
	}
} end_actions

#comment# We are now done specifying nodes. We will now specify the tree. #end_comment#

sub_trees {
	#comment# subtrees are smaller trees which can be inserted. This helps with readability and reusability#end_comment#
	sub_tree {
		WEST_AND_EAST #comment# the name of the subtree#end_comment#
		composite {
			try_west_and_east#comment# the name of the composite node #end_comment#
			sequence #comment# the type of the composite node #end_comment#
			children {
				check_west_and_east_cars #comment# the first child is a check node we defined earlier #end_comment#
				#comment# the second child is a composite node #end_comment#
				composite {
					choose_fairly
					selector
					children {
						check_fairness #comment# a check node we defined earlier #end_comment#
						swap_direction #comment# an action node we defined earlier #end_comment#
					}
				}
			}
		}
	}
	sub_tree {
		WEST_ONLY
		composite {
			try_west
			sequence
			children {
				check_west_cars
				set_west
			}
		}
	}
	sub_tree {
		EAST_ONLY
		composite {
			try_east
			sequence
			children {
				check_east_cars
				set_east
			}
		}
	}
	sub_tree {
		DIRECTION_SUBTREE
		composite {
			select_direction
			selector
			children {
				insert {WEST_AND_EAST}
				insert {WEST_ONLY}
				insert {EAST_ONLY}
			}
		}
	}
	sub_tree {
		LIGHT_SUBTREE
		composite {
			activate_light
			sequence
			children {
				check_safety
				#comment#
				composite {
					safety_check
					selector
					children {
						check_tunnel_empty
						check_west_east_safe
						check_east_west_safe
					}
				}
				#end_comment#
				send_light_signal
			}
		}
	}
} end_sub_trees

tree {
	#comment# this is our actual tree, and the actual root #end_comment#
	composite {
		light_controller
		sequence
		children {
			insert {DIRECTION_SUBTREE} #comment# here we are inserting a subtree of the name DIRECTION_SUBTREE #end_comment#
			insert {LIGHT_SUBTREE}
		}
	}
} end_tree

#comment# the tick_prerequisite is optional.
If provided, it MUST have a condition. If the condition is true, the tree ticks. if it is false, the simulation halts.
#end_comment#
#comment#
tick_prerequisite {} end_tick_prerequisite
#end_comment#

specifications {
	#comment# Specifications are used to write specifications for our model #end_comment#
	
	INVARSPEC {(not, (and, west_light -1, east_light -1))}
	#comment# ^ only one light at a time #end_comment#
	INVARSPEC {(not, (and, west_light -1, (equal, tunnel_state -1, 'east_to_west')))}
	#comment# ^ can't have west light while going east to west #end_comment# 
	INVARSPEC {(not, (and, east_light -1, (equal, tunnel_state -1, 'west_to_east')))}
	#comment# ^ can't have east light while going west to east #end_comment#

	#comment# The below attempt to ensure that each car eventually gets to use the tunnel.
	They do this by stating that it is always the case that if there is a car waiting,
	then the light will eventually let that car through.#end_comment#
	#comment# These will fail, because cars are not guaranteed to ever leave the tunnel.#end_comment#
	CTLSPEC {(always_globally, (implies, west_cars -1, (always_finally, west_light -1)))}
	CTLSPEC {(always_globally, (implies, east_cars -1, (always_finally, east_light -1)))}
	LTLSPEC {(globally, (implies, west_cars -1, (finally, west_light -1)))}
	LTLSPEC {(globally, (implies, east_cars -1, (finally, east_light -1)))}
	
	#comment# So we add a condition to force cars to leave. #end_comment#
	CTLSPEC {(implies,
			(always_globally, (always_finally, (equal, tunnel_state -1, 'empty'))),
			(always_globally, (implies, west_cars -1, (always_finally, west_light -1)))
		)}
	CTLSPEC {(implies,
			(always_globally, (always_finally, (equal, tunnel_state -1, 'empty'))),
			(always_globally, (implies, east_cars -1, (always_finally, east_light -1)))
		)}
	LTLSPEC {(implies,
			(globally, (finally, (equal, tunnel_state -1, 'empty'))),
			(globally, (implies, west_cars -1, (finally, west_light -1)))
		)}
	LTLSPEC {(implies,
			(globally, (finally, (equal, tunnel_state -1, 'empty'))),
			(globally, (implies, east_cars -1, (finally, east_light -1)))
		)}
} end_specifications