MODULE main
	DEFINE
		max_active_node := 69;
		statuses := [BlueROV.status, topics2bb.status, dd_tasks_serene.status, mission_server.status, obstacle_avoidance.status, priorities.status, battery2bb.status, rth2bb.status, geofence2bb.status, lec2_am_r_2bb.status, lec2_am_l_2bb.status, pipe_lost2bb.status, sensor_failure2bb.status, waypoints_completed2bb.status, mission2bb.status, ddlec2bb.status, fls2bb.status, fls_warning2bb.status, hsd_pipe2bb.status, hsd_wp2bb.status, hsd_rth2bb.status, hsd_surface2bb.status, rtreach2bb.status, battery_check_SIF.status, sensor_failure_selector_SIF.status, emergency_stop_check_SIF.status, home_reached_selector_SIF.status, obstacle_standoff_check_SIF.status, rth_selector_SIF.status, geofence_selector_SIF.status, pipe_lost_selector_SIF.status, track_pipe_mission.status, waypoint_mission.status, loiter_task.status, battery_check.status, battery_low_fs.status, surface_task.status, sensor_failure_selector.status, check_sensor_failure.status, surface_task1.status, emergency_stop_check.status, emergency_stop_fs.status, emergency_stop_tasks.status, emergency_stop_task.status, surface_task2.status, home_reached_selector.status, check_surface.status, surface_task3.status, obstacle_standoff_check.status, obstacle_standoff_fs.status, surface_task4.status, rth_selector.status, check_rth.status, rth_par.status, rth_task.status, home2bb.status, geofence_selector.status, check_geofence.status, rth_par1.status, rth_task1.status, home2bb1.status, pipe_lost_selector.status, check_pipe_post.status, loiter_task1.status, is_track_pipe_mission_requested.status, tracking_serene.status, track_pipe_mission_end.status, evaluate.status, is_waypoint_requested.status, waypoint_selector_serene.status];
		parents := [-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 23, 34, 34, 24, 37, 37, 25, 40, 40, 42, 42, 26, 45, 45, 27, 48, 48, 28, 51, 51, 53, 53, 29, 56, 56, 58, 58, 30, 61, 61, 31, 31, 31, 66, 32, 32];
		leafs := {-3, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 33, 35, 36, 38, 39, 41, 43, 44, 46, 47, 49, 50, 52, 54, 55, 57, 59, 60, 62, 63, 64, 65, 67, 68, 69};
		selectors := {-3, 5, 34, 37, 40, 45, 48, 51, 56, 61};
		sequences := {-3, 31, 32, 42, 66};
		parallels_synchronised_all := {-3, 0, 1, 53, 58};
		parallels_unsynchronised_all := {-3};
		parallels_synchronised_one := {-3};
		parallels_unsynchronised_one := {-3};
		parallels := {-3, 0, 1, 53, 58};
		decorators := {-3, 23, 24, 25, 26, 27, 28, 29, 30};
		first_child := [1, 6, -2, -2, -2, 23, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 34, 37, 40, 45, 48, 51, 56, 61, 64, 68, -2, 35, -2, -2, 38, -2, -2, 41, -2, 43, -2, -2, 46, -2, -2, 49, -2, -2, 52, -2, 54, -2, -2, 57, -2, 59, -2, -2, 62, -2, -2, -2, -2, 67, -2, -2, -2];
		last_child := [5, 22, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 34, 37, 40, 45, 48, 51, 56, 61, 66, 69, -1, 36, -1, -1, 39, -1, -1, 42, -1, 44, -1, -1, 47, -1, -1, 50, -1, -1, 53, -1, 55, -1, -1, 58, -1, 60, -1, -1, 63, -1, -1, -1, -1, 67, -1, -1, -1];
		parallel_resume := [parallel_resume_0, parallel_resume_1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, parallel_resume_53, -2, -2, -2, -2, parallel_resume_58, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2];
		parallel_resume_0 := 
			case
				(previous_node < 1) & !(parallel_resume_0_1 = -2) : parallel_resume_0_1;
				(previous_node < 2) & !(parallel_resume_0_2 = -2) : parallel_resume_0_2;
				(previous_node < 3) & !(parallel_resume_0_3 = -2) : parallel_resume_0_3;
				(previous_node < 4) & !(parallel_resume_0_4 = -2) : parallel_resume_0_4;
				(previous_node < 5) & !(parallel_resume_0_5 = -2) : parallel_resume_0_5;
				TRUE : parents[0];
			esac;
		parallel_resume_1 := 
			case
				(previous_node < 6) & !(parallel_resume_1_6 = -2) : parallel_resume_1_6;
				(previous_node < 7) & !(parallel_resume_1_7 = -2) : parallel_resume_1_7;
				(previous_node < 8) & !(parallel_resume_1_8 = -2) : parallel_resume_1_8;
				(previous_node < 9) & !(parallel_resume_1_9 = -2) : parallel_resume_1_9;
				(previous_node < 10) & !(parallel_resume_1_10 = -2) : parallel_resume_1_10;
				(previous_node < 11) & !(parallel_resume_1_11 = -2) : parallel_resume_1_11;
				(previous_node < 12) & !(parallel_resume_1_12 = -2) : parallel_resume_1_12;
				(previous_node < 13) & !(parallel_resume_1_13 = -2) : parallel_resume_1_13;
				(previous_node < 14) & !(parallel_resume_1_14 = -2) : parallel_resume_1_14;
				(previous_node < 15) & !(parallel_resume_1_15 = -2) : parallel_resume_1_15;
				(previous_node < 16) & !(parallel_resume_1_16 = -2) : parallel_resume_1_16;
				(previous_node < 17) & !(parallel_resume_1_17 = -2) : parallel_resume_1_17;
				(previous_node < 18) & !(parallel_resume_1_18 = -2) : parallel_resume_1_18;
				(previous_node < 19) & !(parallel_resume_1_19 = -2) : parallel_resume_1_19;
				(previous_node < 20) & !(parallel_resume_1_20 = -2) : parallel_resume_1_20;
				(previous_node < 21) & !(parallel_resume_1_21 = -2) : parallel_resume_1_21;
				(previous_node < 22) & !(parallel_resume_1_22 = -2) : parallel_resume_1_22;
				TRUE : parents[1];
			esac;
		parallel_resume_53 := 
			case
				(previous_node < 54) & !(parallel_resume_53_54 = -2) : parallel_resume_53_54;
				(previous_node < 55) & !(parallel_resume_53_55 = -2) : parallel_resume_53_55;
				TRUE : parents[53];
			esac;
		parallel_resume_58 := 
			case
				(previous_node < 59) & !(parallel_resume_58_59 = -2) : parallel_resume_58_59;
				(previous_node < 60) & !(parallel_resume_58_60 = -2) : parallel_resume_58_60;
				TRUE : parents[58];
			esac;
	VAR
		active_node : -2..max_active_node;
		previous_node : -1..max_active_node;
		resume_node : -1..max_active_node;
		previous_status : {running, success, failure, invalid};
		parallel_resume_0_1 : {-2, 1};
		parallel_resume_0_2 : {-2, 2};
		parallel_resume_0_3 : {-2, 3};
		parallel_resume_0_4 : {-2, 4};
		parallel_resume_0_5 : {-2, 5, 23, 34, 35, 36, 24, 37, 38, 39, 25, 40, 41, 42, 43, 44, 26, 45, 46, 47, 27, 48, 49, 50, 28, 51, 52, 53, 29, 56, 57, 58, 30, 61, 62, 63, 31, 64, 65, 66, 67, 32, 68, 69, 33};
		parallel_resume_1_6 : {-2, 6};
		parallel_resume_1_7 : {-2, 7};
		parallel_resume_1_8 : {-2, 8};
		parallel_resume_1_9 : {-2, 9};
		parallel_resume_1_10 : {-2, 10};
		parallel_resume_1_11 : {-2, 11};
		parallel_resume_1_12 : {-2, 12};
		parallel_resume_1_13 : {-2, 13};
		parallel_resume_1_14 : {-2, 14};
		parallel_resume_1_15 : {-2, 15};
		parallel_resume_1_16 : {-2, 16};
		parallel_resume_1_17 : {-2, 17};
		parallel_resume_1_18 : {-2, 18};
		parallel_resume_1_19 : {-2, 19};
		parallel_resume_1_20 : {-2, 20};
		parallel_resume_1_21 : {-2, 21};
		parallel_resume_1_22 : {-2, 22};
		parallel_resume_53_54 : {-2, 54};
		parallel_resume_53_55 : {-2, 55};
		parallel_resume_58_59 : {-2, 59};
		parallel_resume_58_60 : {-2, 60};
		BlueROV : node_parallel(active_node, 0, previous_status, 5, previous_node, TRUE, TRUE, parallel_resume_0);
		topics2bb : node_parallel(active_node, 1, previous_status, 22, previous_node, TRUE, TRUE, parallel_resume_1);
		dd_tasks_serene : node_running(active_node, 2);
		mission_server : node_set_blackboard_variables(active_node, 3, mission_server_SET_status);
		mission_server_SET_status : mission_server_SET_status_module(active_node, 3, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		obstacle_avoidance : node_set_blackboard_variables(active_node, 4, obstacle_avoidance_SET_status);
		obstacle_avoidance_SET_status : obstacle_avoidance_SET_status_module(active_node, 4, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		priorities : node_selector(active_node, 5, previous_status, 33, previous_node);
		battery2bb : node_set_blackboard_variables(active_node, 6, battery2bb_SET_status);
		battery2bb_SET_status : battery2bb_SET_status_module(active_node, 6, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth2bb : node_set_blackboard_variables(active_node, 7, rth2bb_SET_status);
		rth2bb_SET_status : rth2bb_SET_status_module(active_node, 7, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		geofence2bb : node_set_blackboard_variables(active_node, 8, geofence2bb_SET_status);
		geofence2bb_SET_status : geofence2bb_SET_status_module(active_node, 8, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2_am_r_2bb : node_set_blackboard_variables(active_node, 9, lec2_am_r_2bb_SET_status);
		lec2_am_r_2bb_SET_status : lec2_am_r_2bb_SET_status_module(active_node, 9, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		lec2_am_l_2bb : node_set_blackboard_variables(active_node, 10, lec2_am_l_2bb_SET_status);
		lec2_am_l_2bb_SET_status : lec2_am_l_2bb_SET_status_module(active_node, 10, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_lost2bb : node_set_blackboard_variables(active_node, 11, pipe_lost2bb_SET_status);
		pipe_lost2bb_SET_status : pipe_lost2bb_SET_status_module(active_node, 11, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		sensor_failure2bb : node_set_blackboard_variables(active_node, 12, sensor_failure2bb_SET_status);
		sensor_failure2bb_SET_status : sensor_failure2bb_SET_status_module(active_node, 12, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoints_completed2bb : node_set_blackboard_variables(active_node, 13, waypoints_completed2bb_SET_status);
		waypoints_completed2bb_SET_status : waypoints_completed2bb_SET_status_module(active_node, 13, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		mission2bb : node_set_blackboard_variables(active_node, 14, mission2bb_SET_status);
		mission2bb_SET_status : mission2bb_SET_status_module(active_node, 14, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		ddlec2bb : node_set_blackboard_variables(active_node, 15, ddlec2bb_SET_status);
		ddlec2bb_SET_status : ddlec2bb_SET_status_module(active_node, 15, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		fls2bb : node_set_blackboard_variables(active_node, 16, fls2bb_SET_status);
		fls2bb_SET_status : fls2bb_SET_status_module(active_node, 16, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		fls_warning2bb : node_set_blackboard_variables(active_node, 17, fls_warning2bb_SET_status);
		fls_warning2bb_SET_status : fls_warning2bb_SET_status_module(active_node, 17, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_pipe2bb : node_set_blackboard_variables(active_node, 18, hsd_pipe2bb_SET_status);
		hsd_pipe2bb_SET_status : hsd_pipe2bb_SET_status_module(active_node, 18, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_wp2bb : node_set_blackboard_variables(active_node, 19, hsd_wp2bb_SET_status);
		hsd_wp2bb_SET_status : hsd_wp2bb_SET_status_module(active_node, 19, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_rth2bb : node_set_blackboard_variables(active_node, 20, hsd_rth2bb_SET_status);
		hsd_rth2bb_SET_status : hsd_rth2bb_SET_status_module(active_node, 20, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		hsd_surface2bb : node_set_blackboard_variables(active_node, 21, hsd_surface2bb_SET_status);
		hsd_surface2bb_SET_status : hsd_surface2bb_SET_status_module(active_node, 21, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rtreach2bb : node_set_blackboard_variables(active_node, 22, rtreach2bb_SET_status);
		rtreach2bb_SET_status : rtreach2bb_SET_status_module(active_node, 22, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		battery_check_SIF : decorator_success_is_failure(active_node, 23, previous_status);
		sensor_failure_selector_SIF : decorator_success_is_failure(active_node, 24, previous_status);
		emergency_stop_check_SIF : decorator_success_is_failure(active_node, 25, previous_status);
		home_reached_selector_SIF : decorator_success_is_failure(active_node, 26, previous_status);
		obstacle_standoff_check_SIF : decorator_success_is_failure(active_node, 27, previous_status);
		rth_selector_SIF : decorator_success_is_failure(active_node, 28, previous_status);
		geofence_selector_SIF : decorator_success_is_failure(active_node, 29, previous_status);
		pipe_lost_selector_SIF : decorator_success_is_failure(active_node, 30, previous_status);
		track_pipe_mission : node_sequence(active_node, 31, previous_status, 66, previous_node);
		waypoint_mission : node_sequence(active_node, 32, previous_status, 69, previous_node);
		loiter_task : node_set_blackboard_variables(active_node, 33, loiter_task_SET_status);
		loiter_task_SET_status : loiter_task_SET_status_module(active_node, 33, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		battery_check : node_selector(active_node, 34, previous_status, 36, previous_node);
		battery_low_fs : node_check_blackboard_variable_value(active_node, 35, blackboard, 1, battery_low_fs_CHECK_battery_low_warning);
		battery_low_fs_CHECK_battery_low_warning : battery_low_fs_CHECK_battery_low_warning_module(active_node, 35, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task : node_set_blackboard_variables(active_node, 36, surface_task_SET_status);
		surface_task_SET_status : surface_task_SET_status_module(active_node, 36, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		sensor_failure_selector : node_selector(active_node, 37, previous_status, 39, previous_node);
		check_sensor_failure : node_check_blackboard_variable_value(active_node, 38, blackboard, 20, check_sensor_failure_CHECK_bb_sensor_failure_warning);
		check_sensor_failure_CHECK_bb_sensor_failure_warning : check_sensor_failure_CHECK_bb_sensor_failure_warning_module(active_node, 38, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task1 : node_set_blackboard_variables(active_node, 39, surface_task1_SET_status);
		surface_task1_SET_status : surface_task1_SET_status_module(active_node, 39, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		emergency_stop_check : node_selector(active_node, 40, previous_status, 42, previous_node);
		emergency_stop_fs : node_check_blackboard_variable_value(active_node, 41, blackboard, 33, emergency_stop_fs_CHECK_emergency_stop_warning);
		emergency_stop_fs_CHECK_emergency_stop_warning : emergency_stop_fs_CHECK_emergency_stop_warning_module(active_node, 41, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		emergency_stop_tasks : node_sequence(active_node, 42, previous_status, 44, previous_node);
		emergency_stop_task : node_set_blackboard_variables(active_node, 43, emergency_stop_task_SET_status);
		emergency_stop_task_SET_status : emergency_stop_task_SET_status_module(active_node, 43, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task2 : node_set_blackboard_variables(active_node, 44, surface_task2_SET_status);
		surface_task2_SET_status : surface_task2_SET_status_module(active_node, 44, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home_reached_selector : node_selector(active_node, 45, previous_status, 47, previous_node);
		check_surface : node_check_blackboard_variable_value(active_node, 46, blackboard, 51, check_surface_CHECK_bb_home_reached);
		check_surface_CHECK_bb_home_reached : check_surface_CHECK_bb_home_reached_module(active_node, 46, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task3 : node_set_blackboard_variables(active_node, 47, surface_task3_SET_status);
		surface_task3_SET_status : surface_task3_SET_status_module(active_node, 47, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		obstacle_standoff_check : node_selector(active_node, 48, previous_status, 50, previous_node);
		obstacle_standoff_fs : node_check_blackboard_variable_value(active_node, 49, blackboard, 29, obstacle_standoff_fs_CHECK_obstacle_standoff_warning);
		obstacle_standoff_fs_CHECK_obstacle_standoff_warning : obstacle_standoff_fs_CHECK_obstacle_standoff_warning_module(active_node, 49, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		surface_task4 : node_set_blackboard_variables(active_node, 50, surface_task4_SET_status);
		surface_task4_SET_status : surface_task4_SET_status_module(active_node, 50, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_selector : node_selector(active_node, 51, previous_status, 53, previous_node);
		check_rth : node_check_blackboard_variable_value(active_node, 52, blackboard, 4, check_rth_CHECK_bb_rth_warning);
		check_rth_CHECK_bb_rth_warning : check_rth_CHECK_bb_rth_warning_module(active_node, 52, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_par : node_parallel(active_node, 53, previous_status, 55, previous_node, TRUE, TRUE, parallel_resume_53);
		rth_task : node_set_blackboard_variables(active_node, 54, rth_task_SET_status);
		rth_task_SET_status : rth_task_SET_status_module(active_node, 54, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home2bb : node_set_blackboard_variables(active_node, 55, home2bb_SET_status);
		home2bb_SET_status : home2bb_SET_status_module(active_node, 55, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		geofence_selector : node_selector(active_node, 56, previous_status, 58, previous_node);
		check_geofence : node_check_blackboard_variable_value(active_node, 57, blackboard, 7, check_geofence_CHECK_bb_geofence_warning);
		check_geofence_CHECK_bb_geofence_warning : check_geofence_CHECK_bb_geofence_warning_module(active_node, 57, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		rth_par1 : node_parallel(active_node, 58, previous_status, 60, previous_node, TRUE, TRUE, parallel_resume_58);
		rth_task1 : node_set_blackboard_variables(active_node, 59, rth_task1_SET_status);
		rth_task1_SET_status : rth_task1_SET_status_module(active_node, 59, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		home2bb1 : node_set_blackboard_variables(active_node, 60, home2bb1_SET_status);
		home2bb1_SET_status : home2bb1_SET_status_module(active_node, 60, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		pipe_lost_selector : node_selector(active_node, 61, previous_status, 63, previous_node);
		check_pipe_post : node_check_blackboard_variable_value(active_node, 62, blackboard, 16, check_pipe_post_CHECK_bb_pipe_lost_warning);
		check_pipe_post_CHECK_bb_pipe_lost_warning : check_pipe_post_CHECK_bb_pipe_lost_warning_module(active_node, 62, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		loiter_task1 : node_set_blackboard_variables(active_node, 63, loiter_task1_SET_status);
		loiter_task1_SET_status : loiter_task1_SET_status_module(active_node, 63, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		is_track_pipe_mission_requested : node_check_blackboard_variable_value(active_node, 64, blackboard, 18, is_track_pipe_mission_requested_CHECK_bb_mission_dot_data);
		is_track_pipe_mission_requested_CHECK_bb_mission_dot_data : is_track_pipe_mission_requested_CHECK_bb_mission_dot_data_module(active_node, 64, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		tracking_serene : node_running(active_node, 65);
		track_pipe_mission_end : node_sequence(active_node, 66, previous_status, 67, previous_node);
		evaluate : node_timer(active_node, 67);
		is_waypoint_requested : node_check_blackboard_variable_value(active_node, 68, blackboard, 18, is_waypoint_requested_CHECK_bb_mission_dot_data);
		is_waypoint_requested_CHECK_bb_mission_dot_data : is_waypoint_requested_CHECK_bb_mission_dot_data_module(active_node, 68, blackboard.variables, blackboard.variable_exists, node_names, variable_names);
		waypoint_selector_serene : node_running(active_node, 69);
		variable_names : define_variables;
		node_names : define_nodes;
		blackboard : blackboard_module(active_node, node_names, variable_names, previous_status);
	ASSIGN
		init(active_node) := -1;
		init(previous_node) := -1;
		init(resume_node) := -1;
		init(previous_status) := invalid;
		init(parallel_resume_0_1) := 1;
		init(parallel_resume_0_2) := 2;
		init(parallel_resume_0_3) := 3;
		init(parallel_resume_0_4) := 4;
		init(parallel_resume_0_5) := 5;
		init(parallel_resume_1_6) := 6;
		init(parallel_resume_1_7) := 7;
		init(parallel_resume_1_8) := 8;
		init(parallel_resume_1_9) := 9;
		init(parallel_resume_1_10) := 10;
		init(parallel_resume_1_11) := 11;
		init(parallel_resume_1_12) := 12;
		init(parallel_resume_1_13) := 13;
		init(parallel_resume_1_14) := 14;
		init(parallel_resume_1_15) := 15;
		init(parallel_resume_1_16) := 16;
		init(parallel_resume_1_17) := 17;
		init(parallel_resume_1_18) := 18;
		init(parallel_resume_1_19) := 19;
		init(parallel_resume_1_20) := 20;
		init(parallel_resume_1_21) := 21;
		init(parallel_resume_1_22) := 22;
		init(parallel_resume_53_54) := 54;
		init(parallel_resume_53_55) := 55;
		init(parallel_resume_58_59) := 59;
		init(parallel_resume_58_60) := 60;
		next(previous_node) :=
			case
				(active_node < 0) : -1;
				TRUE : active_node;
			esac;
		next(resume_node) :=
			case
				(previous_node < 0) : resume_node;
				!(previous_status = running) : -1;
				(resume_node = -1) : previous_node;
				(previous_node in parallels) | (previous_node in selectors) : previous_node;
				TRUE : resume_node;
			esac;
		next(previous_status) :=
			case
				(active_node < 0) : invalid;
				TRUE : statuses[active_node];
			esac;
		next(active_node) :=
			case
				(active_node = -2) : -2;
				(active_node = -1) & (resume_node = -1) : 0;
				(active_node = -1) & !(resume_node = -1) : resume_node;
				(active_node in leafs) : parents[active_node];
				(previous_status = invalid) : first_child[active_node];
				(previous_node = last_child[active_node]) : parents[active_node];
				(active_node in parallels) : parallel_resume[active_node];
				(active_node in sequences) & (previous_status = success) : min(max_active_node, previous_node + 1);
				(active_node in selectors) & (previous_status = failure) : min(max_active_node, previous_node + 1);
				TRUE : parents[active_node];
			esac;
		next(parallel_resume_0_1) :=
			case
				(parallel_resume_0_1 = 1) & (previous_node in {-2, 1}) & (previous_status = running) : previous_node;
				(previous_node = 1) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 1;
				TRUE : parallel_resume_0_1;
			esac;

		next(parallel_resume_0_2) :=
			case
				(parallel_resume_0_2 = 2) & (previous_node in {-2, 2}) & (previous_status = running) : previous_node;
				(previous_node = 2) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 2;
				TRUE : parallel_resume_0_2;
			esac;

		next(parallel_resume_0_3) :=
			case
				(parallel_resume_0_3 = 3) & (previous_node in {-2, 3}) & (previous_status = running) : previous_node;
				(previous_node = 3) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 3;
				TRUE : parallel_resume_0_3;
			esac;

		next(parallel_resume_0_4) :=
			case
				(parallel_resume_0_4 = 4) & (previous_node in {-2, 4}) & (previous_status = running) : previous_node;
				(previous_node = 4) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 4;
				TRUE : parallel_resume_0_4;
			esac;

		next(parallel_resume_0_5) :=
			case
				(parallel_resume_0_5 = 5) & (previous_node in {-2, 5, 23, 34, 35, 36, 24, 37, 38, 39, 25, 40, 41, 42, 43, 44, 26, 45, 46, 47, 27, 48, 49, 50, 28, 51, 52, 53, 29, 56, 57, 58, 30, 61, 62, 63, 31, 64, 65, 66, 67, 32, 68, 69, 33}) & (previous_status = running) : previous_node;
				(previous_node = 5) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 5;
				TRUE : parallel_resume_0_5;
			esac;

		next(parallel_resume_1_6) :=
			case
				(parallel_resume_1_6 = 6) & (previous_node in {-2, 6}) & (previous_status = running) : previous_node;
				(previous_node = 6) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 6;
				TRUE : parallel_resume_1_6;
			esac;

		next(parallel_resume_1_7) :=
			case
				(parallel_resume_1_7 = 7) & (previous_node in {-2, 7}) & (previous_status = running) : previous_node;
				(previous_node = 7) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 7;
				TRUE : parallel_resume_1_7;
			esac;

		next(parallel_resume_1_8) :=
			case
				(parallel_resume_1_8 = 8) & (previous_node in {-2, 8}) & (previous_status = running) : previous_node;
				(previous_node = 8) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 8;
				TRUE : parallel_resume_1_8;
			esac;

		next(parallel_resume_1_9) :=
			case
				(parallel_resume_1_9 = 9) & (previous_node in {-2, 9}) & (previous_status = running) : previous_node;
				(previous_node = 9) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 9;
				TRUE : parallel_resume_1_9;
			esac;

		next(parallel_resume_1_10) :=
			case
				(parallel_resume_1_10 = 10) & (previous_node in {-2, 10}) & (previous_status = running) : previous_node;
				(previous_node = 10) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 10;
				TRUE : parallel_resume_1_10;
			esac;

		next(parallel_resume_1_11) :=
			case
				(parallel_resume_1_11 = 11) & (previous_node in {-2, 11}) & (previous_status = running) : previous_node;
				(previous_node = 11) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 11;
				TRUE : parallel_resume_1_11;
			esac;

		next(parallel_resume_1_12) :=
			case
				(parallel_resume_1_12 = 12) & (previous_node in {-2, 12}) & (previous_status = running) : previous_node;
				(previous_node = 12) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 12;
				TRUE : parallel_resume_1_12;
			esac;

		next(parallel_resume_1_13) :=
			case
				(parallel_resume_1_13 = 13) & (previous_node in {-2, 13}) & (previous_status = running) : previous_node;
				(previous_node = 13) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 13;
				TRUE : parallel_resume_1_13;
			esac;

		next(parallel_resume_1_14) :=
			case
				(parallel_resume_1_14 = 14) & (previous_node in {-2, 14}) & (previous_status = running) : previous_node;
				(previous_node = 14) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 14;
				TRUE : parallel_resume_1_14;
			esac;

		next(parallel_resume_1_15) :=
			case
				(parallel_resume_1_15 = 15) & (previous_node in {-2, 15}) & (previous_status = running) : previous_node;
				(previous_node = 15) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 15;
				TRUE : parallel_resume_1_15;
			esac;

		next(parallel_resume_1_16) :=
			case
				(parallel_resume_1_16 = 16) & (previous_node in {-2, 16}) & (previous_status = running) : previous_node;
				(previous_node = 16) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 16;
				TRUE : parallel_resume_1_16;
			esac;

		next(parallel_resume_1_17) :=
			case
				(parallel_resume_1_17 = 17) & (previous_node in {-2, 17}) & (previous_status = running) : previous_node;
				(previous_node = 17) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 17;
				TRUE : parallel_resume_1_17;
			esac;

		next(parallel_resume_1_18) :=
			case
				(parallel_resume_1_18 = 18) & (previous_node in {-2, 18}) & (previous_status = running) : previous_node;
				(previous_node = 18) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 18;
				TRUE : parallel_resume_1_18;
			esac;

		next(parallel_resume_1_19) :=
			case
				(parallel_resume_1_19 = 19) & (previous_node in {-2, 19}) & (previous_status = running) : previous_node;
				(previous_node = 19) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 19;
				TRUE : parallel_resume_1_19;
			esac;

		next(parallel_resume_1_20) :=
			case
				(parallel_resume_1_20 = 20) & (previous_node in {-2, 20}) & (previous_status = running) : previous_node;
				(previous_node = 20) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 20;
				TRUE : parallel_resume_1_20;
			esac;

		next(parallel_resume_1_21) :=
			case
				(parallel_resume_1_21 = 21) & (previous_node in {-2, 21}) & (previous_status = running) : previous_node;
				(previous_node = 21) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 21;
				TRUE : parallel_resume_1_21;
			esac;

		next(parallel_resume_1_22) :=
			case
				(parallel_resume_1_22 = 22) & (previous_node in {-2, 22}) & (previous_status = running) : previous_node;
				(previous_node = 22) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 22;
				TRUE : parallel_resume_1_22;
			esac;

		next(parallel_resume_53_54) :=
			case
				(parallel_resume_53_54 = 54) & (previous_node in {-2, 54}) & (previous_status = running) : previous_node;
				(previous_node = 54) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 54;
				TRUE : parallel_resume_53_54;
			esac;

		next(parallel_resume_53_55) :=
			case
				(parallel_resume_53_55 = 55) & (previous_node in {-2, 55}) & (previous_status = running) : previous_node;
				(previous_node = 55) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 55;
				TRUE : parallel_resume_53_55;
			esac;

		next(parallel_resume_58_59) :=
			case
				(parallel_resume_58_59 = 59) & (previous_node in {-2, 59}) & (previous_status = running) : previous_node;
				(previous_node = 59) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 59;
				TRUE : parallel_resume_58_59;
			esac;

		next(parallel_resume_58_60) :=
			case
				(parallel_resume_58_60 = 60) & (previous_node in {-2, 60}) & (previous_status = running) : previous_node;
				(previous_node = 60) & (previous_status = success | previous_status = failure) : -2;
				(previous_node = 0) & (previous_status = success | previous_status = failure) : 60;
				TRUE : parallel_resume_58_60;
			esac;

-------------------------------------------------------------------------------------
--LTLSPEC G (!(active_node = -2));
--we never enter the error state.

--LTLSPEC (active_node = -1) U (active_node = 1);
--this should fail, obvious

--LTLSPEC (active_node = -1) U (active_node = 0);
--this should succeed, but only because the root node is parallel, therefore we can't ever skip over it by resuming a run.

-------------------------------------------------------------------------------------

--LTLSPEC G( (blackboard.variables[variable_names.battery_low_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--proves that if low warning, then surface (eventually)


--LTLSPEC G( (blackboard.variables[variable_names.battery_low_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

--LTLSPEC G( ((blackboard.variables[variable_names.battery_low_warning] = 1) & (previous_node = node_names.battery2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task)));
--this one is true, but only for battery_warning

LTLSPEC G( ((blackboard.variables[variable_names.battery_low_warning] = 1) & (previous_node = node_names.battery2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
--this one should be true.

-------------------------------------------------------------------------------------

-- LTLSPEC G( (blackboard.variables[variable_names.bb_sensor_failure_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
-- --proves that if low warning, then surface (eventually)


-- LTLSPEC G( (blackboard.variables[variable_names.bb_sensor_failure_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

-- LTLSPEC G( ((blackboard.variables[variable_names.bb_sensor_failure_warning] = 1) & (previous_node = node_names.sensor_failure2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task1)));
-- --this one is true, but only for battery_warning

-- LTLSPEC G( ((blackboard.variables[variable_names.bb_sensor_failure_warning] = 1) & (previous_node = node_names.sensor_failure2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --this one should be true.

-- -------------------------------------------------------------------------------------

-- LTLSPEC G( (blackboard.variables[variable_names.emergency_stop_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
-- --proves that if low warning, then surface (eventually)


-- LTLSPEC G( (blackboard.variables[variable_names.emergency_stop_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

-- LTLSPEC G( ((blackboard.variables[variable_names.emergency_stop_warning] = 1) & (previous_node in {node_names.fls_warning2bb, node_names.rtreach2bb, node_names.mission_server}))  -> (((active_node > -1))  U (active_node = node_names.surface_task2)));
-- --this one is true, but only for battery_warning

-- LTLSPEC G( ((blackboard.variables[variable_names.emergency_stop_warning] = 1) & (previous_node in {node_names.fls_warning2bb, node_names.rtreach2bb, node_names.mission_server}))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --this one should be true.

-- -------------------------------------------------------------------------------------

-- LTLSPEC G( (blackboard.variables[variable_names.bb_home_reached] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
-- --proves that if low warning, then surface (eventually)


-- LTLSPEC G( (blackboard.variables[variable_names.bb_home_reached] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

-- LTLSPEC G( ((blackboard.variables[variable_names.bb_home_reached] = 1) & (previous_node in {node_names.home2bb, node_names.home2bb1}))  -> (((active_node > -1))  U (active_node = node_names.surface_task3)));
-- --this one is true, but only for battery_warning

-- LTLSPEC G( ((blackboard.variables[variable_names.bb_home_reached] = 1) & (previous_node in {node_names.home2bb, node_names.home2bb1}))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --this one should be true.

-- -------------------------------------------------------------------------------------

-- LTLSPEC G( (blackboard.variables[variable_names.obstacle_standoff_warning] = 1)  -> F (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
-- --proves that if low warning, then surface (eventually)


-- LTLSPEC G( (blackboard.variables[variable_names.obstacle_standoff_warning] = 1)  -> ((!(active_node = -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --if low warning, than surface task before active_node reaches -1. (this should fail, because it doesn't consider that G means it needs to be true after we leave a surface task)

-- LTLSPEC G( ((blackboard.variables[variable_names.obstacle_standoff_warning] = 1) & (previous_node = node_names.fls2bb))  -> (((active_node > -1))  U (active_node = node_names.surface_task4)));
-- --this one is true, but only for battery_warning

-- LTLSPEC G( ((blackboard.variables[variable_names.obstacle_standoff_warning] = 1) & (previous_node = node_names.fls2bb))  -> (((active_node > -1))  U (active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4})));
-- --this one should be true.

-- -------------------------------------------------------------------------------------



CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--should be true. there's always a way to avoid surfacing. (until we introduce some specs that force battery to eventually decrease or something).

CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--this is the same as above, except inverted. it says we will always surface. should be false.

-------------------------------------------------------------------------------------
--this is a set of ctlspecs that i was using to debug an error in the model.
--ignore truth values attached.

--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--does surface task always have to trigger?

--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC EG(!(active_node in {node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));

--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));

--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task3}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task2, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task1, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));
--CTLSPEC AF((active_node in {node_names.surface_task1, node_names.surface_task2, node_names.surface_task3, node_names.surface_task4}));


--CTLSPEC EG((active_node in {node_names.surface_task4})); --FALSE --this was probably should have been EF
--LTLSPEC G(!(active_node = node_names.surface_task4)); --TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = 1); -- TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = 0); -- TRUE
--CTLSPEC EF(blackboard.variables[blackboard.variable_names.obstacle_standoff_warning] = -1); -- TRUE

--CTLSPEC EF(active_node = node_names.obstacle_standoff_fs); -- FALSE (5)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_fs)); --TRUE (5)
--so we literally never enter the obstacle_standoff_fs. time to check if we reach the node above it.
--CTLSPEC EF(active_node = node_names.obstacle_standoff_check); --FALSE (6)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_check)); --TRUE (6)

--CTLSPEC EF(active_node = node_names.obstacle_standoff_check_SIF); --FALSE (7)
--CTLSPEC AG(!(active_node = node_names.obstacle_standoff_check_SIF)); --TRUE (7)
--ok, that's the end of that tree, can't reach that whole area. gonna check if home_reached_selector, the branch before it, can be reached


--CTLSPEC EF(active_node = node_names.home_reached_selector_SIF); --TRUE (8)
--CTLSPEC AG(!(active_node = node_names.home_reached_selector_SIF)); --FALSE (8)
--yup, previous one is reachable.

-------------------------------------------------------------------------------------

MODULE node_parallel(active_node, id, previous_status, last_child, previous_node, synchronized, parallel_policy_all, resumer)
	DEFINE
		status :=
			case
				(id = active_node) & (resumer > id) : invalid;
				(id = active_node) & ((cur_status = failure) | (previous_status = failure)) : failure;
				(id = active_node) & (cur_status = running) & (previous_status = running) : running;
				(id = active_node) & !(parallel_policy_all) : success;
				(id = active_node) & (cur_status = success) & (previous_status = success) : success;
				(id = active_node) : running;
				TRUE : invalid;
			esac;
	VAR
		cur_status : {failure, running, success};
	ASSIGN
		init(cur_status) :=
			case
				(parallel_policy_all) : success;
				TRUE : running;
			esac;
		next(cur_status) :=
			case
				(id = active_node) & ((previous_status = failure) | (cur_status = failure)) : failure;
				(id = active_node) & (parallel_policy_all) & (previous_status = success) : cur_status;
				(id = active_node) & (parallel_policy_all) & (previous_status = running) : running;
				(id = active_node) & !(parallel_policy_all) & (previous_status = success) : success;
				(id = active_node) & !(parallel_policy_all) & (previous_status = running) : cur_status;
				(active_node = -1) & synchronized & (parallel_policy_all) & !(previous_status = running) : success;
				(active_node = -1) & synchronized & !(parallel_policy_all) & !(previous_status = running) : running;
				(active_node = -1) & !(synchronized) & (parallel_policy_all) : success;
				(active_node = -1) & !(synchronized) & !(parallel_policy_all) : running;
				TRUE : cur_status;
			esac;
MODULE node_set_blackboard_variables(active_node, id, status_module)
	DEFINE
		status := status_module.status;
MODULE node_running(active_node, id)
	DEFINE
		status :=
			case
				(id = active_node) : running;
				TRUE : invalid;
			esac;
MODULE node_selector(active_node, id, previous_status, last_child, previous_node)
	DEFINE
		status :=
			case
				(id = active_node) & (previous_status = invalid) : invalid;
				(id = active_node) & (previous_status = running) : running;
				(id = active_node) & (previous_status = success) : success;
				(id = active_node) & (last_child = previous_node) : failure;
				(id = active_node) : invalid;
				TRUE : invalid;
			esac;
MODULE decorator_success_is_failure(active_node, id, previous_status)
	DEFINE
		status :=
			case
				(id = active_node) & !(previous_status = success) : previous_status;
				(id = active_node) & (previous_status = success) : failure;
				TRUE : invalid;
			esac;
MODULE node_check_blackboard_variable_value(active_node, id, blackboard, variable, check)
	DEFINE
		status :=
			case
				(id = active_node) & !(blackboard.variable_exists[variable]) : failure;
				(id = active_node) & (blackboard.variable_exists[variable]) & (check.result) : success;
				(id = active_node) & (blackboard.variable_exists[variable]) & !(check.result) : failure;
				TRUE : invalid;
			esac;
MODULE node_sequence(active_node, id, previous_status, last_child, previous_node)
	DEFINE
		status :=
			case
				(id = active_node) & (previous_status = invalid) : invalid;
				(id = active_node) & (previous_status = running) : running;
				(id = active_node) & (previous_status = failure) : failure;
				(id = active_node) & (last_child = previous_node) : success;
				(id = active_node) : invalid;
				TRUE : invalid;
			esac;
MODULE node_timer(active_node, id)
	DEFINE
		status :=
			case
				(id = active_node) : {success, running};
				TRUE : invalid;
			esac;
MODULE define_variables
	DEFINE
		battery := 0;
		battery_low_warning := 1;
		battery_dot_batt_charge_remaining := 2;
		bb_rth := 3;
		bb_rth_warning := 4;
		bb_rth_dot_data := 5;
		bb_geofence := 6;
		bb_geofence_warning := 7;
		bb_geofence_dot_data := 8;
		lec2_am_r := 9;
		lec2_am_r_speed_warning := 10;
		lec2_am_r_pipe_warning := 11;
		lec2_am_l := 12;
		lec2_am_l_speed_warning := 13;
		lec2_am_l_pipe_warning := 14;
		bb_pipelost := 15;
		bb_pipe_lost_warning := 16;
		bb_pipelost_dot_data := 17;
		bb_mission_dot_data := 18;
		bb_sensor_failure := 19;
		bb_sensor_failure_warning := 20;
		bb_sensor_failure_dot_data := 21;
		bb_waypoints_completed := 22;
		bb_waypoints_completed_dot_data := 23;
		bb_mission := 24;
		dd_output := 25;
		dd_z_axis_warning := 26;
		dd_xy_axis_degradation := 27;
		fls_range := 28;
		obstacle_standoff_warning := 29;
		obstacle_min_standoff := 30;
		obstacle_in_view := 31;
		bb_fls_warning := 32;
		emergency_stop_warning := 33;
		hsd_pipeline_mapping := 34;
		hsd_to_waypoint := 35;
		hsd_to_rth := 36;
		hsd_to_surface := 37;
		rtreach_out := 38;
		uuv_max_speed := 39;
		mission_file := 40;
		refLat := 41;
		refLon := 42;
		next_mission := 43;
		decision_threshold := 44;
		HSD_out := 45;
		bb_obstacle_warning := 46;
		cm_hsd_input := 47;
		HSD_out_dot_heading := 48;
		HSD_out_dot_speed := 49;
		HSD_out_dot_depth := 50;
		bb_home_reached := 51;
		bb_home_dist := 52;
		bb_home_dist_dot_data := 53;
MODULE define_nodes
	DEFINE
		BlueROV := 0;
		topics2bb := 1;
		dd_tasks_serene := 2;
		mission_server := 3;
		obstacle_avoidance := 4;
		priorities := 5;
		battery2bb := 6;
		rth2bb := 7;
		geofence2bb := 8;
		lec2_am_r_2bb := 9;
		lec2_am_l_2bb := 10;
		pipe_lost2bb := 11;
		sensor_failure2bb := 12;
		waypoints_completed2bb := 13;
		mission2bb := 14;
		ddlec2bb := 15;
		fls2bb := 16;
		fls_warning2bb := 17;
		hsd_pipe2bb := 18;
		hsd_wp2bb := 19;
		hsd_rth2bb := 20;
		hsd_surface2bb := 21;
		rtreach2bb := 22;
		battery_check_SIF := 23;
		sensor_failure_selector_SIF := 24;
		emergency_stop_check_SIF := 25;
		home_reached_selector_SIF := 26;
		obstacle_standoff_check_SIF := 27;
		rth_selector_SIF := 28;
		geofence_selector_SIF := 29;
		pipe_lost_selector_SIF := 30;
		track_pipe_mission := 31;
		waypoint_mission := 32;
		loiter_task := 33;
		battery_check := 34;
		battery_low_fs := 35;
		surface_task := 36;
		sensor_failure_selector := 37;
		check_sensor_failure := 38;
		surface_task1 := 39;
		emergency_stop_check := 40;
		emergency_stop_fs := 41;
		emergency_stop_tasks := 42;
		emergency_stop_task := 43;
		surface_task2 := 44;
		home_reached_selector := 45;
		check_surface := 46;
		surface_task3 := 47;
		obstacle_standoff_check := 48;
		obstacle_standoff_fs := 49;
		surface_task4 := 50;
		rth_selector := 51;
		check_rth := 52;
		rth_par := 53;
		rth_task := 54;
		home2bb := 55;
		geofence_selector := 56;
		check_geofence := 57;
		rth_par1 := 58;
		rth_task1 := 59;
		home2bb1 := 60;
		pipe_lost_selector := 61;
		check_pipe_post := 62;
		loiter_task1 := 63;
		is_track_pipe_mission_requested := 64;
		tracking_serene := 65;
		track_pipe_mission_end := 66;
		evaluate := 67;
		is_waypoint_requested := 68;
		waypoint_selector_serene := 69;
--battery : 0
----battery2bb
--battery_low_warning : 1
----battery2bb
--battery_dot_batt_charge_remaining : 2
----battery2bb
--bb_rth : 3
----rth2bb
--bb_rth_warning : 4
----rth2bb
----mission_server
--bb_rth_dot_data : 5
----rth2bb
--bb_geofence : 6
----geofence2bb
--bb_geofence_warning : 7
----geofence2bb
--bb_geofence_dot_data : 8
----geofence2bb
--lec2_am_r : 9
----lec2_am_r_2bb
--lec2_am_r_speed_warning : 10
----lec2_am_r_2bb
--lec2_am_r_pipe_warning : 11
----lec2_am_r_2bb
--lec2_am_l : 12
----lec2_am_l_2bb
--lec2_am_l_speed_warning : 13
----lec2_am_l_2bb
--lec2_am_l_pipe_warning : 14
----lec2_am_l_2bb
--bb_pipelost : 15
----pipe_lost2bb
--bb_pipe_lost_warning : 16
----pipe_lost2bb
--bb_pipelost_dot_data : 17
----pipe_lost2bb
--bb_mission_dot_data : 18
----pipe_lost2bb
----mission2bb
----mission_server
--bb_sensor_failure : 19
----sensor_failure2bb
--bb_sensor_failure_warning : 20
----sensor_failure2bb
--bb_sensor_failure_dot_data : 21
----sensor_failure2bb
--bb_waypoints_completed : 22
----waypoints_completed2bb
--bb_waypoints_completed_dot_data : 23
----waypoints_completed2bb
--bb_mission : 24
----mission2bb
--dd_output : 25
----ddlec2bb
--dd_z_axis_warning : 26
----ddlec2bb
--dd_xy_axis_degradation : 27
----ddlec2bb
--fls_range : 28
----fls2bb
--obstacle_standoff_warning : 29
----fls2bb
--obstacle_min_standoff : 30
----fls2bb
----mission_server
--obstacle_in_view : 31
----fls_warning2bb
--bb_fls_warning : 32
----fls_warning2bb
--emergency_stop_warning : 33
----fls_warning2bb
----rtreach2bb
----mission_server
--hsd_pipeline_mapping : 34
----hsd_pipe2bb
--hsd_to_waypoint : 35
----hsd_wp2bb
--hsd_to_rth : 36
----hsd_rth2bb
--hsd_to_surface : 37
----hsd_surface2bb
--rtreach_out : 38
----rtreach2bb
--uuv_max_speed : 39
----mission_server
--mission_file : 40
----mission_server
--refLat : 41
----mission_server
--refLon : 42
----mission_server
--next_mission : 43
----mission_server
--decision_threshold : 44
----mission_server
--HSD_out : 45
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----loiter_task
--bb_obstacle_warning : 46
----obstacle_avoidance
--cm_hsd_input : 47
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----loiter_task
--HSD_out_dot_heading : 48
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----loiter_task
--HSD_out_dot_speed : 49
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----loiter_task
--HSD_out_dot_depth : 50
----obstacle_avoidance
----surface_task
----surface_task1
----surface_task2
----surface_task3
----surface_task4
----rth_task
----rth_task1
----loiter_task1
----loiter_task
--bb_home_reached : 51
----home2bb
----home2bb1
--bb_home_dist : 52
----home2bb
----home2bb1
--bb_home_dist_dot_data : 53
----home2bb
----home2bb1
MODULE blackboard_module(active_node, node_names, variable_names, previous_status)
	DEFINE
		variables := [battery_SET.battery, battery_low_warning_SET.battery_low_warning, battery_dot_batt_charge_remaining_SET.battery_dot_batt_charge_remaining, bb_rth_SET.bb_rth, bb_rth_warning_SET.bb_rth_warning, bb_rth_dot_data_SET.bb_rth_dot_data, bb_geofence_SET.bb_geofence, bb_geofence_warning_SET.bb_geofence_warning, bb_geofence_dot_data_SET.bb_geofence_dot_data, lec2_am_r_SET.lec2_am_r, lec2_am_r_speed_warning_SET.lec2_am_r_speed_warning, lec2_am_r_pipe_warning_SET.lec2_am_r_pipe_warning, lec2_am_l_SET.lec2_am_l, lec2_am_l_speed_warning_SET.lec2_am_l_speed_warning, lec2_am_l_pipe_warning_SET.lec2_am_l_pipe_warning, bb_pipelost_SET.bb_pipelost, bb_pipe_lost_warning_SET.bb_pipe_lost_warning, bb_pipelost_dot_data_SET.bb_pipelost_dot_data, bb_mission_dot_data_SET.bb_mission_dot_data, bb_sensor_failure_SET.bb_sensor_failure, bb_sensor_failure_warning_SET.bb_sensor_failure_warning, bb_sensor_failure_dot_data_SET.bb_sensor_failure_dot_data, bb_waypoints_completed_SET.bb_waypoints_completed, bb_waypoints_completed_dot_data_SET.bb_waypoints_completed_dot_data, bb_mission_SET.bb_mission, dd_output_SET.dd_output, dd_z_axis_warning_SET.dd_z_axis_warning, dd_xy_axis_degradation_SET.dd_xy_axis_degradation, fls_range_SET.fls_range, obstacle_standoff_warning_SET.obstacle_standoff_warning, obstacle_min_standoff_SET.obstacle_min_standoff, obstacle_in_view_SET.obstacle_in_view, bb_fls_warning_SET.bb_fls_warning, emergency_stop_warning_SET.emergency_stop_warning, hsd_pipeline_mapping_SET.hsd_pipeline_mapping, hsd_to_waypoint_SET.hsd_to_waypoint, hsd_to_rth_SET.hsd_to_rth, hsd_to_surface_SET.hsd_to_surface, rtreach_out_SET.rtreach_out, uuv_max_speed_SET.uuv_max_speed, mission_file_SET.mission_file, refLat_SET.refLat, refLon_SET.refLon, next_mission_SET.next_mission, decision_threshold_SET.decision_threshold, HSD_out_SET.HSD_out, bb_obstacle_warning_SET.bb_obstacle_warning, cm_hsd_input_SET.cm_hsd_input, HSD_out_dot_heading_SET.HSD_out_dot_heading, HSD_out_dot_speed_SET.HSD_out_dot_speed, HSD_out_dot_depth_SET.HSD_out_dot_depth, bb_home_reached_SET.bb_home_reached, bb_home_dist_SET.bb_home_dist, bb_home_dist_dot_data_SET.bb_home_dist_dot_data];
		variable_exists := [battery_SET.battery_exists, battery_low_warning_SET.battery_low_warning_exists, battery_dot_batt_charge_remaining_SET.battery_dot_batt_charge_remaining_exists, bb_rth_SET.bb_rth_exists, bb_rth_warning_SET.bb_rth_warning_exists, bb_rth_dot_data_SET.bb_rth_dot_data_exists, bb_geofence_SET.bb_geofence_exists, bb_geofence_warning_SET.bb_geofence_warning_exists, bb_geofence_dot_data_SET.bb_geofence_dot_data_exists, lec2_am_r_SET.lec2_am_r_exists, lec2_am_r_speed_warning_SET.lec2_am_r_speed_warning_exists, lec2_am_r_pipe_warning_SET.lec2_am_r_pipe_warning_exists, lec2_am_l_SET.lec2_am_l_exists, lec2_am_l_speed_warning_SET.lec2_am_l_speed_warning_exists, lec2_am_l_pipe_warning_SET.lec2_am_l_pipe_warning_exists, bb_pipelost_SET.bb_pipelost_exists, bb_pipe_lost_warning_SET.bb_pipe_lost_warning_exists, bb_pipelost_dot_data_SET.bb_pipelost_dot_data_exists, bb_mission_dot_data_SET.bb_mission_dot_data_exists, bb_sensor_failure_SET.bb_sensor_failure_exists, bb_sensor_failure_warning_SET.bb_sensor_failure_warning_exists, bb_sensor_failure_dot_data_SET.bb_sensor_failure_dot_data_exists, bb_waypoints_completed_SET.bb_waypoints_completed_exists, bb_waypoints_completed_dot_data_SET.bb_waypoints_completed_dot_data_exists, bb_mission_SET.bb_mission_exists, dd_output_SET.dd_output_exists, dd_z_axis_warning_SET.dd_z_axis_warning_exists, dd_xy_axis_degradation_SET.dd_xy_axis_degradation_exists, fls_range_SET.fls_range_exists, obstacle_standoff_warning_SET.obstacle_standoff_warning_exists, obstacle_min_standoff_SET.obstacle_min_standoff_exists, obstacle_in_view_SET.obstacle_in_view_exists, bb_fls_warning_SET.bb_fls_warning_exists, emergency_stop_warning_SET.emergency_stop_warning_exists, hsd_pipeline_mapping_SET.hsd_pipeline_mapping_exists, hsd_to_waypoint_SET.hsd_to_waypoint_exists, hsd_to_rth_SET.hsd_to_rth_exists, hsd_to_surface_SET.hsd_to_surface_exists, rtreach_out_SET.rtreach_out_exists, uuv_max_speed_SET.uuv_max_speed_exists, mission_file_SET.mission_file_exists, refLat_SET.refLat_exists, refLon_SET.refLon_exists, next_mission_SET.next_mission_exists, decision_threshold_SET.decision_threshold_exists, HSD_out_SET.HSD_out_exists, bb_obstacle_warning_SET.bb_obstacle_warning_exists, cm_hsd_input_SET.cm_hsd_input_exists, HSD_out_dot_heading_SET.HSD_out_dot_heading_exists, HSD_out_dot_speed_SET.HSD_out_dot_speed_exists, HSD_out_dot_depth_SET.HSD_out_dot_depth_exists, bb_home_reached_SET.bb_home_reached_exists, bb_home_dist_SET.bb_home_dist_exists, bb_home_dist_dot_data_SET.bb_home_dist_dot_data_exists];
	VAR
		battery_SET : battery_SET_module(active_node, {6}, variables, variable_exists, node_names, variable_names, previous_status);
		battery_low_warning_SET : battery_low_warning_SET_module(active_node, {6}, variables, variable_exists, node_names, variable_names, previous_status);
		battery_dot_batt_charge_remaining_SET : battery_dot_batt_charge_remaining_SET_module(active_node, {6}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_rth_SET : bb_rth_SET_module(active_node, {7}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_rth_warning_SET : bb_rth_warning_SET_module(active_node, {7, 3}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_rth_dot_data_SET : bb_rth_dot_data_SET_module(active_node, {7}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_geofence_SET : bb_geofence_SET_module(active_node, {8}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_geofence_warning_SET : bb_geofence_warning_SET_module(active_node, {8}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_geofence_dot_data_SET : bb_geofence_dot_data_SET_module(active_node, {8}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_r_SET : lec2_am_r_SET_module(active_node, {9}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_r_speed_warning_SET : lec2_am_r_speed_warning_SET_module(active_node, {9}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_r_pipe_warning_SET : lec2_am_r_pipe_warning_SET_module(active_node, {9}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_l_SET : lec2_am_l_SET_module(active_node, {10}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_l_speed_warning_SET : lec2_am_l_speed_warning_SET_module(active_node, {10}, variables, variable_exists, node_names, variable_names, previous_status);
		lec2_am_l_pipe_warning_SET : lec2_am_l_pipe_warning_SET_module(active_node, {10}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_pipelost_SET : bb_pipelost_SET_module(active_node, {11}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_pipe_lost_warning_SET : bb_pipe_lost_warning_SET_module(active_node, {11}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_pipelost_dot_data_SET : bb_pipelost_dot_data_SET_module(active_node, {11}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_mission_dot_data_SET : bb_mission_dot_data_SET_module(active_node, {11, 14, 3}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_sensor_failure_SET : bb_sensor_failure_SET_module(active_node, {12}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_sensor_failure_warning_SET : bb_sensor_failure_warning_SET_module(active_node, {12}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_sensor_failure_dot_data_SET : bb_sensor_failure_dot_data_SET_module(active_node, {12}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_waypoints_completed_SET : bb_waypoints_completed_SET_module(active_node, {13}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_waypoints_completed_dot_data_SET : bb_waypoints_completed_dot_data_SET_module(active_node, {13}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_mission_SET : bb_mission_SET_module(active_node, {14}, variables, variable_exists, node_names, variable_names, previous_status);
		dd_output_SET : dd_output_SET_module(active_node, {15}, variables, variable_exists, node_names, variable_names, previous_status);
		dd_z_axis_warning_SET : dd_z_axis_warning_SET_module(active_node, {15}, variables, variable_exists, node_names, variable_names, previous_status);
		dd_xy_axis_degradation_SET : dd_xy_axis_degradation_SET_module(active_node, {15}, variables, variable_exists, node_names, variable_names, previous_status);
		fls_range_SET : fls_range_SET_module(active_node, {16}, variables, variable_exists, node_names, variable_names, previous_status);
		obstacle_standoff_warning_SET : obstacle_standoff_warning_SET_module(active_node, {16}, variables, variable_exists, node_names, variable_names, previous_status);
		obstacle_min_standoff_SET : obstacle_min_standoff_SET_module(active_node, {16, 3}, variables, variable_exists, node_names, variable_names, previous_status);
		obstacle_in_view_SET : obstacle_in_view_SET_module(active_node, {17}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_fls_warning_SET : bb_fls_warning_SET_module(active_node, {17}, variables, variable_exists, node_names, variable_names, previous_status);
		emergency_stop_warning_SET : emergency_stop_warning_SET_module(active_node, {17, 22, 3}, variables, variable_exists, node_names, variable_names, previous_status);
		hsd_pipeline_mapping_SET : hsd_pipeline_mapping_SET_module(active_node, {18}, variables, variable_exists, node_names, variable_names, previous_status);
		hsd_to_waypoint_SET : hsd_to_waypoint_SET_module(active_node, {19}, variables, variable_exists, node_names, variable_names, previous_status);
		hsd_to_rth_SET : hsd_to_rth_SET_module(active_node, {20}, variables, variable_exists, node_names, variable_names, previous_status);
		hsd_to_surface_SET : hsd_to_surface_SET_module(active_node, {21}, variables, variable_exists, node_names, variable_names, previous_status);
		rtreach_out_SET : rtreach_out_SET_module(active_node, {22}, variables, variable_exists, node_names, variable_names, previous_status);
		uuv_max_speed_SET : uuv_max_speed_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		mission_file_SET : mission_file_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		refLat_SET : refLat_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		refLon_SET : refLon_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		next_mission_SET : next_mission_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		decision_threshold_SET : decision_threshold_SET_module(active_node, {3}, variables, variable_exists, node_names, variable_names, previous_status);
		HSD_out_SET : HSD_out_SET_module(active_node, {4, 36, 39, 44, 47, 50, 54, 59, 63, 33}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_obstacle_warning_SET : bb_obstacle_warning_SET_module(active_node, {4}, variables, variable_exists, node_names, variable_names, previous_status);
		cm_hsd_input_SET : cm_hsd_input_SET_module(active_node, {4, 36, 39, 44, 47, 50, 54, 59, 63, 33}, variables, variable_exists, node_names, variable_names, previous_status);
		HSD_out_dot_heading_SET : HSD_out_dot_heading_SET_module(active_node, {4, 36, 39, 44, 47, 50, 54, 59, 63, 33}, variables, variable_exists, node_names, variable_names, previous_status);
		HSD_out_dot_speed_SET : HSD_out_dot_speed_SET_module(active_node, {4, 36, 39, 44, 47, 50, 54, 59, 63, 33}, variables, variable_exists, node_names, variable_names, previous_status);
		HSD_out_dot_depth_SET : HSD_out_dot_depth_SET_module(active_node, {4, 36, 39, 44, 47, 50, 54, 59, 63, 33}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_home_reached_SET : bb_home_reached_SET_module(active_node, {55, 60}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_home_dist_SET : bb_home_dist_SET_module(active_node, {55, 60}, variables, variable_exists, node_names, variable_names, previous_status);
		bb_home_dist_dot_data_SET : bb_home_dist_dot_data_SET_module(active_node, {55, 60}, variables, variable_exists, node_names, variable_names, previous_status);

MODULE battery_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		battery := 0; --this isn't actually used. it's representing a pixhawk message
		battery_exists := TRUE;
MODULE battery_low_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		battery_low_warning_exists := TRUE;
	VAR
		battery_low_warning : 0..1;
	ASSIGN
		init(battery_low_warning) := 0;
		next(battery_low_warning) :=
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : battery_low_warning;
			esac;
MODULE battery_dot_batt_charge_remaining_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		battery_dot_batt_charge_remaining_exists := TRUE;
		battery_dot_batt_charge_remaining := 0;
MODULE bb_rth_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_rth := 0; --fake variable
		bb_rth_exists := TRUE;
MODULE bb_rth_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_rth_warning_exists := TRUE;
	VAR
		bb_rth_warning : 0..1;
	ASSIGN
		init(bb_rth_warning) := 0;
		next(bb_rth_warning) := 
			case
				(bb_rth_warning = 1) : 1; -- can't be unset.
				(active_node = node_names.rth2bb) & (next(previous_status) = success) : {0, 1};
				(active_node = node_names.mission_server) & (variables[variable_names.next_mission] = 1) : {0, 1}; -- can be either, but only runs if next mission is true.
				TRUE : bb_rth_warning;
			esac;
MODULE bb_rth_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_rth_dot_data_exists := TRUE;
		bb_rth_dot_data := 0;
MODULE bb_geofence_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_geofence := 0; -- a fake variable
		bb_geofence_exists := TRUE;
MODULE bb_geofence_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_geofence_warning_exists := TRUE;
	VAR
		bb_geofence_warning : 0..1;
	ASSIGN
		init(bb_geofence_warning) := 0;
		next(bb_geofence_warning) := 
			case
				(bb_geofence_warning = 1) : 1;
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_geofence_warning;
			esac;
MODULE bb_geofence_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_geofence_dot_data_exists := TRUE;
		bb_geofence_dot_data := 0;
MODULE lec2_am_r_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_r_exists := TRUE;
		lec2_am_r := 0;
MODULE lec2_am_r_speed_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_r_speed_warning_exists := TRUE;
	VAR
		lec2_am_r_speed_warning : 0..1;
	ASSIGN
		init(lec2_am_r_speed_warning) := 0;
		next(lec2_am_r_speed_warning) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : lec2_am_r_speed_warning;
			esac;
MODULE lec2_am_r_pipe_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_r_pipe_warning_exists := TRUE;
	VAR
		lec2_am_r_pipe_warning : 0..1;
	ASSIGN
		init(lec2_am_r_pipe_warning) := 0;
		next(lec2_am_r_pipe_warning) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : lec2_am_r_pipe_warning;
			esac;
MODULE lec2_am_l_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_l_exists := TRUE;
		lec2_am_l := 0;
MODULE lec2_am_l_speed_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_l_speed_warning_exists := TRUE;
	VAR
		lec2_am_l_speed_warning : 0..1;
	ASSIGN
		init(lec2_am_l_speed_warning) := 0;
		next(lec2_am_l_speed_warning) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : lec2_am_l_speed_warning;
			esac;
MODULE lec2_am_l_pipe_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		lec2_am_l_pipe_warning_exists := TRUE;
	VAR
		lec2_am_l_pipe_warning : 0..1;
	ASSIGN
		init(lec2_am_l_pipe_warning) := 0;
		next(lec2_am_l_pipe_warning) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : lec2_am_l_pipe_warning;
			esac;
MODULE bb_pipelost_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_pipelost := 0;
		bb_pipelost_exists := TRUE;
MODULE bb_pipe_lost_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_pipe_lost_warning_exists := TRUE;
	VAR
		bb_pipe_lost_warning : 0..1;
	ASSIGN
		init(bb_pipe_lost_warning) := 0;
		next(bb_pipe_lost_warning) := 
			case
				(active_node in nodes_with_access) & (variables[variable_names.bb_mission_dot_data] = 1) & (next(previous_status) = success) : {0, 1}; -- only set it if mission_dot_data is pipe-tracking
				TRUE : bb_pipe_lost_warning;
			esac;
MODULE bb_pipelost_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_pipelost_dot_data_exists := TRUE;
		bb_pipelost_dot_data := 0; -- as far as i can tell, this is just going to set the warning
MODULE bb_sensor_failure_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_sensor_failure := 0;
		bb_sensor_failure_exists := TRUE;
MODULE bb_sensor_failure_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_sensor_failure_warning_exists := TRUE;
	VAR
		bb_sensor_failure_warning : 0..1;
	ASSIGN
		init(bb_sensor_failure_warning) := 0;
		next(bb_sensor_failure_warning) := 
			case
				(bb_sensor_failure_warning = 1) : 1;
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_sensor_failure_warning;
			esac;
MODULE bb_sensor_failure_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_sensor_failure_dot_data_exists := TRUE;
		bb_sensor_failure_dot_data := 0; --i think this it just used to set the warning.
MODULE bb_waypoints_completed_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_waypoints_completed := 0; -- fake variable?
		bb_waypoints_completed_exists := TRUE;
MODULE bb_waypoints_completed_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_waypoints_completed_dot_data_exists := TRUE;
	VAR
		bb_waypoints_completed_dot_data : 0..1; -- this one is initialized to false. 
	ASSIGN
		init(bb_waypoints_completed_dot_data) := 0;
		next(bb_waypoints_completed_dot_data) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_waypoints_completed_dot_data;
			esac;
MODULE bb_mission_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_mission := 0;
		bb_mission_exists := TRUE;
MODULE bb_mission_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_mission_dot_data_exists := TRUE;
	VAR
		bb_mission_dot_data : 0..4; -- 0 means other, 1 means pipe-track,  2 means waypoint-follow, 3 means fdr, 4 mean loiter.
	ASSIGN
		init(bb_mission_dot_data) := 1;
		next(bb_mission_dot_data) := 
			case
				(active_node = node_names.mission2bb) & (next(previous_status) = success) : {0, 4};
				(active_node = node_names.mission_server) : {0, 4};
				TRUE : bb_mission_dot_data;
			esac;
MODULE dd_output_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		dd_output_exists := TRUE;
		dd_output := 0;
MODULE dd_z_axis_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		dd_z_axis_warning_exists := TRUE;
	VAR
		dd_z_axis_warning : 0..1;
	ASSIGN
		init(dd_z_axis_warning) := 0;
		next(dd_z_axis_warning) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : dd_z_axis_warning;
			esac;
MODULE dd_xy_axis_degradation_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		dd_xy_axis_degradation_exists := TRUE;
	VAR
		dd_xy_axis_degradation : 0..1;
	ASSIGN
		init(dd_xy_axis_degradation) := 0;
		next(dd_xy_axis_degradation) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : dd_xy_axis_degradation;
			esac;
MODULE fls_range_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		fls_range := 0;
		fls_range_exists := TRUE;
MODULE obstacle_standoff_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		obstacle_standoff_warning_exists := TRUE;
	VAR
		obstacle_standoff_warning : 0..1;
	ASSIGN
		init(obstacle_standoff_warning) := 0;
		next(obstacle_standoff_warning) := 
			case
				(obstacle_standoff_warning = 1) : 1;
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : obstacle_standoff_warning;
			esac;
MODULE obstacle_min_standoff_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		obstacle_min_standoff_exists := TRUE;
		obstacle_min_standoff := 0; -- currently not dealing with this, as it's just used to set the standoff warning, which is just nondeterministic anyways
MODULE obstacle_in_view_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		obstacle_in_view := 0;
		obstacle_in_view_exists := TRUE;
MODULE bb_fls_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_fls_warning_exists := TRUE;
	VAR
		bb_fls_warning : 0..1;
	ASSIGN
		init(bb_fls_warning) := 0;
		next(bb_fls_warning) := 
			case
				(bb_fls_warning = 1 ) : 1;
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_fls_warning;
			esac;
MODULE hsd_pipeline_mapping_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		hsd_pipeline_mapping := 0;
		hsd_pipeline_mapping_exists := TRUE; --yeah i don't know what this does yet
MODULE hsd_to_waypoint_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		hsd_to_waypoint := 0;
		hsd_to_waypoint_exists := TRUE;
MODULE hsd_to_rth_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		hsd_to_rth := 0;
		hsd_to_rth_exists := TRUE;
MODULE hsd_to_surface_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		hsd_to_surface := 0;
		hsd_to_surface_exists := TRUE;
MODULE rtreach_out_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		rtreach_out := 0;
		rtreach_out_exists := TRUE;
MODULE emergency_stop_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		emergency_stop_warning_exists := TRUE;
	VAR
		emergency_stop_warning : 0..1;
	ASSIGN
		init(emergency_stop_warning) := 0;
		next(emergency_stop_warning) := 
			case
				(emergency_stop_warning = 1) : 1;
				(active_node = node_names.mission_server) : {0, 1};
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};--this means we're not in mission server, so only update if success
				TRUE : emergency_stop_warning;
			esac;
MODULE uuv_max_speed_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		uuv_max_speed := 0;
		uuv_max_speed_exists := TRUE;
MODULE mission_file_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		mission_file := 0;
		mission_file_exists := TRUE; -- i actually don't know what this variable is for.
MODULE refLat_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		refLat := 0;
		refLat_exists := TRUE; --not sure what this is either. pretty sure it's storing lattitude.
MODULE refLon_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		refLon := 0;
		refLon_exists := TRUE; --not sure what this is either. pretty sure it's storing longitude
MODULE next_mission_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		next_mission_exists := TRUE;
	VAR
		next_mission : 0..1;
	ASSIGN
		init(next_mission) := 0; -- starts out as false.
		next(next_mission) := 
			case
				--(active_node = node_names.next_mission) : 1;
				(active_node = node_names.waypoint_selector_serene) & (variables[variable_names.bb_waypoints_completed_dot_data] = 0) : 1;
				(active_node = node_names.mission_server) : 0;
				TRUE : next_mission;
			esac;
MODULE decision_threshold_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		decision_threshold := 0;
		decision_threshold_exists := TRUE;
MODULE HSD_out_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		HSD_out := 0; --fake variable
		HSD_out_exists := TRUE; --always exists, cuz it's initialized. 
MODULE bb_obstacle_warning_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_obstacle_warning_exists := TRUE;
	VAR
		bb_obstacle_warning : 0..1;
	ASSIGN
		init(bb_obstacle_warning) := 0; -- starts as false.
		next(bb_obstacle_warning) := 
			case
				(active_node in nodes_with_access) : {0, 1}; -- can be set either way
				TRUE : bb_obstacle_warning;
			esac;
MODULE cm_hsd_input_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		cm_hsd_input := 0;
		cm_hsd_input_exists := TRUE;
MODULE HSD_out_dot_heading_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		HSD_out_dot_heading := 0;
		HSD_out_dot_heading_exists := TRUE;
MODULE HSD_out_dot_speed_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		HSD_out_dot_speed := 0;
		HSD_out_dot_speed_exists := TRUE;
MODULE HSD_out_dot_depth_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		HSD_out_dot_depth := 0;
		HSD_out_dot_depth_exists := TRUE;
MODULE bb_home_reached_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_home_reached_exists := TRUE;
	VAR
		bb_home_reached : 0..1;
	ASSIGN
		init(bb_home_reached) := 0;--starts at false
		next(bb_home_reached) := 
			case
				(active_node in nodes_with_access) & (next(previous_status) = success) : {0, 1};
				TRUE : bb_home_reached;
			esac;
MODULE bb_home_dist_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_home_dist := 0;
		bb_home_dist_exists := TRUE;
MODULE bb_home_dist_dot_data_SET_module(active_node, nodes_with_access, variables, variable_exists, node_names, variable_names, previous_status)
	DEFINE
		bb_home_dist_dot_data := 0;
		bb_home_dist_dot_data_exists := TRUE;

MODULE battery2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rth2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE geofence2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE lec2_am_r_2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE lec2_am_l_2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE pipe_lost2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE sensor_failure2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE waypoints_completed2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE mission2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE ddlec2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE fls2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE fls_warning2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_pipe2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_wp2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_rth2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE hsd_surface2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rtreach2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE reallocate_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE dd_lec_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE mission_server_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE obstacle_avoidance_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE emergency_stop_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : success;
				TRUE : invalid;
			esac;
MODULE surface_task2_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task3_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE surface_task4_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE rth_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE home2bb_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE rth_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE home2bb1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : {success, running};
				TRUE : invalid;
			esac;
MODULE loiter_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE tracking_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_min_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_min_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE speed_max_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_disable_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_disable_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE pipe_mapping_enable_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE next_mission_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : success;
				TRUE : invalid;
			esac;
MODULE loiter_task1_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE waypoint_task_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE loiter_task2_SET_status_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		status := 
			case
				(active_node = id) : running;
				TRUE : invalid;
			esac;
MODULE is_reallocation_requested_CHECK_dd_xy_axis_degradation_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.dd_xy_axis_degradation] = 0);
MODULE battery_low_fs_CHECK_battery_low_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.battery_low_warning] = 0);
MODULE check_sensor_failure_CHECK_bb_sensor_failure_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_sensor_failure_warning] = 0);
MODULE emergency_stop_fs_CHECK_emergency_stop_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.emergency_stop_warning] = 0);
MODULE check_surface_CHECK_bb_home_reached_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_home_reached] = 0);
MODULE obstacle_standoff_fs_CHECK_obstacle_standoff_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := !(variables[variable_names.obstacle_standoff_warning] = 0);
MODULE check_rth_CHECK_bb_rth_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_rth_warning] = 0);
MODULE check_geofence_CHECK_bb_geofence_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_geofence_warning] = 0);
MODULE check_pipe_post_CHECK_bb_pipe_lost_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_pipe_lost_warning] = 0);
MODULE is_track_pipe_mission_requested_CHECK_bb_mission_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_mission_dot_data] = 1);
MODULE is_waypoint_requested_CHECK_bb_mission_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_mission_dot_data] = 2);
MODULE check_lec2am_ls_CHECK_lec2_am_l_speed_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_l_speed_warning] = 0);
MODULE check_lec2am_rs_CHECK_lec2_am_r_speed_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_r_speed_warning] = 0);
MODULE check_lec2am_lp_CHECK_lec2_am_l_pipe_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_l_pipe_warning] = 0);
MODULE check_lec2am_rp_CHECK_lec2_am_r_pipe_warning_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.lec2_am_r_pipe_warning] = 0);
MODULE check_waypoints_completed_CHECK_bb_waypoints_completed_dot_data_module(active_node, id, variables, variable_exists, node_names, variable_names)
	DEFINE
		result := (variables[variable_names.bb_waypoints_completed_dot_data] = 0);


