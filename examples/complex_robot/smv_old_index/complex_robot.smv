MODULE main
    VAR
        system : system_module;
--------------SPECIFICATIONS

CTLSPEC AF(system.flag_returned_stage_0);
LTLSPEC F(system.flag_returned_stage_0);
CTLSPEC AG(((system.zone_stage_0 = target) -> AG(((system.zone_stage_0 != target) -> system.have_flag_stage_0))));
LTLSPEC G(((system.zone_stage_0 = target) -> G(((system.zone_stage_0 != target) -> system.have_flag_stage_0))));

--------------END OF SPECIFICATIONS

MODULE system_module
    CONSTANTS
        success, failure, running, invalid, target, home, maze;
    DEFINE
        resume_from_here_in_subtree__control := -3;
        resume_from_here_in_subtree__set_zone := -3;
        resume_from_here_in_subtree__control_sequence := -3;
        control.active := TRUE;
        --START OF BLACKBOARD DEFINITIONS
        zone_stage_1 := 
            case
                !(set_zone.active) : zone_stage_0;
                !(TRUE) : zone_stage_0;
                (x_stage_0 <= 3) : home;
                (x_stage_0 >= 15) : target;
                TRUE : maze;
            esac;
        side_stage_1 := 
            case
                !(change_side.active) : side_stage_0;
                (side_stage_0 = 1) : -1;
                TRUE : 1;
            esac;
        side_stage_2 := 
            case
                !(change_side_1.active) : side_stage_1;
                (side_stage_1 = 1) : -1;
                TRUE : 1;
            esac;
        side_stage_3 := 
            case
                !(change_side_2.active) : side_stage_2;
                (side_stage_2 = 1) : -1;
                TRUE : 1;
            esac;
        have_flag_stage_1 := 
            case
                !(search_tile.active) : have_flag_stage_0;
                !(TRUE) : have_flag_stage_0;
                have_flag_stage_0 : TRUE;
                TRUE : (search_tile_DOT_tile_searched_stage_1 & (x_stage_0 = flag_x_stage_0) & (y_stage_0 = flag_y_stage_0));
            esac;
        forward_stage_0 :=
            case
                have_flag_stage_0 : -1;
                TRUE : 1;
            esac;
        forward_stage_1 :=
            case
                have_flag_stage_1 : -1;
                TRUE : 1;
            esac;
        x_stage_1 := 
            case
                !(go_forward.active) : x_stage_0;
                (((forward_stage_1 + x_stage_0) >= 0) & ((forward_stage_1 + x_stage_0) <= 18) & ((active_hole_stage_1 = -1) | (active_hole_stage_1 = y_stage_0))) : (x_stage_0 + forward_stage_1);
                TRUE : x_stage_0;
            esac;
        x_stage_2 := 
            case
                !(go_forward_1.active) : x_stage_1;
                (((forward_stage_1 + x_stage_1) >= 0) & ((forward_stage_1 + x_stage_1) <= 18) & ((active_hole_stage_2 = -1) | (active_hole_stage_2 = y_stage_1))) : (x_stage_1 + forward_stage_1);
                TRUE : x_stage_1;
            esac;
        y_stage_1 := 
            case
                !(go_side.active) : y_stage_0;
                (((side_stage_3 + y_stage_0) >= 0) & ((side_stage_3 + y_stage_0) <= 2)) : (y_stage_0 + side_stage_3);
                TRUE : y_stage_0;
            esac;
        y_stage_2 := 
            case
                !(go_side_1.active) : y_stage_1;
                (((side_stage_3 + y_stage_1) >= 0) & ((side_stage_3 + y_stage_1) <= 2)) : (y_stage_1 + side_stage_3);
                TRUE : y_stage_1;
            esac;
        y_stage_3 := 
            case
                !(go_side_2.active) : y_stage_2;
                (((side_stage_3 + y_stage_2) >= 0) & ((side_stage_3 + y_stage_2) <= 2)) : (y_stage_2 + side_stage_3);
                TRUE : y_stage_2;
            esac;
        active_hole_stage_0 :=
            case
                ((x_stage_0 + min(0, forward_stage_0)) = 4) : hole_1_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 1)) : hole_2_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 2)) : hole_3_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 3)) : hole_4_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 4)) : hole_5_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 5)) : hole_6_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 6)) : hole_7_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 7)) : hole_8_stage_0;
                ((x_stage_0 + min(0, forward_stage_0)) = (4 + 8)) : hole_9_stage_0;
                TRUE : -1;
            esac;
        active_hole_stage_1 :=
            case
                ((x_stage_0 + min(0, forward_stage_1)) = 4) : hole_1_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 1)) : hole_2_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 2)) : hole_3_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 3)) : hole_4_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 4)) : hole_5_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 5)) : hole_6_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 6)) : hole_7_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 7)) : hole_8_stage_0;
                ((x_stage_0 + min(0, forward_stage_1)) = (4 + 8)) : hole_9_stage_0;
                TRUE : -1;
            esac;
        active_hole_stage_2 :=
            case
                ((x_stage_1 + min(0, forward_stage_1)) = 4) : hole_1_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 1)) : hole_2_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 2)) : hole_3_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 3)) : hole_4_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 4)) : hole_5_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 5)) : hole_6_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 6)) : hole_7_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 7)) : hole_8_stage_0;
                ((x_stage_1 + min(0, forward_stage_1)) = (4 + 8)) : hole_9_stage_0;
                TRUE : -1;
            esac;
        active_hole_stage_3 :=
            case
                ((x_stage_2 + min(0, forward_stage_1)) = 4) : hole_1_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 1)) : hole_2_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 2)) : hole_3_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 3)) : hole_4_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 4)) : hole_5_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 5)) : hole_6_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 6)) : hole_7_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 7)) : hole_8_stage_0;
                ((x_stage_2 + min(0, forward_stage_1)) = (4 + 8)) : hole_9_stage_0;
                TRUE : -1;
            esac;
        flag_returned_stage_0 :=
            case
                TRUE : (have_flag_stage_0 & (x_stage_0 <= 3));
            esac;
        tile_progress_stage_1 := 
            case
                !(search_tile.active) : tile_progress_stage_0;
                search_tile_DOT_tile_searched_stage_1 : 2;
                TRUE : min(2, (1 + tile_progress_stage_0));
            esac;
        tile_progress_stage_2 := 
            case
                !(control.active) : tile_progress_stage_1;
                (tile_tracker_stage_0 = tile_progress_stage_1) : 0;
                TRUE : tile_progress_stage_1;
            esac;
        search_tile_DOT_tile_searched_stage_0 := search_tile_DOT_tile_searched_stage_1;
        LINK_TO_PREVIOUS_FINAL_search_tile_DOT_tile_searched := search_tile_DOT_tile_searched_stage_1;
        --END OF BLACKBOARD DEFINITIONS
    FROZENVAR
        --START OF BLACKBOARD FROZENVAR
        hole_1_stage_0 : 0..2;
        hole_2_stage_0 : 0..2;
        hole_3_stage_0 : 0..2;
        hole_4_stage_0 : 0..2;
        hole_5_stage_0 : 0..2;
        hole_6_stage_0 : 0..2;
        hole_7_stage_0 : 0..2;
        hole_8_stage_0 : 0..2;
        hole_9_stage_0 : 0..2;
        flag_x_stage_0 : 15..18;
        flag_y_stage_0 : 0..2;
        --END OF BLACKBOARD FROZENVAR
    VAR
        node_names : define_nodes;
        set_zone : success_DEFAULT_module();
        flag_not_returned : flag_not_returned_module(flag_returned_stage_0);
        in_maze : in_maze_module(zone_stage_1);
        can_move_forward : can_move_forward_module(active_hole_stage_0, forward_stage_0, x_stage_0, y_stage_0);
        go_forward : running_DEFAULT_module();
        try_forward : composite_sequence_without_memory_2(can_move_forward, go_forward);
        can_move_side : can_move_side_module(side_stage_0, y_stage_0);
        go_side : running_DEFAULT_module();
        try_side : composite_sequence_without_memory_2(can_move_side, go_side);
        change_side : success_DEFAULT_module();
        return_failure : decorator_X_is_Y(change_side, success, failure);
        try_side_or_change : composite_selector_without_memory_2(try_side, return_failure);
        success_node : success_node_module();
        move_through_maze : composite_selector_without_memory_3(try_forward, try_side_or_change, success_node);
        move_through_maze_decorator : decorator_X_is_Y(move_through_maze, success, running);
        navigate_maze : composite_sequence_without_memory_2(in_maze, move_through_maze_decorator);
        in_maze_1 : in_maze_1_module(zone_stage_1);
        maze_inverter : decorator_inverter(in_maze_1);
        in_target : in_target_module(zone_stage_1);
        flag_found : flag_found_module(have_flag_stage_0);
        go_home : composite_sequence_without_memory_2(in_target, flag_found);
        in_home : in_home_module(zone_stage_1);
        flag_found_1 : flag_found_1_module(have_flag_stage_0);
        flag_inverter : decorator_inverter(flag_found_1);
        go_target : composite_sequence_without_memory_2(in_home, flag_inverter);
        traversal_needed : composite_selector_without_memory_2(go_home, go_target);
        go_forward_1 : running_DEFAULT_module();
        enter_maze : composite_sequence_without_memory_3(maze_inverter, traversal_needed, go_forward_1);
        in_target_1 : in_target_1_module(zone_stage_1);
        need_side : need_side_module(need_side_reached_stage_0);
        can_move_side_1 : can_move_side_1_module(side_stage_1, y_stage_0);
        go_side_1 : running_DEFAULT_module();
        try_side_1 : composite_sequence_without_memory_2(can_move_side_1, go_side_1);
        change_side_1 : success_DEFAULT_module();
        return_failure_1 : decorator_X_is_Y(change_side_1, success, failure);
        try_side_or_change_1 : composite_selector_without_memory_2(try_side_1, return_failure_1);
        side_reached : decorator_X_is_Y(try_side_or_change_1, failure, success);
        never_need_side : success_DEFAULT_module();
        to_side : composite_sequence_without_memory_4(in_target_1, need_side, side_reached, never_need_side);
        in_target_2 : in_target_2_module(zone_stage_1);
        flag_found_2 : flag_found_2_module(have_flag_stage_0);
        flag_inverter_1 : decorator_inverter(flag_found_2);
        search_tile : search_tile_module(have_flag_stage_1, search_tile_DOT_tile_searched_stage_1);
        can_move_side_2 : can_move_side_2_module(side_stage_2, y_stage_0);
        go_side_2 : running_DEFAULT_module();
        try_side_2 : composite_sequence_without_memory_2(can_move_side_2, go_side_2);
        change_side_2 : success_DEFAULT_module();
        return_failure_2 : decorator_X_is_Y(change_side_2, success, failure);
        try_side_or_change_2 : composite_selector_without_memory_2(try_side_2, return_failure_2);
        go_forward_2 : running_DEFAULT_module();
        move_for_flag : composite_selector_without_memory_2(try_side_or_change_2, go_forward_2);
        search_for_flag : composite_selector_without_memory_2(search_tile, move_for_flag);
        search_target : composite_sequence_without_memory_3(in_target_2, flag_inverter_1, search_for_flag);
        control_selector : composite_selector_without_memory_4(navigate_maze, enter_maze, to_side, search_target);
        control_sequence : composite_sequence_without_memory_2(flag_not_returned, control_selector);
        control : composite_parallel_success_on_all_without_memory_2(set_zone, control_sequence);
        --START OF BLACKBOARD VARIABLES DECLARATION
        zone_stage_0 : {home, maze, target};
        side_stage_0 : {-1, 1};
        have_flag_stage_0 : boolean;
        need_side_reached_stage_0 : boolean;
        x_stage_0 : 0..18;
        y_stage_0 : 0..2;
        tile_progress_stage_0 : 0..2;
        tile_tracker_stage_0 : 0..2;
        search_tile_DOT_tile_searched_stage_1 : boolean;
        --END OF BLACKBOARD VARIABLES DECLARATION
    ASSIGN
        --START OF BLACKBOARD VARIABLES INITIALIZATION
        init(zone_stage_0) := 
            case
                TRUE : home;
            esac;
        init(side_stage_0) := 
            case
                TRUE : 1;
            esac;
        init(have_flag_stage_0) := 
            case
                TRUE : FALSE;
            esac;
        init(need_side_reached_stage_0) := 
            case
                TRUE : TRUE;
            esac;
        init(x_stage_0) := 
            case
                TRUE : 0;
            esac;
        init(y_stage_0) := 
            case
                TRUE : 0;
            esac;
        init(hole_1_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_2_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_3_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_4_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_5_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_6_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_7_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_8_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(hole_9_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(flag_x_stage_0) := 
            case
                TRUE : {15, 16, 17, 18};
            esac;
        init(flag_y_stage_0) := 
            case
                TRUE : {0, 1, 2};
            esac;
        init(tile_progress_stage_0) := 
            case
                TRUE : 0;
            esac;
        init(tile_tracker_stage_0) := 
            case
                TRUE : 0;
            esac;
        init(search_tile_DOT_tile_searched_stage_1) := 
            case
                TRUE : FALSE;
            esac;
        --END OF BLACKBOARD VARIABLES INITIALIZATION
        --START OF BLACKBOARD VARIABLES TRANSITION
        next(zone_stage_0) := zone_stage_1;
        next(side_stage_0) := side_stage_3;
        next(have_flag_stage_0) := have_flag_stage_1;
        next(need_side_reached_stage_0) := 
            case
                !(never_need_side.active) : need_side_reached_stage_0;
                TRUE : FALSE;
            esac;
        next(x_stage_0) := 
            case
                !(go_forward_2.active) : x_stage_2;
                (((forward_stage_1 + x_stage_2) >= 0) & ((forward_stage_1 + x_stage_2) <= 18) & ((active_hole_stage_3 = -1) | (active_hole_stage_3 = y_stage_3))) : (x_stage_2 + forward_stage_1);
                TRUE : x_stage_2;
            esac;
        next(y_stage_0) := y_stage_3;
        next(tile_progress_stage_0) := tile_progress_stage_2;
        next(tile_tracker_stage_0) := 
            case
                !(control.active) : tile_tracker_stage_0;
                TRUE : tile_progress_stage_2;
            esac;
        next(search_tile_DOT_tile_searched_stage_1) := 
            case
                !(search_tile.active) : LINK_TO_PREVIOUS_FINAL_search_tile_DOT_tile_searched;
                !(TRUE) : search_tile_DOT_tile_searched_stage_0;
                (tile_progress_stage_0 = 2) : TRUE;
                TRUE : {TRUE, FALSE};
            esac;
        --END OF BLACKBOARD VARIABLES TRANSITION

MODULE define_nodes
    DEFINE
        control := 0;
        set_zone := 1;
        control_sequence := 2;
        flag_not_returned := 3;
        control_selector := 4;
        navigate_maze := 5;
        in_maze := 6;
        move_through_maze_decorator := 7;
        move_through_maze := 8;
        try_forward := 9;
        can_move_forward := 10;
        go_forward := 11;
        try_side_or_change := 12;
        try_side := 13;
        can_move_side := 14;
        go_side := 15;
        return_failure := 16;
        change_side := 17;
        success_node := 18;
        enter_maze := 19;
        maze_inverter := 20;
        in_maze_1 := 21;
        traversal_needed := 22;
        go_home := 23;
        in_target := 24;
        flag_found := 25;
        go_target := 26;
        in_home := 27;
        flag_inverter := 28;
        flag_found_1 := 29;
        go_forward_1 := 30;
        to_side := 31;
        in_target_1 := 32;
        need_side := 33;
        side_reached := 34;
        try_side_or_change_1 := 35;
        try_side_1 := 36;
        can_move_side_1 := 37;
        go_side_1 := 38;
        return_failure_1 := 39;
        change_side_1 := 40;
        never_need_side := 41;
        search_target := 42;
        in_target_2 := 43;
        flag_inverter_1 := 44;
        flag_found_2 := 45;
        search_for_flag := 46;
        search_tile := 47;
        move_for_flag := 48;
        try_side_or_change_2 := 49;
        try_side_2 := 50;
        can_move_side_2 := 51;
        go_side_2 := 52;
        return_failure_2 := 53;
        change_side_2 := 54;
        go_forward_2 := 55;
MODULE decorator_X_is_Y(child_0, incoming_status, outgoing_status)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                child_0.internal_status = incoming_status : outgoing_status;
                TRUE : child_0.internal_status;
            esac;
        child_0.active :=
            case
                !(active) : FALSE;
                TRUE : TRUE;
            esac;
MODULE composite_parallel_success_on_all_without_memory_2(child_0, child_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                (child_0.internal_status = failure) : failure;
                (child_1.internal_status = failure) : failure;
                !(child_0.internal_status = success) : child_0.internal_status;
                !(child_1.internal_status = success) : child_1.internal_status;
                TRUE : success;
            esac;
        child_0.active := active;
        child_1.active := active;
MODULE composite_selector_without_memory_2(child_0, child_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = failure) : child_0.internal_status;
                !(child_1.internal_status = failure) : child_1.internal_status;
                TRUE : failure;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = failure;
MODULE composite_selector_without_memory_3(child_0, child_1, child_2)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = failure) : child_0.internal_status;
                !(child_1.internal_status = failure) : child_1.internal_status;
                !(child_2.internal_status = failure) : child_2.internal_status;
                TRUE : failure;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = failure;
        child_2.active := child_1.status = failure;
MODULE decorator_inverter(child_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                child_0.internal_status = success : failure;
                child_0.internal_status = failure : success;
                TRUE : child_0.status;
            esac;
        child_0.active :=
            case
                !(active) : FALSE;
                TRUE : TRUE;
            esac;
MODULE composite_sequence_without_memory_2(child_0, child_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = success) : child_0.internal_status;
                !(child_1.internal_status = success) : child_1.internal_status;
                TRUE : success;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = success;
MODULE composite_sequence_without_memory_3(child_0, child_1, child_2)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = success) : child_0.internal_status;
                !(child_1.internal_status = success) : child_1.internal_status;
                !(child_2.internal_status = success) : child_2.internal_status;
                TRUE : success;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = success;
        child_2.active := child_1.status = success;
MODULE composite_selector_without_memory_4(child_0, child_1, child_2, child_3)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = failure) : child_0.internal_status;
                !(child_1.internal_status = failure) : child_1.internal_status;
                !(child_2.internal_status = failure) : child_2.internal_status;
                !(child_3.internal_status = failure) : child_3.internal_status;
                TRUE : failure;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = failure;
        child_2.active := child_1.status = failure;
        child_3.active := child_2.status = failure;
MODULE composite_sequence_without_memory_4(child_0, child_1, child_2, child_3)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status :=
            case
                !(child_0.internal_status = success) : child_0.internal_status;
                !(child_1.internal_status = success) : child_1.internal_status;
                !(child_2.internal_status = success) : child_2.internal_status;
                !(child_3.internal_status = success) : child_3.internal_status;
                TRUE : success;
            esac;
        child_0.active := active;
        child_1.active := child_0.status = success;
        child_2.active := child_1.status = success;
        child_3.active := child_2.status = success;
MODULE flag_not_returned_module(flag_returned_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (!(flag_returned_stage_0)) ? success : failure;
MODULE in_maze_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = maze)) ? success : failure;
MODULE can_move_forward_module(active_hole_stage_0, forward_stage_0, x_stage_0, y_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((((forward_stage_0 + x_stage_0) >= 0) & ((forward_stage_0 + x_stage_0) <= 18) & ((active_hole_stage_0 = -1) | (active_hole_stage_0 = y_stage_0)))) ? success : failure;
MODULE can_move_side_module(side_stage_0, y_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((((side_stage_0 + y_stage_0) >= 0) & ((side_stage_0 + y_stage_0) <= 2))) ? success : failure;
MODULE success_node_module()
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (TRUE) ? success : failure;
MODULE in_maze_1_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = maze)) ? success : failure;
MODULE in_target_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = target)) ? success : failure;
MODULE flag_found_module(have_flag_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (have_flag_stage_0) ? success : failure;
MODULE in_home_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = home)) ? success : failure;
MODULE flag_found_1_module(have_flag_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (have_flag_stage_0) ? success : failure;
MODULE in_target_1_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = target)) ? success : failure;
MODULE need_side_module(need_side_reached_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (need_side_reached_stage_0) ? success : failure;
MODULE can_move_side_1_module(side_stage_1, y_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((((side_stage_1 + y_stage_0) >= 0) & ((side_stage_1 + y_stage_0) <= 2))) ? success : failure;
MODULE in_target_2_module(zone_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((zone_stage_1 = target)) ? success : failure;
MODULE flag_found_2_module(have_flag_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := (have_flag_stage_0) ? success : failure;
MODULE search_tile_module(have_flag_stage_1, search_tile_DOT_tile_searched_stage_1)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := 
            case
                (search_tile_DOT_tile_searched_stage_1 & have_flag_stage_1) : success;
                search_tile_DOT_tile_searched_stage_1 : failure;
                TRUE : running;
            esac;
MODULE can_move_side_2_module(side_stage_2, y_stage_0)
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := ((((side_stage_2 + y_stage_0) >= 0) & ((side_stage_2 + y_stage_0) <= 2))) ? success : failure;
MODULE success_DEFAULT_module
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := success;
MODULE running_DEFAULT_module
    CONSTANTS
        success, failure, running, invalid;
    DEFINE
        status := active ? internal_status : invalid;
        internal_status := running;
