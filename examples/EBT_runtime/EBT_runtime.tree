configuration {
    #{ Here you specify various configuration options, such as Hypersafety }#
}
enumerations {
    #{ here you specify the enumerations used in the model}#
    'x_sub', 'y_sub'
}
constants {
    #{ constants are used to synchronize values in a .tree file. }#
    #{ example := 0 }#
    #{ to use example elsewhere, simply type 'example' in place of any integer (quotes included) }#
    path_size := 25, x_min := 0, x_max := 19, y_min := 0, y_max := 19, obs_count := 20, landmark_count := 5
} end_constants

variables {
    #{ Variable declarations go here.
	it is suggested, but not required, that the order of declaration be
	Blackboard, Local, Environment.
	If variable B depends on variable A, then variable A MUST be declared before B.
    }#
    variable { bl drone_x VAR [x_min, x_max] assign {result{0}}}
    variable { bl drone_y VAR [y_min, y_max] assign {result{0}}}
    #{
    variable { bl current_landmark_x VAR [x_min, y_min] assign {result{0}}}
    variable { bl current_landmark_y VAR [y_min, y_max] assign {result{0}}}
    }#
    variable { bl obstacles array (mult, obs_count, 2) DEFINE INT default {assign{ result{0}}} constant_index
	index_of {0} assign {result{0}}
	index_of {2} assign {result{2}}
	index_of {4} assign {result{2}}
	index_of {6} assign {result{4}}
	index_of {8} assign {result{4}}
	index_of {10} assign {result{5}}
	index_of {12} assign {result{5}}
	index_of {14} assign {result{7}}
	index_of {16} assign {result{7}}
	index_of {18} assign {result{7}}
	index_of {20} assign {result{8}}
	index_of {22} assign {result{9}}
	index_of {24} assign {result{10}}
	index_of {26} assign {result{11}}
	index_of {28} assign {result{12}}
	index_of {30} assign {result{12}}
	index_of {32} assign {result{15}}
	index_of {34} assign {result{15}}
	index_of {36} assign {result{16}}
	index_of {38} assign {result{17}}
	#{}#
	index_of {1} assign {result{8}}
	index_of {3} assign {result{2}}
	index_of {5} assign {result{14}}
	index_of {7} assign {result{9}}
	index_of {9} assign {result{10}}
	index_of {11} assign {result{2}}
	index_of {13} assign {result{3}}
	index_of {15} assign {result{0}}
	index_of {17} assign {result{6}}
	index_of {19} assign {result{7}}
	index_of {21} assign {result{14}}
	index_of {23} assign {result{10}}
	index_of {25} assign {result{10}}
	index_of {27} assign {result{4}}
	index_of {29} assign {result{4}}
	index_of {31} assign {result{18}}
	index_of {33} assign {result{8}}
	index_of {35} assign {result{14}}
	index_of {37} assign {result{2}}
	index_of {39} assign {result{17}}
    }
    variable { bl waypoint_x VAR [x_min, x_max] assign {result{(loop, loop_var, [x_min, x_max] such_that True, loop_var)}}}
    variable { bl waypoint_y VAR [y_min, y_max] assign {result{(loop, loop_var, [y_min, y_max] such_that True,
		    (if,
			(or,
			    (loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
				(and,
				    (eq, (index, obstacles, constant_index (mult, obs_index, 2)), waypoint_x),
				    (eq, (index, obstacles, constant_index (add, (mult, obs_index, 2), 1)), loop_var)
				)
			    )
			),
			y_max,
			loop_var
		    )
		)
	    }
	}
    }
    variable {bl current_landmark_x VAR [x_min, x_max] assign{result{drone_x}}}
    variable {bl current_landmark_y VAR [y_min, y_max] assign{result{drone_y}}}
    variable {bl subgoal_var VAR {'x_sub', 'y_sub'} assign{result{'x_sub'}}}
    variable {bl crashed DEFINE BOOLEAN assign{result{(or, (loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
			(and,
			    (eq, drone_x, (index, obstacles, constant_index (mult, obss_index, 2))),
			    (eq, drone_y, (index, obstacles, constant_index (and, (mult, obss_index, 2), 1)))
			)
		    )
		)
	    }}}
    variable {bl victory DEFINE BOOLEAN assign{result{(and, (eq, drone_x, waypoint_x), (eq, drone_y, waypoint_y))}}}
    variable {bl need_update VAR BOOLEAN assign{result{False}}}
} end_variables

environment_update {
} end_environment_update

checks {
    check {
	dont_update
	arguments {}
	read_variables {need_update}
	condition {(not, need_update)}
    }
    check {
	not_at_landmark
	arguments {}
	read_variables {drone_x, drone_y, current_landmark_x, current_landmark_y}
	condition {(not, (and, (eq, drone_x, current_landmark_x), (eq, drone_y, current_landmark_y)))}
    }
    check {
	safe_landmark
	arguments {}
	read_variables {current_landmark_x, current_landmark_y, obstacles}
	condition {
	    (not,
		(or,
		    (loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
			(and,
			    (eq, current_landmark_x, (index, obstacles, constant_index (mult, obs_index, 2))),
			    (eq, current_landmark_y, (index, obstacles, constant_index (add, (mult, obs_index, 2), 1)))
			)
		    )
		)
	    )
	}
    }
} end_checks

environment_checks {
} end_environment_checks

actions {
    action {
	force_update arguments {} local_variables {} read_variables{} write_variables{need_update}
	initial_values{}
	update{
	    variable_statement{
		need_update
		assign{result{True}}
	    }
	}
    action {
	get_next_landmark arguments {} local_variables {}
	read_variables {waypoint_x, waypoint_y, drone_x, drone_y}
	write_variables{current_landmark_x, current_landmark_y, need_update}
	initial_values {}
	update {
	    variable_statement {
		current_landmark_x
		assign{
		    case{(lt, drone_x, current_landmark_x)} result{(max, x_min, (sub, current_landmark_x, 1))}
		    case{(gt, drone_x, current_landmark_x)} result{(min, x_max, (add, current_landmark_x, 1))} 
		    case{(eq, current_landmark_x, waypoint_x)} result{waypoint_x}
		    case{(lt, current_landmark_x, waypoint_x)} result{(min, (add, current_landmark_x, 4), waypoint_x)}
		    result{(max, (sub, current_landmark_x, 4), waypoint_x)}
	    }
	    variable_statement {
		current_landmark_y
		assign{
		    case{(lt, drone_y, current_landmark_y)} result{(max, y_min, (sub, current_landmark_y, 1))}
		    case{(gt, drone_y, current_landmark_y)} result{(min, y_max, (add, current_landmark_y, 1))} 
		    case{(eq, current_landmark_y, waypoint_y)} result{waypoint_x}
		    case{(lt, current_landmark_y, waypoint_y)} result{(min, (add, current_landmark_x, 4), waypoint_x)}
		    result{(max, (sub, current_landmark_y, 4), waypoint_y)}
	    }
	    variable_statement{
		need_update
		assign{result{False}}
	    }
	    return_statement { result {success}}
	}
    }
    action {
	move_action arguments {} local_variables {}
	read_variables {subgoal_var}
	write_variables{drone_x, drone_y}
	initial_values {}
	update {
	    variable_statement {
		drone_x
		assign {
		    case {(eq, subgoal_var, 'y_sub')} result {drone_x}
		    case {(eq, drone_x, current_landmark_x)} result{drone_x}
		    case {(lt, drone_x, current_landmark_x)} result{(min, x_max, (add, drone_x, 1))}
		    result{(max, x_min, (sub, drone_x, 1))}
		}
	    }
	    variable_statement {
		drone_y
		assign {
		    case {(eq, subgoal_var, 'x_sub')} result {drone_y}
		    case {(eq, drone_y, current_landmark_y)} result{drone_y}
		    case {(lt, drone_y, current_landmark_y)} result{(min, y_max, (add, drone_y, 1))}
		    result{(max, y_min, (sub, drone_y, 1))}
		}
	    }
	    return_statement { result {success}}
	}
    }
} end_actions

sub_trees {#{ subtrees go here. }#
} end_sub_trees

tree {
    #{ the tree is defined here}#
    composite {
	ebt_root sequence
	children {
	    composite {
		landmark_update selector
		children {
		    dont_update {}
		    get_next_landmark {}
		}
	    }
	    composite {
		landmark_validation selector
		children {
		    composite {
			valid_landmark sequence
			children {
			    not_at_landmark {}
			    safe_landmark {}
			}
		    }
		    force_update {}
		}
	    }
	    move_action{}
	}
    }
} end_tree




tick_prerequisite { (and, (not, crashed), (not, victory))} end_tick_prerequisite

specifications {
} end_specifications