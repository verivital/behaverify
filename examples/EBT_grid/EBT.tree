configuration {
    #{ Here you specify various configuration options, such as Hypersafety }#
}
enumerations {
    #{ here you specify the enumerations used in the model}#
}
constants {
    #{ constants are used to synchronize values in a .tree file. }#
    #{ example := 0 }#
    #{ to use example elsewhere, simply type 'example' in place of any integer (quotes included) }#
    path_size := 25, x_min := 0, x_max := 19, y_min := 0, y_max := 19, obs_count := 20, landmark_count := 25
} end_constants

variables {
    #{ Variable declarations go here.
	it is suggested, but not required, that the order of declaration be
	Blackboard, Local, Environment.
	If variable B depends on variable A, then variable A MUST be declared before B.
    }#
    variable { bl drone_x VAR [x_min, x_max] assign {result{0}}}
    variable { bl drone_y VAR [y_min, y_max] assign {result{0}}}
    variable { bl landmark_index VAR [0, (sub, landmark_count, 1)] assign {result {0}}}
    #{
    variable { bl current_landmark_x VAR [x_min, y_min] assign {result{0}}}
    variable { bl current_landmark_y VAR [y_min, y_max] assign {result{0}}}
    }#
    variable { bl obstacles_sort_x array (mult, obs_count, 2) DEFINE INT default {assign{ result{0}}} constant_index
	index_of {0} assign {result{0}}
	index_of {2} assign {result{2}}
	index_of {4} assign {result{2}}
	index_of {6} assign {result{4}}
	index_of {8} assign {result{4}}
	index_of {10} assign {result{5}}
	index_of {12} assign {result{5}}
	index_of {14} assign {result{7}}
	index_of {16} assign {result{7}}
	index_of {18} assign {result{7}}
	index_of {20} assign {result{8}}
	index_of {22} assign {result{9}}
	index_of {24} assign {result{10}}
	index_of {26} assign {result{11}}
	index_of {28} assign {result{12}}
	index_of {30} assign {result{12}}
	index_of {32} assign {result{15}}
	index_of {34} assign {result{15}}
	index_of {36} assign {result{16}}
	index_of {38} assign {result{17}}
	#{}#
	index_of {1} assign {result{8}}
	index_of {3} assign {result{2}}
	index_of {5} assign {result{14}}
	index_of {7} assign {result{9}}
	index_of {9} assign {result{10}}
	index_of {11} assign {result{2}}
	index_of {13} assign {result{3}}
	index_of {15} assign {result{0}}
	index_of {17} assign {result{6}}
	index_of {19} assign {result{7}}
	index_of {21} assign {result{14}}
	index_of {23} assign {result{10}}
	index_of {25} assign {result{10}}
	index_of {27} assign {result{4}}
	index_of {29} assign {result{4}}
	index_of {31} assign {result{18}}
	index_of {33} assign {result{8}}
	index_of {35} assign {result{14}}
	index_of {37} assign {result{2}}
	index_of {39} assign {result{17}}
    }
    variable { bl obstacles_sort_y array (mult, obs_count, 2) DEFINE INT default {assign{ result{0}}} constant_index
	index_of {0} assign {result{7}}
	index_of {2} assign {result{2}}
	index_of {4} assign {result{5}}
	index_of {6} assign {result{16}}
	index_of {8} assign {result{5}}
	index_of {10} assign {result{11}}
	index_of {12} assign {result{12}}
	index_of {14} assign {result{7}}
	index_of {16} assign {result{7}}
	index_of {18} assign {result{0}}
	index_of {20} assign {result{15}}
	index_of {22} assign {result{4}}
	index_of {24} assign {result{4}}
	index_of {26} assign {result{9}}
	index_of {28} assign {result{10}}
	index_of {30} assign {result{2}}
	index_of {32} assign {result{8}}
	index_of {34} assign {result{15}}
	index_of {36} assign {result{17}}
	index_of {38} assign {result{12}}
	#{}#
	index_of {1} assign {result{0}}
	index_of {3} assign {result{2}}
	index_of {5} assign {result{2}}
	index_of {7} assign {result{2}}
	index_of {9} assign {result{3}}
	index_of {11} assign {result{4}}
	index_of {13} assign {result{4}}
	index_of {15} assign {result{6}}
	index_of {17} assign {result{7}}
	index_of {19} assign {result{8}}
	index_of {21} assign {result{8}}
	index_of {23} assign {result{9}}
	index_of {25} assign {result{10}}
	index_of {27} assign {result{10}}
	index_of {29} assign {result{10}}
	index_of {31} assign {result{14}}
	index_of {33} assign {result{14}}
	index_of {35} assign {result{14}}
	index_of {37} assign {result{17}}
	index_of {39} assign {result{18}}
    }
    variable { bl waypoint_x VAR [x_min, x_max] assign {result{(loop, loop_var, [x_min, x_max] such_that True, loop_var)}}}
    variable { bl waypoint_y VAR [y_min, y_max] assign {result{(loop, loop_var, [y_min, y_max] such_that
		    (not, (or,
			    (loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
				(and,
				    (eq, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x),
				    (eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), loop_var)))))
		    , loop_var)}}}
    variable { bl landmark array (mult, landmark_count, 2) DEFINE INT iterative_assign, index_var
	condition {(eq, index_var, 0)} assign{result {0}}
	condition {(eq, index_var, 1)} assign{result {0}}
	condition {(eq, index_var, 2)} assign {
	    case {(eq, 0, waypoint_x)} result{0}
	    case {(lt, 0, waypoint_x)} result{
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(gt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (sub, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	    result{
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(lt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (add, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	}
	condition {(eq, index_var, 3)} assign{result{(index, landmark, constant_index (sub, index_var, 2))}}
	#{x change 1, emergency go right}#condition {(eq, (mod, index_var, 12), 6)} assign {
	    case {(and,
		    (eq, (index, landmark, constant_index (sub, index_var, 1)), (index, landmark, constant_index (sub, index_var, 3))),
		    (eq, (index, landmark, constant_index (sub, index_var, 2)), (index, landmark, constant_index (sub, index_var, 4)))
		)
	    } result {
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(gt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), x_max)
		    ),
		    (sub, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    x_max
		)}
	    case {(eq, (index, landmark, constant_index (sub, index_var, 2)), waypoint_x)} result{(index, landmark, constant_index (sub, index_var, 2))}
	    case {(lt, (index, landmark, constant_index (sub, index_var, 2)), waypoint_x)} result{
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(gt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (sub, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	    result{
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(lt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (add, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	}
	#{x change 2, emergency go left}#condition {(eq, (mod, index_var, 4), 2)} assign {
	    case {(and,
		    (eq, (index, landmark, constant_index (sub, index_var, 1)), (index, landmark, constant_index (sub, index_var, 3))),
		    (eq, (index, landmark, constant_index (sub, index_var, 2)), (index, landmark, constant_index (sub, index_var, 4)))
		)
	    } result {
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(lt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), x_min)
		    ),
		    (add, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    x_min
		)}
	    case {(eq, (index, landmark, constant_index (sub, index_var, 2)), waypoint_x)} result{(index, landmark, constant_index (sub, index_var, 2))}
	    case {(lt, (index, landmark, constant_index (sub, index_var, 2)), waypoint_x)} result{
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(gt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (sub, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	    result{
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_x, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 1))),
			(lt, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), waypoint_x)
		    ),
		    (add, (index, obstacles_sort_x, constant_index (mult, obs_index, 2)), 1),
		    waypoint_x
		)}
	}
	#{y change 1, emergency go up}#condition {(eq, (mod, index_var, 8), 5)} assign {
	    case {(and,
		    (eq, (index, landmark, constant_index (sub, index_var, 3)), (index, landmark, constant_index (sub, index_var, 5))),
		    (eq, (index, landmark, constant_index (sub, index_var, 2)), (index, landmark, constant_index (sub, index_var, 4)))
		)
	    } result {
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(gt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), y_max)
		    ),
		    (sub, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), 1),
		    y_max
		)}
	    case {(eq, (index, landmark, constant_index (sub, index_var, 2)), waypoint_y)} result{(index, landmark, constant_index (sub, index_var, 2))}
	    case {(lt, (index, landmark, constant_index (sub, index_var, 2)), waypoint_y)} result{
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(gt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), waypoint_y)
		    ),
		    (sub, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), 1),
		    waypoint_y
		)}
	    result {
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(lt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), waypoint_y)
		    ),
		    (add, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), 1),
		    waypoint_y
		)}
	}
	#{y change 2, emergency go down}#condition {(eq, (mod, index_var, 4), 1)} assign {
	    case {(and,
		    (eq, (index, landmark, constant_index (sub, index_var, 3)), (index, landmark, constant_index (sub, index_var, 5))),
		    (eq, (index, landmark, constant_index (sub, index_var, 2)), (index, landmark, constant_index (sub, index_var, 4)))
		)
	    } result {
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(lt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), y_min)
		    ),
		    (add, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), 1),
		    y_min
		)}
	    case {(eq, (index, landmark, constant_index (sub, index_var, 2)), waypoint_y)} result{(index, landmark, constant_index (sub, index_var, 2))}
	    case {(lt, (index, landmark, constant_index (sub, index_var, 2)), waypoint_y)} result{
		(case_loop, obs_index, [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(gt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(lte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), waypoint_y)
		    ),
		    (sub, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), 1),
		    waypoint_y
		)}
	    result {
		(case_loop, obs_index, reverse [0, (sub, obs_count, 1)] such_that True,
		    (and,
			(eq, (index, obstacles_sort_y, constant_index (mult, obs_index, 2)), (index, landmark, constant_index (sub, index_var, 3))),
			(lt, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), (index, landmark, constant_index (sub, index_var, 2))),
			(gte, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), waypoint_y)
		    ),
		    (add, (index, obstacles_sort_y, constant_index (add, (mult, obs_index, 2), 1)), 1),
		    waypoint_y
		)}
	}
	#{Default case: use last value}#assign{result{(index, landmark, constant_index (sub, index_var, 2))}} 
    }
    variable {bl current_landmark_x DEFINE INT assign{result{(index, landmark, (mult, landmark_index, 2))}}}
    variable {bl current_landmark_y DEFINE INT assign{result{(index, landmark, (add, (mult, landmark_index, 2), 1))}}}
} end_variables

environment_update {
} end_environment_update

checks {
    check {
	is_path_computed
	arguments {}
	read_variables {}
	condition {True}
    }
    check {
	is_waypoint_reached
	arguments {}
	read_variables {drone_x, drone_y, waypoint_x, waypoint_y}
	condition {(and, (eq, drone_x, waypoint_x), (eq, drone_y, waypoint_y))}
    }
    check {
	is_close_to_landmark
	arguments {}
	read_variables {drone_x, drone_y, current_landmark_x, current_landmark_y}
	condition {(and, (eq, drone_x, current_landmark_x), (eq, drone_y, current_landmark_y))}
    }
} end_checks

environment_checks {
} end_environment_checks

actions {
    action {
	compute_path arguments {} local_variables {}
	read_variables {}
	write_variables{}
	initial_values {}
	update {
	    return_statement {result {success}}
	}
    }
    action {
	get_next_landmark arguments {} local_variables {}
	read_variables {}
	write_variables{landmark_index}
	initial_values {}
	update {
	    variable_statement {
		landmark_index
		assign{result{(min, (sub, landmark_count, 1), (add, landmark_index, 1))}}
	    }
	    return_statement { result {success}}
	}
    }
    action {
	get_next_subgoal arguments {} local_variables {}
	read_variables {}
	write_variables{}
	initial_values {}
	update {
	    return_statement { result {success}}
	}
    }
    action {
	move_action arguments {} local_variables {}
	read_variables {current_landmark_x, current_landmark_y}
	write_variables{drone_x, drone_y}
	initial_values {}
	update {
	    variable_statement {
		drone_x
		assign {
		    case {(eq, drone_x, current_landmark_x)} result{drone_x}
		    case {(lt, drone_x, current_landmark_x)} result{(min, x_max, (add, drone_x, 1))}
		    result{(max, x_min, (sub, drone_x, 1))}
		}
	    }
	    variable_statement {
		drone_y
		assign {
		    case {(eq, drone_y, current_landmark_y)} result{drone_y}
		    case {(lt, drone_y, current_landmark_y)} result{(min, y_max, (add, drone_y, 1))}
		    result{(max, y_min, (sub, drone_y, 1))}
		}
	    }
	    return_statement { result {success}}
	}
    }
} end_actions

sub_trees {#{ subtrees go here. }#
    sub_tree {
	INITIAL_SETUP_SUBTREE
	composite {
	    path_selector selector
	    children {
		is_path_computed {}
		compute_path {}
	    }
	}
    }
    sub_tree {
	MAIN_SUBTREE
	composite {
	    main_selector selector
	    children {
		is_waypoint_reached {}
		composite {
		    landmark_sequence sequence children{ is_close_to_landmark {} get_next_landmark {} }
		}
		composite {
		    movement_sequence sequence children{ get_next_subgoal {} move_action {} }
		}
	    }
	}
    }
} end_sub_trees

tree {
    #{ the tree is defined here}#
    composite {
	ebt_root sequence
	children {
	    insert {INITIAL_SETUP_SUBTREE}
	    insert {MAIN_SUBTREE}
	}
    }
} end_tree




tick_prerequisite { (True) } end_tick_prerequisite
#{ if the condition is True, the tree ticks.
    If it is false, everything is done }#

specifications {
    CTLSPEC {(always_finally, (and, (eq, drone_x at -1, waypoint_x at -1), (eq, drone_y at -1, waypoint_y at -1)))}
} end_specifications