

system BlueROV;  //system name

//-----------------------------------
//basic types 
//-----------------------------------

type string;
type bool;
type integer;
type float;
type float32;
type float64;


//-----------------------------------
//message types
//-----------------------------------
message Bool std_msgs
	bool value;
end

message Float32 std_msgs
	float value;
end

message String std_msgs
	string value;
end

message PixhawkHW vandy_bluerov
	float64 thrusters_power;
	float64 batt_capacity_remaining;
	float64 batt_voltage_remaining;
	float64 batt_charge_remaining;
	float32[] rpm;
end

message AssuranceMonitorConfidence ng_msgs
	float32 confidence_level;
	float32[] values;
end

message HSDCommand ng_msgs
	float64 heading;
	float64 speed;
	float64 depth;
end


message LEC1OutputAssuredStamped ng_msgs
    AssuranceMonitorConfidence[] confs;
    HSDCommand cmd;
    float64 current_heading;
end

message Float32MultiArray std_msgs
    float32[] data;
end

//-----------------------------------
//topics
//-----------------------------------

topic PixhawkHW pixhawk_hw /iver0/pixhawk_hw;
topic LEC1OutputAssuredStamped lec_dd_am /lec_dd_am/p_value;
topic Bool bb_geofence /iver0/bb_geofence;
topic Bool bb_pipelost /iver0/bb_pipe_lost;
topic Float32 bb_home_dist /iver0/bb_home_dist;
topic LEC1OutputAssuredStamped lec2_left_am /lec2_am/left/p_value;
topic LEC1OutputAssuredStamped lec2_right_am /lec2_am/right/p_value; 
topic String bb_mission /bb_mission;
topic Bool bb_rth /iver0/bb_rth;
topic Bool bb_sensor_failure /iver0/sensor_failure_rpm;
topic Bool bb_waypoints_completed /iver0/waypoints_completed;
topic HSDCommand hsd_pipeline_mapping /iver0/hsd_pipeline_mapping;
topic HSDCommand hsd_to_surface /iver0/hsd_to_surface;
topic HSDCommand hsd_to_rth /iver0/hsd_to_rth;
topic HSDCommand hsd_to_waypoint /iver0/hsd_to_waypoint;
topic HSDCommand hsd_obstacle_avoidance /iver0/hsd_obstacle_avoidance;
topic HSDCommand hsd_command /iver0/hsd_command;
topic String cm_hsd_input /iver0/cm_hsd_input;
topic Float32MultiArray degradation_detector /iver0/degradation_detector;
topic Float32MultiArray degradation_detector_am /iver0/degradation_detector_am/p_value;
topic Float32MultiArray lec_input /iver0/thruster_cmd_logging;

//-----------------------------------
//Blackboard variables
//-----------------------------------

var PixhawkHW battery;
    init '1';
    min 0;
    max 1;
    nodes_that_set {
    		   node_name  battery2bb;
		   }
end_var
var LEC1OutputAssuredStamped lec_dd_am;
end_var
var Bool bb_geofence = False;
end_var
var Bool bb_pipelost = False;
end_var
var Float32 bb_home_dist = 1000;
end_var
var LEC1OutputAssuredStamped lec2_am_l;
end_var
var LEC1OutputAssuredStamped lec2_am_r;
end_var
var String bb_mission = "";
end_var
var Bool bb_rth = False;
end_var
var Bool bb_sensor_failure = False;
end_var
var Bool bb_waypoints_completed = False;
end_var
var HSDCommand bb_HSD_out;
end_var
var Bool bb_pipe_mapping_enable = False;
end_var
var bool bb_obstacle_warning = False;
end_var
var bool event_reallocate_button = False;
end_var
var Float32MultiArray dd_output;
end_var
var Float32MultiArray lec_input;
end_var



var Bool battery_low_warning;
    init '0';
    min 0;
    max 1;
    nodes_that_set {
    		   node_name  battery2bb;
		   }
end_var
var Bool lec_dd_am_warning;
end_var
var Bool bb_rth_warning;
end_var
var Bool bb_geofence_warning;
end_var
var Bool lec2_am_l_pipe_warning;
end_var
var Bool lec2_am_l_speed_warning;
end_var
var Bool lec2_am_r_pipe_warning;
end_var
var Bool lec2_am_r_speed_warning;
end_var
var Bool bb_pipe_lost_warning;
end_var
var Bool bb_sensor_failure_warning;
end_var
var Bool bb_home_reached;
end_var
var Bool dd_z_axis_warning;
end_var
var Bool dd_xy_axis_degradation;
end_var

//-----------------------------------
//Modeling Only Variables
//-----------------------------------

var Bool task_mission_server_mission_len;
    variable_type DEFINE;
    init "3";
end_var

var Bool task_mission_server_mission_type_list;
    variable_type DEFINE;
    init "[mission_type_0, mission_type_1, mission_type_2]";
end_var

var Bool task_mission_server_mission_distance_list;
    variable_type DEFINE;
    init "[mission_distance_0, mission_distance_1, mission_distance_2]";
end_var
var Bool total_degradation_threshold;
    variable_type DEFINE;
    init "0";
end_var
var Bool home_reached_threshold;
    variable_type DEFINE;
    init "0";
end_var
var Bool mission_type_0;
    variable_type FROZENVAR;
    //custom_value_range  '{mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown}'
end_var
var Bool mission_type_1;
    variable_type FROZENVAR;
    //custom_value_range  '{mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown}'
end_var
var Bool mission_type_2;
    variable_type FROZENVAR;
    //custom_value_range  '{mission_type_path_following, mission_type_waypoint_following, mission_type_e_stop, mission_type_pipe_following, mission_type_unknown}'
end_var
var Bool mission_distance_0;
    variable_type FROZENVAR;
    max 2;
end_var
var Bool mission_distance_1;
    variable_type FROZENVAR;
    max 2;
end_var
var Bool mission_distance_2;
    variable_type FROZENVAR;
    max 2;
end_var


//-----------------------------------
//Blackboard nodes
//-----------------------------------

input battery2bb pixhawk_hw -> battery 
    var bool battery_low_warning = False;
    end_var
    arg float failsafe_battery_low_threshold=0.1;
    success True;
    failure False;
    running True;
    comment  "This node captures the state of the battery"
end

input ddlecam2bb lec_dd_am -> lec_dd_am
    var bool lec_dd_am_warning = False ;
    end_var
    arg float dd_threshold = 5.0 ;
    success True;
    failure False;
    running True;
    comment  "This node captures the state of the lec dd assurance monitor"
end

input rth2bb bb_rth -> bb_rth
    var bool bb_rth_warning = False;
    end_var
    arg bool failsafe_rth_enable =True;
    success True;
    failure False;
    running True;
    comment  "This node captures if the uuv is commanded to return to home"
end 

input geofence2bb bb_geofence -> bb_geofence
    var bool bb_geofence_warning = False;
    end_var
    success True;
    failure False;
    running True;
    comment  "This node captures if the uuv is within  the geofence"
end

input lec2_am_l_2bb  lec2_left_am -> lec2_am_l
    var bool lec2_am_l_speed_warning = False;
    end_var
    var bool lec2_am_l_pipe_warning = False;
    end_var
    arg float pipe_estimation_good_log_val = 5.0;
    arg float speed_good_log_val  = 2.5;
    success True;
    failure False;
    running True;
    comment  "This node captures the output of the lec2 assurance monitor left"
end

input lec2_am_r_2bb lec2_right_am -> lec2_am_r
    var bool lec2_am_r_speed_warning = False;
    end_var
    var bool lec2_am_r_pipe_warning = False;
    end_var
    arg float pipe_estimation_good_log_val =5.0;
    arg float speed_good_log_val =2.5;
    success True;
    failure False;
    running True;
    comment  "This node captures the output of the lec2 assurance monitor right"
end

input pipe_lost2bb bb_pipelost -> bb_pipelost
    var bool bb_pipe_lost_warning =False;
    end_var
    success True;
    failure False;
    running True;
    comment  "This node captures if the pipe is not in visibility of UUV"
end


input sensor_failure2bb  bb_sensor_failure -> bb_sensor_failure
    var bool bb_sensor_failure_warning =False;
    end_var
    success True;
    failure False;
    running True;
    comment  "This node captures sensor failure"
end

input waypoints_completed2bb  bb_waypoints_completed -> bb_waypoints_completed
    success True;
    failure False;
    running True;
    comment "This node captures if the waypoints are completed"
end 

input home2bb bb_home_dist -> bb_home_dist
    var bool bb_home_reached =False;
    end_var
    arg float home_reached_threshold =15;
    success True;
    failure False;
    running True;
    comment "This node captures if the uuv is home" 
end

input mission2bb bb_mission -> bb_mission
    arg bool enable_waypoint_following = False;
    success True;
    failure False;
    running True;
    comment  "This node captures the current mission"
end

input ddlec2bb degradation_detector -> dd_output 
    var bool dd_z_axis_warning = False;
    end_var
    var bool dd_xy_axis_degradation = False;
    end_var
    arg float decision_threshold = 0.7;
    arg float total_degradation_threshold=0.0;
    arg integer num_classes=22;
    success True;
    failure False;
    running True;
    comment  "This node captures the output of the DD LEC"
end   


//-----------------------------------
//checkers for blackboard variables
//-----------------------------------

//check is_reallocation_requested 
//        event_reallocate_button==False;

check is_reallocation_requested 
        dd_xy_axis_degradation == False;
	integer_representation 0;
end_check;

check check_dd_am 
        lec_dd_am_warning == False;
	integer_representation 0;
end_check


check check_lec2am_ls 
        lec2_am_l_speed_warning == False;
	integer_representation 0;
end_check


check check_lec2am_rs 
        lec2_am_r_speed_warning == False;
	integer_representation 0;
end_check


check check_lec2am_lp 
        lec2_am_l_pipe_warning == False;
	integer_representation 0;
end_check


check check_lec2am_rp 
        lec2_am_r_pipe_warning == False;
	integer_representation 0;
end_check


check check_geofence 
        bb_geofence_warning == False;
	integer_representation 0;
end_check


check check_rth 
        bb_rth_warning == False;
	integer_representation 0;
end_check


check check_surface 
        bb_home_reached ==False;
	integer_representation 0;
end_check


check check_pipe_post 
        bb_pipe_lost_warning == False;
	integer_representation 0;
end_check


check check_waypoints_completed 
        bb_waypoints_completed == True;
	integer_representation 1;
end_check


check check_sensor_failure 
        bb_sensor_failure_warning == False;
	integer_representation 0;
end_check


check battery_low_fs 
        battery_low_warning == False;
	integer_representation 0;
end_check


check is_track_pipe_mission_requested 
        bb_mission  == "pipe_track";
	integer_representation 0;
end_check

check is_waypoint_requested 
        bb_mission  == "waypoint";
	integer_representation 0;
end_check

check is_snr_requested 
        bb_mission  == "fdr";
	integer_representation 0;
end_check

check dd_z_axis
        dd_z_axis_warning == False;
	integer_representation 0;
end_check

check dd_xy_axis
        dd_xy_axis_degradation == False;
	integer_representation 0;
end_check

//-----------------------------------
//standard behavioral nodes
//-----------------------------------

success success_node;
failure failure_node;
running running_node;
running idle;
//running reallocate_task;
//running  dd_lec_task; 

//-----------------------------------
//custom behavioral nodes
//-----------------------------------

task surface_task
     in hsd_to_surface hsd_to_surface_;
     out cm_hsd_input cm_hsd_input_;
     var HSDCommand HSD_out;
     end_var
     success False;
     failure False;
     running True;	
end     

task  rth_task 
    in  hsd_to_rth hsd_to_rth_;
    out cm_hsd_input cm_hsd_input_;
    var HSDCommand HSD_out;
    end_var
     success False;
     failure False;
     running True;
end

task  loiter_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input  cm_hsd_input_;
    var HSDCommand HSD_out ;
    end_var
     success False;
     failure False;
     running True;
end    


task obstacle_avoidance
     in hsd_obstacle_avoidance hsd_obstacle_avoidance_;
     out hsd_command hsd_pub;
     var HSDCommand HSD_out;
     end_var
     var bool bb_obstacle_warning = False ;
     end_var
     success False;
     failure False;
     running True;
end     

task  speed_max_task 
    var HSDCommand HSD_out;
    end_var
    arg float uuv_max_speed=0.9;
     success False;
     failure False;
     running True;
end    

task  speed_min_task 
    var HSDCommand HSD_out;
    end_var
    arg float uuv_min_speed=0.4;
     success False;
     failure False;
     running True;
end

task  pipe_mapping_enable_task 
    var Bool pipe_mapping_enable;
    end_var
     success False;
     failure False;
     running True;
end    

task  pipe_mapping_disable_task 
    var Bool pipe_mapping_enable;
    end_var
     success False;
     failure False;
     running True;
end

task  tracking_task 
    in hsd_pipeline_mapping  hsd_pipeline_mapping_;
    out cm_hsd_input cm_hsd_input_;
    var HSDCommand HSD_out ;
    end_var
     success False;
     failure False;
     running True;
end    

task  waypoint_task 
    in hsd_to_waypoint hsd_waypoint_, bb_waypoints_completed hsd_waypoint_completed_;
	out cm_hsd_input cm_hsd_input_;
    var HSDCommand HSD_out ;
    end_var
     success False;
     failure False;
     running True;
end   

task  reallocate_task 
    var float total_degradation=0;
    end_var
     success False;
     failure False;
     running True;
end   

task dd_lec_task
    in lec_input lec_input_;
    out degradation_detector degradation_detector_, degradation_detector_am degradation_detector_am_;
    arg float[] normalizer=[1000, 1000, 1000, 1000, 1000, 1000, 6000, 6000, 6000, 6000, 6000, 6000, 30]; //why not working?
    arg float threshold=0.7;
    arg integer num_classes=22;
    arg integer ann_input_len=13;
     success False;
     failure False;
     running True;
end

//-----------------------------------
//tree definition
//-----------------------------------

tree(updatetime=500,timeout=15)
par BlueROV (success_on_all, False) {
    par topics2bb (success_on_all, False) {
		mon battery2bb, rth2bb, geofence2bb
        mon lec2_am_r_2bb, lec2_am_l_2bb, pipe_lost2bb
		mon sensor_failure2bb, waypoints_completed2bb
        mon mission2bb, ddlec2bb
	}
    sel dd_tasks (False) {
        do reallocate_check (False) {
			if is_reallocation_requested
			then {
				exec reallocate_task
			}
		}
        exec dd_lec_task

	}
    exec obstacle_avoidance
    sel priorities (False) {
		do battery_check (False){
			if battery_low_fs 
			then {
				exec surface_task
			}
		}
        do sensor_failure_selector (False){
			if check_sensor_failure
			then {
				exec surface_task
			}
		}

		do home_reached_selector  (False){
			if check_surface  
			then {
				exec surface_task 
			}
		}
		do rth_selector  (False){
			if check_rth  
			then {
				par rth_par (success_on_all, False) {
					exec rth_task  
					mon home2bb
				}
			}
		}
		do geofence_selector  (False){
			if check_geofence  
			then {
				par rth_par (success_on_all, False) {
					exec rth_task  
					mon home2bb
				} 
			}
		}
		do pipe_lost_selector  (False){
			if check_pipe_post  
			then {
				exec loiter_task
			}
		}
        seq track_pipe_mission (False)  {
			chk is_track_pipe_mission_requested
	        par tracking (success_on_all, False) {
                exec tracking_task  
                sel lec2am_speed_cmd (False) {
                    do lec2am_l_speed_check (False){
                        if check_lec2am_ls
                        then {
                            exec speed_min_task 
                        }
                    } 
                    do lec2am_r_speed_check  (False){
                        if check_lec2am_rs  
                        then {
                            exec speed_min_task
                        }
                    }
                    exec speed_max_task 
                }
                sel lec2am_mapping_cmd (False) {
                    do lec2am_l_mapping_check  (False){
                        if check_lec2am_lp  
                        then {
                            exec pipe_mapping_disable_task
                        }
                    }
                    do lec2am_r_mapping_check  (False){
                        if check_lec2am_rp  
                        then {
                            exec pipe_mapping_disable_task
                        }
                    }
                    exec pipe_mapping_enable_task
                }
            }
            seq track_pipe_mission_end (False) {
                timer evaluate(0.5)
            }
        }
        seq waypoint_mission  (False) {
			chk is_waypoint_requested 
            sel waypoint_selector (False) {
                sel waypoints_condition(failure) (False){
                    do waypoints_sif (False){
                        if check_waypoints_completed
                        then { 
                            exec waypoint_task
                        }
                    }
                }
                seq waypoint_end (False){
                    exec loiter_task
                    exec running_node
                }
            }
		}
        exec idle
    }
}

//-------done------------------