Assumptions:
1. Each node returns instantly.
2. No time passes in the environment between the start and end of a tree ticking, and the environment is static during the tick (unless changed by the tree).


First, let us consider behavior trees without memory and an abstracted environment.

We will define a Behavior Tree as an extended state machine using the following rules.
Assume we have n+1 nodes. Label the nodes node0, node1, node2...noden where nodei is the ith node reached when traversing the tree using a Depth First Search started from the root.
Our set of states is given by {{node0, node1, ... noden} mode, {invalid, running, failure, success} status0, ... {invalid, running, failure, success} statusn}
The initial state is {(node0, invalid, invalid..., invalid)}.
The set of transitions T := C UNION P UNION S UNION R
where C is the set of transitions to children, P is the set of transtions to parent, S is the set of status transitions, R is the set of root transitions.
C is defined using these rules:
if nodej is a child of nodei and nodei is a sequence node, then (nodei, ...) -> (nodej, ...) if statusj = invalid and statusi = invalid and forall k<j, statusk = success or nodek not in children(nodei)
if nodej is a child of nodei and nodei is a selector node, then (nodei, ...) -> (nodej, ...) if statusj = invalid and statusi = invalid and forall k<j, statusk = failure or nodek not in children(nodei)
if nodej is a child of nodei and nodei is a parallel node, then (nodei, ...) -> (nodej, ...) if statusj = invalid and statusi = invalid and forall k<j, statusk != invalid or nodek not in children(nodei)
if nodej is a child of nodei and nodei is a decorator node, then (nodei, ...) -> (nodej, ...) if statusj = invalid and statusi = invalid and forall k<j, statusk != invalid or nodek not in children(nodei)

P
if nodej is a child of nodei and nodei is a sequence node and A \in {running, failure}, then (nodej, ... statusi=invalid ... statusj=A ...) -> (nodei, ... statusi=A ... statusj=A ...).
if nodej is a child of nodei and nodei is a sequence node, then (nodej, ... statusi=invalid ... statusj=success ...) -> (nodei, ... statusi=success ... statusj=success ...) if \forall k>j, nodek \notin children(nodei).
if nodej is a child of nodei and nodei is a sequence node, then (nodej, ... statusi=invalid ... statusj=success ...) -> (nodei, ... statusi=invalid ... statusj=success ...) if \exists k>j s.t. nodek \in children(nodei).
if nodej is a child of nodei and nodei is a selector node and A \in {running, success}, then (nodej, ... statusi=invalid ... statusj=A ...) -> (nodei, ... statusi=A ... statusj=A ...).
if nodej is a child of nodei and nodei is a selector node, then (nodej, ... statusi=invalid ... statusj=failure ...) -> (nodei, ... statusi=failure ... statusj=failure ...) if \forall k>j, nodek \notin children(nodei).
if nodej is a child of nodei and nodei is a sequence node, then (nodej, ... statusi=invalid ... statusj=failure ...) -> (nodei, ... statusi=invalid ... statusj=failure ...) if \exists k>j s.t. nodek \in children(nodei).
if nodej is a child of nodei and nodei is a parallel node and A \neq invalid and B \neq invalid, then (nodej, ... statusi=invalid ... statusj=A ...) -> (nodei, ... statusi=B ... statusj=A ...) if \forall k>j, nodek \notin children(nodei). Here B is based on the policy of the parallel node.
if nodej is a child of nodei and nodei is a parallel node and A \neq invalid, then (nodej, ... statusi=invalid ... statusj=A ...) -> (nodei, ... statusi=invalid ... statusj=A ...) if \exists k>j s.t. nodek \in children(nodei).

S
if nodej is a leaf node, then the appropriate loops for nodej to nodej to set it's status exist.

R
node0 is the root. We also have the special loop (node0, status0/neq invalid ....) -> (node0, status0=invalid, status1=invalid, status2=invalid...statusk=invalid...statusn=invalid).

--------------------------------------------------------------------------

ok, we need to figure out


--------------------------------------------------------------------------
Turing complete

We will allow the behavior tree to use the following leaf nodes:
1. for each symbol s in the alphabet, a node which reads the symbol r from the tape and returns success if r=s. (also nodes which do this with running and failure).
2. for each symbol s in the alphabet, a node which writes the symbol to the tape and returns success. (also nodes which do this with running and failure).
3. for each direction d in {L, R}, a node which causes the head to move in the direction and returns success. (also nodes which do this with running and failure).

The behavior tree will also be able to use selector, sequence, and parallel nodes.

A behavior tree with memory will also be able to use selectorM, sequenceM, and parallelM nodes, where those are nodes with memory. 

First, assume that T is a turing machine and BT is a behavior tree without memory or blackboard. Furthermore, let T have two states, A and B, and let 1 be a symbol that can appear on the tape. Then let T go left if a 1 is read and the state is A, and let T go right if a 1 is read and the state is B. Then observe that since BT has no memory or blackboard, it is effectively a function from the input symbols to the actions. Therefore, it cannot possibly be capable of reproducing this behavior, as a function will provide the same output when given the same inputs.

Therefore, some form of memory is needed in order for a behavior tree to be turing complete.

Next, let T be a turing machine. Then let 