/******************************************************************************
 * monitor code generated by NuRV (NuRV_lite version: 1.0.0)
 *
 * LTL:  G system.drone_x < 3
 *
 * nbits_obs: 3 (width: 1), nbits_all: 3 (width: 1)
 * reset_table: 1, trans_table: 1, input_filter: 0
 ******************************************************************************/

#include <stdio.h>  /* for FILE, etc. */
#include <stddef.h> /* for size_t */
#include <stdlib.h> /* for bsearch() */
#include <stdint.h> /* for int8_t, etc. */
#include <string.h> /* for memset() */
#include <assert.h> /* for assert() */

#include "monitor_simplest.h"

/* maximum number of elements in each line: 20 */
static int reset_table[19] = {
  0, 1, 18, 12, 18, 15, 15, 12, 10, 10, 10, 15, 12, 18, 12, 15, 18, 15, 18
};

/* for internal per-monitor use only */
typedef struct {
  long input;
  int output;
  int next_loc;
} trans_t;

/* maximum number of elements in each line: 4 */
static trans_t data_18[2] = {
  {0x0L, 0, 4}, {0x4L, 0, 6}
};

static trans_t data_17[2] = {
  {0x1L, 2, 13}, {0x5L, 2, 14}
};

static trans_t data_16[2] = {
  {0x0L, 2, 16}, {0x4L, 2, 17}
};

static trans_t data_15[2] = {
  {0x1L, 0, 2}, {0x5L, 0, 3}
};

static trans_t data_14[2] = {
  {0x2L, 2, 11}, {0x6L, 2, 8}
};

static trans_t data_13[2] = {
  {0x0L, 2, 16}, {0x4L, 2, 17}
};

static trans_t data_12[2] = {
  {0x2L, 0, 5}, {0x6L, 2, 8}
};

static trans_t data_11[2] = {
  {0x1L, 2, 13}, {0x5L, 2, 14}
};

static trans_t data_10[2] = {
  {0x3L, 2, 7}, {0x7L, 2, 9}
};

static trans_t data_9[2] = {
  {0x3L, 2, 7}, {0x7L, 2, 9}
};

static trans_t data_8[2] = {
  {0x3L, 2, 7}, {0x7L, 2, 9}
};

static trans_t data_7[2] = {
  {0x2L, 2, 11}, {0x6L, 2, 8}
};

static trans_t data_6[2] = {
  {0x1L, 0, 2}, {0x5L, 0, 3}
};

static trans_t data_5[2] = {
  {0x1L, 0, 2}, {0x5L, 0, 3}
};

static trans_t data_4[2] = {
  {0x0L, 0, 4}, {0x4L, 0, 6}
};

static trans_t data_3[2] = {
  {0x2L, 0, 5}, {0x6L, 2, 8}
};

static trans_t data_2[2] = {
  {0x0L, 0, 4}, {0x4L, 0, 6}
};

static trans_t data_1[8] = {
  {0x0L, 0, 4}, {0x1L, 0, 2}, {0x2L, 0, 5}, {0x3L, 2, 7}, /* L1 */
  {0x4L, 0, 6}, {0x5L, 0, 3}, {0x6L, 2, 8}, {0x7L, 2, 9} /* L2 */
};

static int data_cmp (const void *lhs, const void *rhs)
{
  const trans_t *_lhs = (const trans_t *)lhs;
  const trans_t *_rhs = (const trans_t *)rhs;

  return (_lhs -> input - _rhs -> input);
}

static trans_t* data_table[19] = {
  NULL, data_1, data_2, data_3, data_4, data_5, data_6, data_7, /* L1 */
  data_8, data_9, data_10, data_11, data_12, data_13, data_14, data_15, /* L2 */
  data_16, data_17, data_18
};

/* number of elements in each line: 20 */
static size_t size_table[19] = {
  0, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};

/* 3. main function (old API) */
int /* [out] (0 = unknown, 1 = true, 2 = false, 3 = error) */
  monitor_simplest
    (long state,       /* [in] */
     int  reset,       /* [in] (0 = none, 1 = hard, 2 = soft) */
     int *current_loc) /* [in/out] */
{
  long states[1], base = 1L;

  states[0] = (state % 2L) * base;
  state >>= 1;
  base <<= 1;
  states[0] += (state % 2L) * base;
  state >>= 1;
  base <<= 1;
  states[0] += (state % 2L) * base;

  return monitor_simplest_ex (states, 1, reset, current_loc);
}

/* internal function (no input filtering) */
static RV_value monitor_simplest_internal
  (long    *inputs,      /* [in] */
   size_t   width,       /* [in] (min: 1) */
   RV_reset reset,       /* [in] */
   int     *current_loc) /* [in/out] */
{
  /* local variables */
  trans_t *table, key, *result; /* for bsearch() */
  size_t size;                  /* for bsearch() */
  RV_value output;

  /* validate inputs (part 1) */
  if (NULL == current_loc) {
    return RV_INVALID_LOC;
  }

  /* handle resets */
  if (HARD_RESET == reset) {
    *current_loc = 1; /* initial location */
  }

  /* validate inputs (part 2) */
  if (*current_loc <= 0 || *current_loc > 18) {
    return RV_INVALID_LOC;
  }
  if (width < 1) return RV_INVALID_ARG;

  if (SOFT_RESET == reset) {
    int i = *current_loc;
    *current_loc = reset_table[i];
  }

  /* perform binary search */
  table = data_table[*current_loc];
  size = size_table[*current_loc];
  if (0 == size) {
    result = NULL;
  } else {
    key.input = inputs[0];
    result = (trans_t *)bsearch(&key, table, size, sizeof(trans_t), data_cmp);
  }
  if (result) {
    output = result->output;
    *current_loc = result->next_loc;
  } else {
    output = RV_ERROR;
  }

  return output;
}

/* 4. main function (new API) */
RV_value monitor_simplest_ex
  (long    *states,      /* [in] */
   size_t   width,       /* [in] (min: 1) */
   RV_reset reset,       /* [in] */
   int     *current_loc) /* [in/out] */
{
  return monitor_simplest_internal(states, 1, reset, current_loc);
}

/* scalar support */
typedef struct {int key; int value;} scalar_t;

static int scalar_cmp (const void *lhs, const void *rhs)
{
  const scalar_t *_lhs = (const scalar_t *)lhs;
  const scalar_t *_rhs = (const scalar_t *)rhs;

  return (_lhs -> key - _rhs -> key);
}

static scalar_t system_drone_x_map[4] = {
  {0, 0x0}, {1, 0x2}, {2, 0x1}, {3, 0x3}
};

static scalar_t system_current_action_map[2] = {
  {right, 0x1}, {left, 0x0}
};

/* 5. The scalar monitor interface */
RV_value monitor_simplest_scalar
  (monitor_simplest_input_t *input,
   monitor_simplest_mask_t *masks,
   RV_reset reset,
   int *current_loc)
{
  long inputs[1];
  scalar_t item, *result = NULL;
  int system_drone_x = input->system_drone_x;
  int system_current_action = input->system_current_action;
  int bit, bits;

  memset((void *)inputs, 0, 1 * sizeof(long));
  item.key = system_drone_x;
  result = (scalar_t *)bsearch(&item, system_drone_x_map, 4, sizeof(scalar_t), scalar_cmp);
  if ((scalar_t *)NULL == result) { return RV_INVALID_ARG; }
  bits = result->value;
  bit = (bits >> 1) & 1;
  inputs[0] += (bit == 1) ? 0x1L /* 2^0 */ : 0L;
  bit = bits & 1;
  inputs[0] += (bit == 1) ? 0x2L /* 2^1 */ : 0L;
  item.key = system_current_action;
  result = (scalar_t *)bsearch(&item, system_current_action_map, 2, sizeof(scalar_t), scalar_cmp);
  if ((scalar_t *)NULL == result) { return RV_INVALID_ARG; }
  bits = result->value;
  bit = bits & 1;
  inputs[0] += (bit == 1) ? 0x4L /* 2^2 */ : 0L;

  return monitor_simplest_internal(inputs, 1, reset, current_loc);
}
