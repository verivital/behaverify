/******************************************************************************
 * monitor code generated by NuRV (NuRV_lite version: 1.0.0)
 *
 * LTL:  G system.drone_x != 1
 *
 * nbits_obs: 9 (width: 1), nbits_all: 9 (width: 1)
 * reset_table: 1, trans_table: 1, input_filter: 0
 ******************************************************************************/

#ifndef NURV_CODEGEN_MONITOR_MONITOR
#define NURV_CODEGEN_MONITOR_MONITOR

#ifndef NURV_CODEGEN_TYPES
#define NURV_CODEGEN_TYPES 1
typedef enum {
  RV_UNKNOWN     = 0,
  RV_TRUE        = 1,
  RV_FALSE       = 2,
  RV_ERROR       = 3,
  RV_INVALID_ARG = 4,
  RV_INVALID_LOC = 5,
  RV_INVALID_MON = 6,
} RV_value;

#ifdef __GNUC__
#define RV_value_string(z) \
     ({__typeof__(z) x = z; \
       (x == RV_UNKNOWN     ? "unknown" : \
        x == RV_TRUE        ? "true" : \
        x == RV_FALSE       ? "false" : \
        x == RV_ERROR       ? "out-of-model" : \
        x == RV_INVALID_ARG ? "invalid inputs" : \
        x == RV_INVALID_LOC ? "invalid location" : "");})
#else
#define RV_value_string(x) \
       (x == RV_UNKNOWN     ? "unknown" : \
        x == RV_TRUE        ? "true" : \
        x == RV_FALSE       ? "false" : \
        x == RV_ERROR       ? "out-of-model" : \
        x == RV_INVALID_ARG ? "invalid inputs" : \
        x == RV_INVALID_LOC ? "invalid location" : "")
#endif

typedef enum {
  NO_RESET   = 0,
  HARD_RESET = 1,
  SOFT_RESET = 2 
} RV_reset;
#endif /* NURV_CODEGEN_TYPES */

/* 1. old API */
int /* [out] (0 = unknown, 1 = true, 2 = false, 3 = error) */
  monitor
    (long /* [in] state */,
     int  /* [in] reset (0 = none, 1 = hard, 2 = soft) */,
     int* /* [in/out] current_loc */);

#define monitor_segment 30 /* number of 'bits' stored in each long state */
#define monitor_width   1 /* minimal value of 'width' in the function call */

/* 2. new API */
RV_value monitor_ex
  (long    *states,       /* [in] */
   size_t   width,        /* [in] (min: 1) */
   RV_reset reset,        /* [in] (HARD_RESET is necessary for the first call) */
   int     *current_loc); /* [in/out] (after HARD_RESET it is 1) */

/* INFO: input ordering:
   system_drone_x.1 (system.drone_x.1) : 0
   system_drone_x.0 (system.drone_x.0) : 1
   system_drone_y.1 (system.drone_y.1) : 2
   system_drone_y.0 (system.drone_y.0) : 3
   system_drone_speed.0 (system.drone_speed.0) : 4
   system_going_left (system.going_left) : 5
   system_going_right (system.going_right) : 6
   system_going_down (system.going_down) : 7
   system_going_up (system.going_up) : 8
*/

/* input data */
typedef struct {
  int system_drone_x;
  int system_drone_y;
  int system_drone_speed;
  int system_going_left;
  int system_going_right;
  int system_going_down;
  int system_going_up;
} monitor_input_t;

/* input masks (0: not observable, 1: observable) */
typedef struct {
  unsigned int system_drone_x : 1;
  unsigned int system_drone_y : 1;
  unsigned int system_drone_speed : 1;
  unsigned int system_going_left : 1;
  unsigned int system_going_right : 1;
  unsigned int system_going_down : 1;
  unsigned int system_going_up : 1;
} monitor_mask_t;

/* 3. scalar API */
RV_value monitor_scalar
  (monitor_input_t *input,
   monitor_mask_t *masks, /* NULL (no masks) means fully observable */
   RV_reset reset,
   int *current_loc);

#endif /* NURV_CODEGEN_MONITOR_MONITOR */
