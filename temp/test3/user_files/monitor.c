/******************************************************************************
 * monitor code generated by NuRV (NuRV_lite version: 1.0.0)
 *
 * LTL:  G ( F system.counter_stage_1 > 5)
 *
 * nbits_obs: 4 (width: 1), nbits_all: 4 (width: 1)
 * reset_table: 1, trans_table: 1, input_filter: 0
 ******************************************************************************/

#include <stdio.h>  /* for FILE, etc. */
#include <stddef.h> /* for size_t */
#include <stdlib.h> /* for bsearch() */
#include <stdint.h> /* for int8_t, etc. */
#include <string.h> /* for memset() */
#include <assert.h> /* for assert() */

#include "monitor.h"

/* maximum number of elements in each line: 20 */
static int reset_table[29] = {
  0, 1, 4, 6, 4, 9, 6, 12, 12, 9, 15, 15, 12, 18, 18, 15, 21, 21, 18, 23, /* L1 */
  23, 21, 25, 23, 27, 25, 28, 27, 28
};

/* for internal per-monitor use only */
typedef struct {
  long input;
  int output;
  int next_loc;
} trans_t;

/* maximum number of elements in each line: 4 */
static trans_t data_28[1] = {
  {0xaL, 1, 26}};

static trans_t data_27[2] = {
  {0x9L, 1, 24}, {0xaL, 1, 26}
};

static trans_t data_26[1] = {
  {0xaL, 1, 26}};

static trans_t data_25[2] = {
  {0x8L, 1, 22}, {0x9L, 1, 24}
};

static trans_t data_24[2] = {
  {0x9L, 1, 24}, {0xaL, 1, 26}
};

static trans_t data_23[3] = {
  {0x7L, 1, 19}, {0x8L, 1, 22}, {0xfL, 1, 20}
};

static trans_t data_22[2] = {
  {0x8L, 1, 22}, {0x9L, 1, 24}
};

static trans_t data_21[4] = {
  {0x6L, 1, 16}, {0x7L, 1, 19}, {0xeL, 1, 17}, {0xfL, 1, 20} /* L1 */
};

static trans_t data_20[3] = {
  {0x7L, 1, 19}, {0x8L, 1, 22}, {0xfL, 1, 20}
};

static trans_t data_19[3] = {
  {0x7L, 1, 19}, {0x8L, 1, 22}, {0xfL, 1, 20}
};

static trans_t data_18[4] = {
  {0x5L, 0, 13}, {0x6L, 1, 16}, {0xdL, 0, 14}, {0xeL, 1, 17} /* L1 */
};

static trans_t data_17[4] = {
  {0x6L, 1, 16}, {0x7L, 1, 19}, {0xeL, 1, 17}, {0xfL, 1, 20} /* L1 */
};

static trans_t data_16[4] = {
  {0x6L, 1, 16}, {0x7L, 1, 19}, {0xeL, 1, 17}, {0xfL, 1, 20} /* L1 */
};

static trans_t data_15[4] = {
  {0x4L, 0, 10}, {0x5L, 0, 13}, {0xcL, 0, 11}, {0xdL, 0, 14} /* L1 */
};

static trans_t data_14[4] = {
  {0x5L, 0, 13}, {0x6L, 1, 16}, {0xdL, 0, 14}, {0xeL, 1, 17} /* L1 */
};

static trans_t data_13[4] = {
  {0x5L, 0, 13}, {0x6L, 1, 16}, {0xdL, 0, 14}, {0xeL, 1, 17} /* L1 */
};

static trans_t data_12[4] = {
  {0x3L, 0, 7}, {0x4L, 0, 10}, {0xbL, 0, 8}, {0xcL, 0, 11} /* L1 */
};

static trans_t data_11[4] = {
  {0x4L, 0, 10}, {0x5L, 0, 13}, {0xcL, 0, 11}, {0xdL, 0, 14} /* L1 */
};

static trans_t data_10[4] = {
  {0x4L, 0, 10}, {0x5L, 0, 13}, {0xcL, 0, 11}, {0xdL, 0, 14} /* L1 */
};

static trans_t data_9[3] = {
  {0x2L, 0, 5}, {0x3L, 0, 7}, {0xbL, 0, 8}
};

static trans_t data_8[4] = {
  {0x3L, 0, 7}, {0x4L, 0, 10}, {0xbL, 0, 8}, {0xcL, 0, 11} /* L1 */
};

static trans_t data_7[4] = {
  {0x3L, 0, 7}, {0x4L, 0, 10}, {0xbL, 0, 8}, {0xcL, 0, 11} /* L1 */
};

static trans_t data_6[2] = {
  {0x1L, 0, 3}, {0x2L, 0, 5}
};

static trans_t data_5[3] = {
  {0x2L, 0, 5}, {0x3L, 0, 7}, {0xbL, 0, 8}
};

static trans_t data_4[2] = {
  {0x0L, 0, 2}, {0x1L, 0, 3}
};

static trans_t data_3[2] = {
  {0x1L, 0, 3}, {0x2L, 0, 5}
};

static trans_t data_2[2] = {
  {0x0L, 0, 2}, {0x1L, 0, 3}
};

static trans_t data_1[1] = {
  {0x0L, 0, 2}};

static int data_cmp (const void *lhs, const void *rhs)
{
  const trans_t *_lhs = (const trans_t *)lhs;
  const trans_t *_rhs = (const trans_t *)rhs;

  return (_lhs -> input - _rhs -> input);
}

static trans_t* data_table[29] = {
  NULL, data_1, data_2, data_3, data_4, data_5, data_6, data_7, /* L1 */
  data_8, data_9, data_10, data_11, data_12, data_13, data_14, data_15, /* L2 */
  data_16, data_17, data_18, data_19, data_20, data_21, data_22, data_23, /* L3 */
  data_24, data_25, data_26, data_27, data_28
};

/* number of elements in each line: 20 */
static size_t size_table[29] = {
  0, 1, 2, 2, 2, 3, 2, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, /* L1 */
  3, 4, 2, 3, 2, 2, 1, 2, 1
};

/* 3. main function (old API) */
int /* [out] (0 = unknown, 1 = true, 2 = false, 3 = error) */
  monitor
    (long state,       /* [in] */
     int  reset,       /* [in] (0 = none, 1 = hard, 2 = soft) */
     int *current_loc) /* [in/out] */
{
  long states[1], base = 1L;

  states[0] = (state % 2L) * base;
  state >>= 1;
  base <<= 1;
  states[0] += (state % 2L) * base;
  state >>= 1;
  base <<= 1;
  states[0] += (state % 2L) * base;
  state >>= 1;
  base <<= 1;
  states[0] += (state % 2L) * base;

  return monitor_ex (states, 1, reset, current_loc);
}

/* internal function (no input filtering) */
static RV_value monitor_internal
  (long    *inputs,      /* [in] */
   size_t   width,       /* [in] (min: 1) */
   RV_reset reset,       /* [in] */
   int     *current_loc) /* [in/out] */
{
  /* local variables */
  trans_t *table, key, *result; /* for bsearch() */
  size_t size;                  /* for bsearch() */
  RV_value output;

  /* validate inputs (part 1) */
  if (NULL == current_loc) {
    printf("hello");
    return RV_INVALID_LOC;
  }

  /* handle resets */
  if (HARD_RESET == reset) {
    *current_loc = 1; /* initial location */
  }

  /* validate inputs (part 2) */
  if (*current_loc <= 0 || *current_loc > 28) {
    printf("hello2");
    return RV_INVALID_LOC;
  }
  if (width < 1) return RV_INVALID_ARG;

  if (SOFT_RESET == reset) {
    int i = *current_loc;
    *current_loc = reset_table[i];
  }

  /* perform binary search */
  table = data_table[*current_loc];
  size = size_table[*current_loc];
  if (0 == size) {
    result = NULL;
  } else {
    key.input = inputs[0];
    result = (trans_t *)bsearch(&key, table, size, sizeof(trans_t), data_cmp);
  }
  if (result) {
    output = result->output;
    *current_loc = result->next_loc;
  } else {
    output = RV_ERROR;
  }

  return output;
}

/* 4. main function (new API) */
RV_value monitor_ex
  (long    *states,      /* [in] */
   size_t   width,       /* [in] (min: 1) */
   RV_reset reset,       /* [in] */
   int     *current_loc) /* [in/out] */
{
  return monitor_internal(states, 1, reset, current_loc);
}

/* scalar support */
typedef struct {int key; int value;} scalar_t;

static int scalar_cmp (const void *lhs, const void *rhs)
{
  const scalar_t *_lhs = (const scalar_t *)lhs;
  const scalar_t *_rhs = (const scalar_t *)rhs;

  return (_lhs -> key - _rhs -> key);
}

static scalar_t system_counter_stage_1_map[11] = {
  {0, 0x0}, {1, 0x8}, {2, 0x4}, {3, 0xc},
  {4, 0x2}, {5, 0xa}, {6, 0x6}, {7, 0xe},
  {8, 0x1}, {9, 0x9}, {10, 0x5}
};

/* 5. The scalar monitor interface */
RV_value monitor_scalar
  (monitor_input_t *input,
   monitor_mask_t *masks,
   RV_reset reset,
   int *current_loc)
{
  long inputs[1];
  scalar_t item, *result = NULL;
  int system_counter_stage_1 = input->system_counter_stage_1;
  int bit, bits;

  memset((void *)inputs, 0, 1 * sizeof(long));
  item.key = system_counter_stage_1;
  result = (scalar_t *)bsearch(&item, system_counter_stage_1_map, 11, sizeof(scalar_t), scalar_cmp);
  if ((scalar_t *)NULL == result) { return RV_INVALID_ARG; }
  bits = result->value;
  bit = (bits >> 3) & 1;
  inputs[0] += (bit == 1) ? 0x1L /* 2^0 */ : 0L;
  bit = (bits >> 2) & 1;
  inputs[0] += (bit == 1) ? 0x2L /* 2^1 */ : 0L;
  bit = (bits >> 1) & 1;
  inputs[0] += (bit == 1) ? 0x4L /* 2^2 */ : 0L;
  bit = bits & 1;
  inputs[0] += (bit == 1) ? 0x8L /* 2^3 */ : 0L;

  return monitor_internal(inputs, 1, reset, current_loc);
}
