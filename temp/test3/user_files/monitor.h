/******************************************************************************
 * monitor code generated by NuRV (NuRV_lite version: 1.0.0)
 *
 * LTL:  G ( F system.counter_stage_1 > 5)
 *
 * nbits_obs: 4 (width: 1), nbits_all: 4 (width: 1)
 * reset_table: 1, trans_table: 1, input_filter: 0
 ******************************************************************************/

#ifndef NURV_CODEGEN_MONITOR_MONITOR
#define NURV_CODEGEN_MONITOR_MONITOR

#ifndef NURV_CODEGEN_TYPES
#define NURV_CODEGEN_TYPES 1
typedef enum {
  RV_UNKNOWN     = 0,
  RV_TRUE        = 1,
  RV_FALSE       = 2,
  RV_ERROR       = 3,
  RV_INVALID_ARG = 4,
  RV_INVALID_LOC = 5,
  RV_INVALID_MON = 6,
} RV_value;

#ifdef __GNUC__
#define RV_value_string(z) \
     ({__typeof__(z) x = z; \
       (x == RV_UNKNOWN     ? "unknown" : \
        x == RV_TRUE        ? "true" : \
        x == RV_FALSE       ? "false" : \
        x == RV_ERROR       ? "out-of-model" : \
        x == RV_INVALID_ARG ? "invalid inputs" : \
        x == RV_INVALID_LOC ? "invalid location" : "");})
#else
#define RV_value_string(x) \
       (x == RV_UNKNOWN     ? "unknown" : \
        x == RV_TRUE        ? "true" : \
        x == RV_FALSE       ? "false" : \
        x == RV_ERROR       ? "out-of-model" : \
        x == RV_INVALID_ARG ? "invalid inputs" : \
        x == RV_INVALID_LOC ? "invalid location" : "")
#endif

typedef enum {
  NO_RESET   = 0,
  HARD_RESET = 1,
  SOFT_RESET = 2 
} RV_reset;
#endif /* NURV_CODEGEN_TYPES */

/* 1. old API */
int /* [out] (0 = unknown, 1 = true, 2 = false, 3 = error) */
  monitor
    (long /* [in] state */,
     int  /* [in] reset (0 = none, 1 = hard, 2 = soft) */,
     int* /* [in/out] current_loc */);

#define monitor_segment 30 /* number of 'bits' stored in each long state */
#define monitor_width   1 /* minimal value of 'width' in the function call */

/* 2. new API */
RV_value monitor_ex
  (long    *states,       /* [in] */
   size_t   width,        /* [in] (min: 1) */
   RV_reset reset,        /* [in] (HARD_RESET is necessary for the first call) */
   int     *current_loc); /* [in/out] (after HARD_RESET it is 1) */

/* INFO: input ordering:
   system_counter_stage_1.3 (system.counter_stage_1.3) : 0
   system_counter_stage_1.2 (system.counter_stage_1.2) : 1
   system_counter_stage_1.1 (system.counter_stage_1.1) : 2
   system_counter_stage_1.0 (system.counter_stage_1.0) : 3
*/

/* input data */
typedef struct {
  int system_counter_stage_1;
} monitor_input_t;

/* input masks (0: not observable, 1: observable) */
typedef struct {
  unsigned int system_counter_stage_1 : 1;
} monitor_mask_t;

/* 3. scalar API */
RV_value monitor_scalar
  (monitor_input_t *input,
   monitor_mask_t *masks, /* NULL (no masks) means fully observable */
   RV_reset reset,
   int *current_loc);

#endif /* NURV_CODEGEN_MONITOR_MONITOR */
